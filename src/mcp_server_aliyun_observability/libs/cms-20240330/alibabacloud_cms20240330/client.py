# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from typing import Dict
from Tea.core import TeaCore

from alibabacloud_tea_openapi.client import Client as OpenApiClient
from alibabacloud_tea_openapi import models as open_api_models
from alibabacloud_tea_util.client import Client as UtilClient
from alibabacloud_endpoint_util.client import Client as EndpointUtilClient
from alibabacloud_cms20240330 import models as cms_20240330_models
from alibabacloud_tea_util import models as util_models
from alibabacloud_openapi_util.client import Client as OpenApiUtilClient


class Client(OpenApiClient):
    """
    *\
    """
    def __init__(
        self, 
        config: open_api_models.Config,
    ):
        super().__init__(config)
        self._endpoint_rule = ''
        self.check_config(config)
        self._endpoint = self.get_endpoint('cms', self._region_id, self._endpoint_rule, self._network, self._suffix, self._endpoint_map, self._endpoint)

    def get_endpoint(
        self,
        product_id: str,
        region_id: str,
        endpoint_rule: str,
        network: str,
        suffix: str,
        endpoint_map: Dict[str, str],
        endpoint: str,
    ) -> str:
        if not UtilClient.empty(endpoint):
            return endpoint
        if not UtilClient.is_unset(endpoint_map) and not UtilClient.empty(endpoint_map.get(region_id)):
            return endpoint_map.get(region_id)
        return EndpointUtilClient.get_endpoint_rules(product_id, region_id, endpoint_rule, network, suffix)

    def active_contact_channel_with_options(
        self,
        request: cms_20240330_models.ActiveContactChannelRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ActiveContactChannelResponse:
        """
        @summary 激活验证码
        
        @param request: ActiveContactChannelRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ActiveContactChannelResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.code):
            query['code'] = request.code
        if not UtilClient.is_unset(request.site):
            query['site'] = request.site
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ActiveContactChannel',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contacts/action/activate',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ActiveContactChannelResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ActiveContactChannelResponse(),
                self.execute(params, req, runtime)
            )

    async def active_contact_channel_with_options_async(
        self,
        request: cms_20240330_models.ActiveContactChannelRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ActiveContactChannelResponse:
        """
        @summary 激活验证码
        
        @param request: ActiveContactChannelRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ActiveContactChannelResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.code):
            query['code'] = request.code
        if not UtilClient.is_unset(request.site):
            query['site'] = request.site
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ActiveContactChannel',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contacts/action/activate',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ActiveContactChannelResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ActiveContactChannelResponse(),
                await self.execute_async(params, req, runtime)
            )

    def active_contact_channel(
        self,
        request: cms_20240330_models.ActiveContactChannelRequest,
    ) -> cms_20240330_models.ActiveContactChannelResponse:
        """
        @summary 激活验证码
        
        @param request: ActiveContactChannelRequest
        @return: ActiveContactChannelResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.active_contact_channel_with_options(request, headers, runtime)

    async def active_contact_channel_async(
        self,
        request: cms_20240330_models.ActiveContactChannelRequest,
    ) -> cms_20240330_models.ActiveContactChannelResponse:
        """
        @summary 激活验证码
        
        @param request: ActiveContactChannelRequest
        @return: ActiveContactChannelResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.active_contact_channel_with_options_async(request, headers, runtime)

    def check_dispatch_role_with_options(
        self,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CheckDispatchRoleResponse:
        """
        @summary 检查用户是否已经开通了 AliyunLogDispatchRole 角色
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CheckDispatchRoleResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='CheckDispatchRole',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alert/user/dispatchRole/checkAuth',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CheckDispatchRoleResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CheckDispatchRoleResponse(),
                self.execute(params, req, runtime)
            )

    async def check_dispatch_role_with_options_async(
        self,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CheckDispatchRoleResponse:
        """
        @summary 检查用户是否已经开通了 AliyunLogDispatchRole 角色
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CheckDispatchRoleResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='CheckDispatchRole',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alert/user/dispatchRole/checkAuth',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CheckDispatchRoleResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CheckDispatchRoleResponse(),
                await self.execute_async(params, req, runtime)
            )

    def check_dispatch_role(self) -> cms_20240330_models.CheckDispatchRoleResponse:
        """
        @summary 检查用户是否已经开通了 AliyunLogDispatchRole 角色
        
        @return: CheckDispatchRoleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.check_dispatch_role_with_options(headers, runtime)

    async def check_dispatch_role_async(self) -> cms_20240330_models.CheckDispatchRoleResponse:
        """
        @summary 检查用户是否已经开通了 AliyunLogDispatchRole 角色
        
        @return: CheckDispatchRoleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.check_dispatch_role_with_options_async(headers, runtime)

    def count_alert_histories_by_fields_with_options(
        self,
        tmp_req: cms_20240330_models.CountAlertHistoriesByFieldsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CountAlertHistoriesByFieldsResponse:
        """
        @summary 根据告警历史的字段取值(group by)统计告警历史的数量
        
        @param tmp_req: CountAlertHistoriesByFieldsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CountAlertHistoriesByFieldsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.CountAlertHistoriesByFieldsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.field_list):
            request.field_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.field_list, 'fieldList', 'json')
        if not UtilClient.is_unset(tmp_req.label_filter):
            request.label_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.label_filter, 'labelFilter', 'json')
        if not UtilClient.is_unset(tmp_req.notification_filter):
            request.notification_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.notification_filter, 'notificationFilter', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_rule_id):
            query['alertRuleId'] = request.alert_rule_id
        if not UtilClient.is_unset(request.biz_source):
            query['bizSource'] = request.biz_source
        if not UtilClient.is_unset(request.display_name_key_word):
            query['displayNameKeyWord'] = request.display_name_key_word
        if not UtilClient.is_unset(request.field_list_shrink):
            query['fieldList'] = request.field_list_shrink
        if not UtilClient.is_unset(request.instance_key):
            query['instanceKey'] = request.instance_key
        if not UtilClient.is_unset(request.label_filter_shrink):
            query['labelFilter'] = request.label_filter_shrink
        if not UtilClient.is_unset(request.latest_level):
            query['latestLevel'] = request.latest_level
        if not UtilClient.is_unset(request.max_level):
            query['maxLevel'] = request.max_level
        if not UtilClient.is_unset(request.notification_filter_shrink):
            query['notificationFilter'] = request.notification_filter_shrink
        if not UtilClient.is_unset(request.start_time_from):
            query['startTimeFrom'] = request.start_time_from
        if not UtilClient.is_unset(request.start_time_to):
            query['startTimeTo'] = request.start_time_to
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CountAlertHistoriesByFields',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertHistories/countByFields',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CountAlertHistoriesByFieldsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CountAlertHistoriesByFieldsResponse(),
                self.execute(params, req, runtime)
            )

    async def count_alert_histories_by_fields_with_options_async(
        self,
        tmp_req: cms_20240330_models.CountAlertHistoriesByFieldsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CountAlertHistoriesByFieldsResponse:
        """
        @summary 根据告警历史的字段取值(group by)统计告警历史的数量
        
        @param tmp_req: CountAlertHistoriesByFieldsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CountAlertHistoriesByFieldsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.CountAlertHistoriesByFieldsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.field_list):
            request.field_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.field_list, 'fieldList', 'json')
        if not UtilClient.is_unset(tmp_req.label_filter):
            request.label_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.label_filter, 'labelFilter', 'json')
        if not UtilClient.is_unset(tmp_req.notification_filter):
            request.notification_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.notification_filter, 'notificationFilter', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_rule_id):
            query['alertRuleId'] = request.alert_rule_id
        if not UtilClient.is_unset(request.biz_source):
            query['bizSource'] = request.biz_source
        if not UtilClient.is_unset(request.display_name_key_word):
            query['displayNameKeyWord'] = request.display_name_key_word
        if not UtilClient.is_unset(request.field_list_shrink):
            query['fieldList'] = request.field_list_shrink
        if not UtilClient.is_unset(request.instance_key):
            query['instanceKey'] = request.instance_key
        if not UtilClient.is_unset(request.label_filter_shrink):
            query['labelFilter'] = request.label_filter_shrink
        if not UtilClient.is_unset(request.latest_level):
            query['latestLevel'] = request.latest_level
        if not UtilClient.is_unset(request.max_level):
            query['maxLevel'] = request.max_level
        if not UtilClient.is_unset(request.notification_filter_shrink):
            query['notificationFilter'] = request.notification_filter_shrink
        if not UtilClient.is_unset(request.start_time_from):
            query['startTimeFrom'] = request.start_time_from
        if not UtilClient.is_unset(request.start_time_to):
            query['startTimeTo'] = request.start_time_to
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CountAlertHistoriesByFields',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertHistories/countByFields',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CountAlertHistoriesByFieldsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CountAlertHistoriesByFieldsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def count_alert_histories_by_fields(
        self,
        request: cms_20240330_models.CountAlertHistoriesByFieldsRequest,
    ) -> cms_20240330_models.CountAlertHistoriesByFieldsResponse:
        """
        @summary 根据告警历史的字段取值(group by)统计告警历史的数量
        
        @param request: CountAlertHistoriesByFieldsRequest
        @return: CountAlertHistoriesByFieldsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.count_alert_histories_by_fields_with_options(request, headers, runtime)

    async def count_alert_histories_by_fields_async(
        self,
        request: cms_20240330_models.CountAlertHistoriesByFieldsRequest,
    ) -> cms_20240330_models.CountAlertHistoriesByFieldsResponse:
        """
        @summary 根据告警历史的字段取值(group by)统计告警历史的数量
        
        @param request: CountAlertHistoriesByFieldsRequest
        @return: CountAlertHistoriesByFieldsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.count_alert_histories_by_fields_with_options_async(request, headers, runtime)

    def count_alert_histories_by_time_with_options(
        self,
        tmp_req: cms_20240330_models.CountAlertHistoriesByTimeRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CountAlertHistoriesByTimeResponse:
        """
        @summary 按告警时间统计告警历史
        
        @param tmp_req: CountAlertHistoriesByTimeRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CountAlertHistoriesByTimeResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.CountAlertHistoriesByTimeShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.label_filter):
            request.label_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.label_filter, 'labelFilter', 'json')
        if not UtilClient.is_unset(tmp_req.notification_filter):
            request.notification_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.notification_filter, 'notificationFilter', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_rule_id):
            query['alertRuleId'] = request.alert_rule_id
        if not UtilClient.is_unset(request.biz_source):
            query['bizSource'] = request.biz_source
        if not UtilClient.is_unset(request.display_name_key_word):
            query['displayNameKeyWord'] = request.display_name_key_word
        if not UtilClient.is_unset(request.instance_key):
            query['instanceKey'] = request.instance_key
        if not UtilClient.is_unset(request.interval):
            query['interval'] = request.interval
        if not UtilClient.is_unset(request.label_filter_shrink):
            query['labelFilter'] = request.label_filter_shrink
        if not UtilClient.is_unset(request.latest_level):
            query['latestLevel'] = request.latest_level
        if not UtilClient.is_unset(request.max_level):
            query['maxLevel'] = request.max_level
        if not UtilClient.is_unset(request.notification_filter_shrink):
            query['notificationFilter'] = request.notification_filter_shrink
        if not UtilClient.is_unset(request.start_time_from):
            query['startTimeFrom'] = request.start_time_from
        if not UtilClient.is_unset(request.start_time_to):
            query['startTimeTo'] = request.start_time_to
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CountAlertHistoriesByTime',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertHistories/countByTime',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CountAlertHistoriesByTimeResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CountAlertHistoriesByTimeResponse(),
                self.execute(params, req, runtime)
            )

    async def count_alert_histories_by_time_with_options_async(
        self,
        tmp_req: cms_20240330_models.CountAlertHistoriesByTimeRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CountAlertHistoriesByTimeResponse:
        """
        @summary 按告警时间统计告警历史
        
        @param tmp_req: CountAlertHistoriesByTimeRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CountAlertHistoriesByTimeResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.CountAlertHistoriesByTimeShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.label_filter):
            request.label_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.label_filter, 'labelFilter', 'json')
        if not UtilClient.is_unset(tmp_req.notification_filter):
            request.notification_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.notification_filter, 'notificationFilter', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_rule_id):
            query['alertRuleId'] = request.alert_rule_id
        if not UtilClient.is_unset(request.biz_source):
            query['bizSource'] = request.biz_source
        if not UtilClient.is_unset(request.display_name_key_word):
            query['displayNameKeyWord'] = request.display_name_key_word
        if not UtilClient.is_unset(request.instance_key):
            query['instanceKey'] = request.instance_key
        if not UtilClient.is_unset(request.interval):
            query['interval'] = request.interval
        if not UtilClient.is_unset(request.label_filter_shrink):
            query['labelFilter'] = request.label_filter_shrink
        if not UtilClient.is_unset(request.latest_level):
            query['latestLevel'] = request.latest_level
        if not UtilClient.is_unset(request.max_level):
            query['maxLevel'] = request.max_level
        if not UtilClient.is_unset(request.notification_filter_shrink):
            query['notificationFilter'] = request.notification_filter_shrink
        if not UtilClient.is_unset(request.start_time_from):
            query['startTimeFrom'] = request.start_time_from
        if not UtilClient.is_unset(request.start_time_to):
            query['startTimeTo'] = request.start_time_to
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CountAlertHistoriesByTime',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertHistories/countByTime',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CountAlertHistoriesByTimeResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CountAlertHistoriesByTimeResponse(),
                await self.execute_async(params, req, runtime)
            )

    def count_alert_histories_by_time(
        self,
        request: cms_20240330_models.CountAlertHistoriesByTimeRequest,
    ) -> cms_20240330_models.CountAlertHistoriesByTimeResponse:
        """
        @summary 按告警时间统计告警历史
        
        @param request: CountAlertHistoriesByTimeRequest
        @return: CountAlertHistoriesByTimeResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.count_alert_histories_by_time_with_options(request, headers, runtime)

    async def count_alert_histories_by_time_async(
        self,
        request: cms_20240330_models.CountAlertHistoriesByTimeRequest,
    ) -> cms_20240330_models.CountAlertHistoriesByTimeResponse:
        """
        @summary 按告警时间统计告警历史
        
        @param request: CountAlertHistoriesByTimeRequest
        @return: CountAlertHistoriesByTimeResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.count_alert_histories_by_time_with_options_async(request, headers, runtime)

    def count_alert_rules_by_fields_with_options(
        self,
        tmp_req: cms_20240330_models.CountAlertRulesByFieldsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CountAlertRulesByFieldsResponse:
        """
        @summary 根据字段统计告警规则数量
        
        @param tmp_req: CountAlertRulesByFieldsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CountAlertRulesByFieldsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.CountAlertRulesByFieldsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.field_list):
            request.field_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.field_list, 'fieldList', 'json')
        if not UtilClient.is_unset(tmp_req.label_filter):
            request.label_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.label_filter, 'labelFilter', 'json')
        if not UtilClient.is_unset(tmp_req.notification_filter):
            request.notification_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.notification_filter, 'notificationFilter', 'json')
        query = {}
        if not UtilClient.is_unset(request.biz_source):
            query['bizSource'] = request.biz_source
        if not UtilClient.is_unset(request.display_name_key_word):
            query['displayNameKeyWord'] = request.display_name_key_word
        if not UtilClient.is_unset(request.enabled):
            query['enabled'] = request.enabled
        if not UtilClient.is_unset(request.field_list_shrink):
            query['fieldList'] = request.field_list_shrink
        if not UtilClient.is_unset(request.label_filter_shrink):
            query['labelFilter'] = request.label_filter_shrink
        if not UtilClient.is_unset(request.notification_filter_shrink):
            query['notificationFilter'] = request.notification_filter_shrink
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CountAlertRulesByFields',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules/countByFields',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CountAlertRulesByFieldsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CountAlertRulesByFieldsResponse(),
                self.execute(params, req, runtime)
            )

    async def count_alert_rules_by_fields_with_options_async(
        self,
        tmp_req: cms_20240330_models.CountAlertRulesByFieldsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CountAlertRulesByFieldsResponse:
        """
        @summary 根据字段统计告警规则数量
        
        @param tmp_req: CountAlertRulesByFieldsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CountAlertRulesByFieldsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.CountAlertRulesByFieldsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.field_list):
            request.field_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.field_list, 'fieldList', 'json')
        if not UtilClient.is_unset(tmp_req.label_filter):
            request.label_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.label_filter, 'labelFilter', 'json')
        if not UtilClient.is_unset(tmp_req.notification_filter):
            request.notification_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.notification_filter, 'notificationFilter', 'json')
        query = {}
        if not UtilClient.is_unset(request.biz_source):
            query['bizSource'] = request.biz_source
        if not UtilClient.is_unset(request.display_name_key_word):
            query['displayNameKeyWord'] = request.display_name_key_word
        if not UtilClient.is_unset(request.enabled):
            query['enabled'] = request.enabled
        if not UtilClient.is_unset(request.field_list_shrink):
            query['fieldList'] = request.field_list_shrink
        if not UtilClient.is_unset(request.label_filter_shrink):
            query['labelFilter'] = request.label_filter_shrink
        if not UtilClient.is_unset(request.notification_filter_shrink):
            query['notificationFilter'] = request.notification_filter_shrink
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CountAlertRulesByFields',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules/countByFields',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CountAlertRulesByFieldsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CountAlertRulesByFieldsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def count_alert_rules_by_fields(
        self,
        request: cms_20240330_models.CountAlertRulesByFieldsRequest,
    ) -> cms_20240330_models.CountAlertRulesByFieldsResponse:
        """
        @summary 根据字段统计告警规则数量
        
        @param request: CountAlertRulesByFieldsRequest
        @return: CountAlertRulesByFieldsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.count_alert_rules_by_fields_with_options(request, headers, runtime)

    async def count_alert_rules_by_fields_async(
        self,
        request: cms_20240330_models.CountAlertRulesByFieldsRequest,
    ) -> cms_20240330_models.CountAlertRulesByFieldsResponse:
        """
        @summary 根据字段统计告警规则数量
        
        @param request: CountAlertRulesByFieldsRequest
        @return: CountAlertRulesByFieldsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.count_alert_rules_by_fields_with_options_async(request, headers, runtime)

    def create_addon_release_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.CreateAddonReleaseRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAddonReleaseResponse:
        """
        @summary 安装接入组件，代表进行一次接入
        
        @param request: CreateAddonReleaseRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAddonReleaseResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.addon_name):
            body['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.aliyun_lang):
            body['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.dry_run):
            body['dryRun'] = request.dry_run
        if not UtilClient.is_unset(request.env_type):
            body['envType'] = request.env_type
        if not UtilClient.is_unset(request.parent_addon_release_id):
            body['parentAddonReleaseId'] = request.parent_addon_release_id
        if not UtilClient.is_unset(request.release_name):
            body['releaseName'] = request.release_name
        if not UtilClient.is_unset(request.values):
            body['values'] = request.values
        if not UtilClient.is_unset(request.version):
            body['version'] = request.version
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateAddonRelease',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/addon-releases',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAddonReleaseResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAddonReleaseResponse(),
                self.execute(params, req, runtime)
            )

    async def create_addon_release_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.CreateAddonReleaseRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAddonReleaseResponse:
        """
        @summary 安装接入组件，代表进行一次接入
        
        @param request: CreateAddonReleaseRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAddonReleaseResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.addon_name):
            body['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.aliyun_lang):
            body['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.dry_run):
            body['dryRun'] = request.dry_run
        if not UtilClient.is_unset(request.env_type):
            body['envType'] = request.env_type
        if not UtilClient.is_unset(request.parent_addon_release_id):
            body['parentAddonReleaseId'] = request.parent_addon_release_id
        if not UtilClient.is_unset(request.release_name):
            body['releaseName'] = request.release_name
        if not UtilClient.is_unset(request.values):
            body['values'] = request.values
        if not UtilClient.is_unset(request.version):
            body['version'] = request.version
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateAddonRelease',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/addon-releases',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAddonReleaseResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAddonReleaseResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_addon_release(
        self,
        policy_id: str,
        request: cms_20240330_models.CreateAddonReleaseRequest,
    ) -> cms_20240330_models.CreateAddonReleaseResponse:
        """
        @summary 安装接入组件，代表进行一次接入
        
        @param request: CreateAddonReleaseRequest
        @return: CreateAddonReleaseResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_addon_release_with_options(policy_id, request, headers, runtime)

    async def create_addon_release_async(
        self,
        policy_id: str,
        request: cms_20240330_models.CreateAddonReleaseRequest,
    ) -> cms_20240330_models.CreateAddonReleaseResponse:
        """
        @summary 安装接入组件，代表进行一次接入
        
        @param request: CreateAddonReleaseRequest
        @return: CreateAddonReleaseResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_addon_release_with_options_async(policy_id, request, headers, runtime)

    def create_agg_task_group_with_options(
        self,
        instance_id: str,
        request: cms_20240330_models.CreateAggTaskGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAggTaskGroupResponse:
        """
        @summary 创建聚合任务组
        
        @param request: CreateAggTaskGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAggTaskGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.override_if_exists):
            query['overrideIfExists'] = request.override_if_exists
        body = {}
        if not UtilClient.is_unset(request.agg_task_group_config):
            body['aggTaskGroupConfig'] = request.agg_task_group_config
        if not UtilClient.is_unset(request.agg_task_group_config_type):
            body['aggTaskGroupConfigType'] = request.agg_task_group_config_type
        if not UtilClient.is_unset(request.agg_task_group_name):
            body['aggTaskGroupName'] = request.agg_task_group_name
        if not UtilClient.is_unset(request.cron_expr):
            body['cronExpr'] = request.cron_expr
        if not UtilClient.is_unset(request.delay):
            body['delay'] = request.delay
        if not UtilClient.is_unset(request.description):
            body['description'] = request.description
        if not UtilClient.is_unset(request.from_time):
            body['fromTime'] = request.from_time
        if not UtilClient.is_unset(request.max_retries):
            body['maxRetries'] = request.max_retries
        if not UtilClient.is_unset(request.max_run_time_in_seconds):
            body['maxRunTimeInSeconds'] = request.max_run_time_in_seconds
        if not UtilClient.is_unset(request.precheck_string):
            body['precheckString'] = request.precheck_string
        if not UtilClient.is_unset(request.schedule_mode):
            body['scheduleMode'] = request.schedule_mode
        if not UtilClient.is_unset(request.schedule_time_expr):
            body['scheduleTimeExpr'] = request.schedule_time_expr
        if not UtilClient.is_unset(request.status):
            body['status'] = request.status
        if not UtilClient.is_unset(request.tags):
            body['tags'] = request.tags
        if not UtilClient.is_unset(request.target_prometheus_id):
            body['targetPrometheusId'] = request.target_prometheus_id
        if not UtilClient.is_unset(request.to_time):
            body['toTime'] = request.to_time
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateAggTaskGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(instance_id)}/agg-task-groups',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAggTaskGroupResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAggTaskGroupResponse(),
                self.execute(params, req, runtime)
            )

    async def create_agg_task_group_with_options_async(
        self,
        instance_id: str,
        request: cms_20240330_models.CreateAggTaskGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAggTaskGroupResponse:
        """
        @summary 创建聚合任务组
        
        @param request: CreateAggTaskGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAggTaskGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.override_if_exists):
            query['overrideIfExists'] = request.override_if_exists
        body = {}
        if not UtilClient.is_unset(request.agg_task_group_config):
            body['aggTaskGroupConfig'] = request.agg_task_group_config
        if not UtilClient.is_unset(request.agg_task_group_config_type):
            body['aggTaskGroupConfigType'] = request.agg_task_group_config_type
        if not UtilClient.is_unset(request.agg_task_group_name):
            body['aggTaskGroupName'] = request.agg_task_group_name
        if not UtilClient.is_unset(request.cron_expr):
            body['cronExpr'] = request.cron_expr
        if not UtilClient.is_unset(request.delay):
            body['delay'] = request.delay
        if not UtilClient.is_unset(request.description):
            body['description'] = request.description
        if not UtilClient.is_unset(request.from_time):
            body['fromTime'] = request.from_time
        if not UtilClient.is_unset(request.max_retries):
            body['maxRetries'] = request.max_retries
        if not UtilClient.is_unset(request.max_run_time_in_seconds):
            body['maxRunTimeInSeconds'] = request.max_run_time_in_seconds
        if not UtilClient.is_unset(request.precheck_string):
            body['precheckString'] = request.precheck_string
        if not UtilClient.is_unset(request.schedule_mode):
            body['scheduleMode'] = request.schedule_mode
        if not UtilClient.is_unset(request.schedule_time_expr):
            body['scheduleTimeExpr'] = request.schedule_time_expr
        if not UtilClient.is_unset(request.status):
            body['status'] = request.status
        if not UtilClient.is_unset(request.tags):
            body['tags'] = request.tags
        if not UtilClient.is_unset(request.target_prometheus_id):
            body['targetPrometheusId'] = request.target_prometheus_id
        if not UtilClient.is_unset(request.to_time):
            body['toTime'] = request.to_time
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateAggTaskGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(instance_id)}/agg-task-groups',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAggTaskGroupResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAggTaskGroupResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_agg_task_group(
        self,
        instance_id: str,
        request: cms_20240330_models.CreateAggTaskGroupRequest,
    ) -> cms_20240330_models.CreateAggTaskGroupResponse:
        """
        @summary 创建聚合任务组
        
        @param request: CreateAggTaskGroupRequest
        @return: CreateAggTaskGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_agg_task_group_with_options(instance_id, request, headers, runtime)

    async def create_agg_task_group_async(
        self,
        instance_id: str,
        request: cms_20240330_models.CreateAggTaskGroupRequest,
    ) -> cms_20240330_models.CreateAggTaskGroupResponse:
        """
        @summary 创建聚合任务组
        
        @param request: CreateAggTaskGroupRequest
        @return: CreateAggTaskGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_agg_task_group_with_options_async(instance_id, request, headers, runtime)

    def create_alert_action_with_options(
        self,
        request: cms_20240330_models.CreateAlertActionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAlertActionResponse:
        """
        @summary 创建告警动作
        
        @param request: CreateAlertActionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAlertActionResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_action_id):
            body['alertActionId'] = request.alert_action_id
        if not UtilClient.is_unset(request.alert_action_name):
            body['alertActionName'] = request.alert_action_name
        if not UtilClient.is_unset(request.ess_param):
            body['essParam'] = request.ess_param
        if not UtilClient.is_unset(request.fc_param):
            body['fcParam'] = request.fc_param
        if not UtilClient.is_unset(request.mns_param):
            body['mnsParam'] = request.mns_param
        if not UtilClient.is_unset(request.pager_duty_param):
            body['pagerDutyParam'] = request.pager_duty_param
        if not UtilClient.is_unset(request.sls_param):
            body['slsParam'] = request.sls_param
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        if not UtilClient.is_unset(request.type):
            body['type'] = request.type
        if not UtilClient.is_unset(request.webhook_param):
            body['webhookParam'] = request.webhook_param
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateAlertAction',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertAction',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertActionResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertActionResponse(),
                self.execute(params, req, runtime)
            )

    async def create_alert_action_with_options_async(
        self,
        request: cms_20240330_models.CreateAlertActionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAlertActionResponse:
        """
        @summary 创建告警动作
        
        @param request: CreateAlertActionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAlertActionResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_action_id):
            body['alertActionId'] = request.alert_action_id
        if not UtilClient.is_unset(request.alert_action_name):
            body['alertActionName'] = request.alert_action_name
        if not UtilClient.is_unset(request.ess_param):
            body['essParam'] = request.ess_param
        if not UtilClient.is_unset(request.fc_param):
            body['fcParam'] = request.fc_param
        if not UtilClient.is_unset(request.mns_param):
            body['mnsParam'] = request.mns_param
        if not UtilClient.is_unset(request.pager_duty_param):
            body['pagerDutyParam'] = request.pager_duty_param
        if not UtilClient.is_unset(request.sls_param):
            body['slsParam'] = request.sls_param
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        if not UtilClient.is_unset(request.type):
            body['type'] = request.type
        if not UtilClient.is_unset(request.webhook_param):
            body['webhookParam'] = request.webhook_param
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateAlertAction',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertAction',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertActionResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertActionResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_alert_action(
        self,
        request: cms_20240330_models.CreateAlertActionRequest,
    ) -> cms_20240330_models.CreateAlertActionResponse:
        """
        @summary 创建告警动作
        
        @param request: CreateAlertActionRequest
        @return: CreateAlertActionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_alert_action_with_options(request, headers, runtime)

    async def create_alert_action_async(
        self,
        request: cms_20240330_models.CreateAlertActionRequest,
    ) -> cms_20240330_models.CreateAlertActionResponse:
        """
        @summary 创建告警动作
        
        @param request: CreateAlertActionRequest
        @return: CreateAlertActionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_alert_action_with_options_async(request, headers, runtime)

    def create_alert_event_integration_policy_with_options(
        self,
        request: cms_20240330_models.CreateAlertEventIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAlertEventIntegrationPolicyResponse:
        """
        @summary 创建集成
        
        @param request: CreateAlertEventIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAlertEventIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='CreateAlertEventIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertEventIntegrationPolicies',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertEventIntegrationPolicyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertEventIntegrationPolicyResponse(),
                self.execute(params, req, runtime)
            )

    async def create_alert_event_integration_policy_with_options_async(
        self,
        request: cms_20240330_models.CreateAlertEventIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAlertEventIntegrationPolicyResponse:
        """
        @summary 创建集成
        
        @param request: CreateAlertEventIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAlertEventIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='CreateAlertEventIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertEventIntegrationPolicies',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertEventIntegrationPolicyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertEventIntegrationPolicyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_alert_event_integration_policy(
        self,
        request: cms_20240330_models.CreateAlertEventIntegrationPolicyRequest,
    ) -> cms_20240330_models.CreateAlertEventIntegrationPolicyResponse:
        """
        @summary 创建集成
        
        @param request: CreateAlertEventIntegrationPolicyRequest
        @return: CreateAlertEventIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_alert_event_integration_policy_with_options(request, headers, runtime)

    async def create_alert_event_integration_policy_async(
        self,
        request: cms_20240330_models.CreateAlertEventIntegrationPolicyRequest,
    ) -> cms_20240330_models.CreateAlertEventIntegrationPolicyResponse:
        """
        @summary 创建集成
        
        @param request: CreateAlertEventIntegrationPolicyRequest
        @return: CreateAlertEventIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_alert_event_integration_policy_with_options_async(request, headers, runtime)

    def create_alert_notify_template_with_options(
        self,
        request: cms_20240330_models.CreateAlertNotifyTemplateRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAlertNotifyTemplateResponse:
        """
        @summary 创建通知模板
        
        @param request: CreateAlertNotifyTemplateRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAlertNotifyTemplateResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_notify_template_id):
            body['alertNotifyTemplateId'] = request.alert_notify_template_id
        if not UtilClient.is_unset(request.alert_notify_template_name):
            body['alertNotifyTemplateName'] = request.alert_notify_template_name
        if not UtilClient.is_unset(request.program_lang):
            body['programLang'] = request.program_lang
        if not UtilClient.is_unset(request.templates):
            body['templates'] = request.templates
        if not UtilClient.is_unset(request.type):
            body['type'] = request.type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateAlertNotifyTemplate',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertNotifyTemplate',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertNotifyTemplateResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertNotifyTemplateResponse(),
                self.execute(params, req, runtime)
            )

    async def create_alert_notify_template_with_options_async(
        self,
        request: cms_20240330_models.CreateAlertNotifyTemplateRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAlertNotifyTemplateResponse:
        """
        @summary 创建通知模板
        
        @param request: CreateAlertNotifyTemplateRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAlertNotifyTemplateResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_notify_template_id):
            body['alertNotifyTemplateId'] = request.alert_notify_template_id
        if not UtilClient.is_unset(request.alert_notify_template_name):
            body['alertNotifyTemplateName'] = request.alert_notify_template_name
        if not UtilClient.is_unset(request.program_lang):
            body['programLang'] = request.program_lang
        if not UtilClient.is_unset(request.templates):
            body['templates'] = request.templates
        if not UtilClient.is_unset(request.type):
            body['type'] = request.type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateAlertNotifyTemplate',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertNotifyTemplate',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertNotifyTemplateResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertNotifyTemplateResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_alert_notify_template(
        self,
        request: cms_20240330_models.CreateAlertNotifyTemplateRequest,
    ) -> cms_20240330_models.CreateAlertNotifyTemplateResponse:
        """
        @summary 创建通知模板
        
        @param request: CreateAlertNotifyTemplateRequest
        @return: CreateAlertNotifyTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_alert_notify_template_with_options(request, headers, runtime)

    async def create_alert_notify_template_async(
        self,
        request: cms_20240330_models.CreateAlertNotifyTemplateRequest,
    ) -> cms_20240330_models.CreateAlertNotifyTemplateResponse:
        """
        @summary 创建通知模板
        
        @param request: CreateAlertNotifyTemplateRequest
        @return: CreateAlertNotifyTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_alert_notify_template_with_options_async(request, headers, runtime)

    def create_alert_push_action_with_options(
        self,
        request: cms_20240330_models.CreateAlertPushActionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAlertPushActionResponse:
        """
        @summary 创建报警推送
        
        @param request: CreateAlertPushActionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAlertPushActionResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_push_actioni_d):
            body['alertPushActioniD'] = request.alert_push_actioni_d
        if not UtilClient.is_unset(request.fc_param):
            body['fcParam'] = request.fc_param
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.sls_param):
            body['slsParam'] = request.sls_param
        if not UtilClient.is_unset(request.type):
            body['type'] = request.type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateAlertPushAction',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertPushAction',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertPushActionResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertPushActionResponse(),
                self.execute(params, req, runtime)
            )

    async def create_alert_push_action_with_options_async(
        self,
        request: cms_20240330_models.CreateAlertPushActionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAlertPushActionResponse:
        """
        @summary 创建报警推送
        
        @param request: CreateAlertPushActionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAlertPushActionResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_push_actioni_d):
            body['alertPushActioniD'] = request.alert_push_actioni_d
        if not UtilClient.is_unset(request.fc_param):
            body['fcParam'] = request.fc_param
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.sls_param):
            body['slsParam'] = request.sls_param
        if not UtilClient.is_unset(request.type):
            body['type'] = request.type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateAlertPushAction',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertPushAction',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertPushActionResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertPushActionResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_alert_push_action(
        self,
        request: cms_20240330_models.CreateAlertPushActionRequest,
    ) -> cms_20240330_models.CreateAlertPushActionResponse:
        """
        @summary 创建报警推送
        
        @param request: CreateAlertPushActionRequest
        @return: CreateAlertPushActionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_alert_push_action_with_options(request, headers, runtime)

    async def create_alert_push_action_async(
        self,
        request: cms_20240330_models.CreateAlertPushActionRequest,
    ) -> cms_20240330_models.CreateAlertPushActionResponse:
        """
        @summary 创建报警推送
        
        @param request: CreateAlertPushActionRequest
        @return: CreateAlertPushActionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_alert_push_action_with_options_async(request, headers, runtime)

    def create_alert_robot_with_options(
        self,
        request: cms_20240330_models.CreateAlertRobotRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAlertRobotResponse:
        """
        @summary 创建机器人
        
        @param request: CreateAlertRobotRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAlertRobotResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.is_custom):
            body['isCustom'] = request.is_custom
        if not UtilClient.is_unset(request.lang):
            body['lang'] = request.lang
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.robot_id):
            body['robotId'] = request.robot_id
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        if not UtilClient.is_unset(request.type):
            body['type'] = request.type
        if not UtilClient.is_unset(request.url):
            body['url'] = request.url
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateAlertRobot',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/robot',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertRobotResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertRobotResponse(),
                self.execute(params, req, runtime)
            )

    async def create_alert_robot_with_options_async(
        self,
        request: cms_20240330_models.CreateAlertRobotRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAlertRobotResponse:
        """
        @summary 创建机器人
        
        @param request: CreateAlertRobotRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAlertRobotResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.is_custom):
            body['isCustom'] = request.is_custom
        if not UtilClient.is_unset(request.lang):
            body['lang'] = request.lang
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.robot_id):
            body['robotId'] = request.robot_id
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        if not UtilClient.is_unset(request.type):
            body['type'] = request.type
        if not UtilClient.is_unset(request.url):
            body['url'] = request.url
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateAlertRobot',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/robot',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertRobotResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertRobotResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_alert_robot(
        self,
        request: cms_20240330_models.CreateAlertRobotRequest,
    ) -> cms_20240330_models.CreateAlertRobotResponse:
        """
        @summary 创建机器人
        
        @param request: CreateAlertRobotRequest
        @return: CreateAlertRobotResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_alert_robot_with_options(request, headers, runtime)

    async def create_alert_robot_async(
        self,
        request: cms_20240330_models.CreateAlertRobotRequest,
    ) -> cms_20240330_models.CreateAlertRobotResponse:
        """
        @summary 创建机器人
        
        @param request: CreateAlertRobotRequest
        @return: CreateAlertRobotResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_alert_robot_with_options_async(request, headers, runtime)

    def create_alert_rule_with_options(
        self,
        request: cms_20240330_models.CreateAlertRuleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAlertRuleResponse:
        """
        @summary 创建云监控2.0告警规则
        
        @param request: CreateAlertRuleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAlertRuleResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_metric_input):
            body['alertMetricInput'] = request.alert_metric_input
        if not UtilClient.is_unset(request.annotations):
            body['annotations'] = request.annotations
        if not UtilClient.is_unset(request.biz_source):
            body['bizSource'] = request.biz_source
        if not UtilClient.is_unset(request.condition):
            body['condition'] = request.condition
        if not UtilClient.is_unset(request.datasource):
            body['datasource'] = request.datasource
        if not UtilClient.is_unset(request.display_name):
            body['displayName'] = request.display_name
        if not UtilClient.is_unset(request.effect_time):
            body['effectTime'] = request.effect_time
        if not UtilClient.is_unset(request.enabled):
            body['enabled'] = request.enabled
        if not UtilClient.is_unset(request.interval):
            body['interval'] = request.interval
        if not UtilClient.is_unset(request.labels):
            body['labels'] = request.labels
        if not UtilClient.is_unset(request.level):
            body['level'] = request.level
        if not UtilClient.is_unset(request.message):
            body['message'] = request.message
        if not UtilClient.is_unset(request.query):
            body['query'] = request.query
        if not UtilClient.is_unset(request.send):
            body['send'] = request.send
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateAlertRule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertRuleResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertRuleResponse(),
                self.execute(params, req, runtime)
            )

    async def create_alert_rule_with_options_async(
        self,
        request: cms_20240330_models.CreateAlertRuleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAlertRuleResponse:
        """
        @summary 创建云监控2.0告警规则
        
        @param request: CreateAlertRuleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAlertRuleResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_metric_input):
            body['alertMetricInput'] = request.alert_metric_input
        if not UtilClient.is_unset(request.annotations):
            body['annotations'] = request.annotations
        if not UtilClient.is_unset(request.biz_source):
            body['bizSource'] = request.biz_source
        if not UtilClient.is_unset(request.condition):
            body['condition'] = request.condition
        if not UtilClient.is_unset(request.datasource):
            body['datasource'] = request.datasource
        if not UtilClient.is_unset(request.display_name):
            body['displayName'] = request.display_name
        if not UtilClient.is_unset(request.effect_time):
            body['effectTime'] = request.effect_time
        if not UtilClient.is_unset(request.enabled):
            body['enabled'] = request.enabled
        if not UtilClient.is_unset(request.interval):
            body['interval'] = request.interval
        if not UtilClient.is_unset(request.labels):
            body['labels'] = request.labels
        if not UtilClient.is_unset(request.level):
            body['level'] = request.level
        if not UtilClient.is_unset(request.message):
            body['message'] = request.message
        if not UtilClient.is_unset(request.query):
            body['query'] = request.query
        if not UtilClient.is_unset(request.send):
            body['send'] = request.send
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateAlertRule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertRuleResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertRuleResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_alert_rule(
        self,
        request: cms_20240330_models.CreateAlertRuleRequest,
    ) -> cms_20240330_models.CreateAlertRuleResponse:
        """
        @summary 创建云监控2.0告警规则
        
        @param request: CreateAlertRuleRequest
        @return: CreateAlertRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_alert_rule_with_options(request, headers, runtime)

    async def create_alert_rule_async(
        self,
        request: cms_20240330_models.CreateAlertRuleRequest,
    ) -> cms_20240330_models.CreateAlertRuleResponse:
        """
        @summary 创建云监控2.0告警规则
        
        @param request: CreateAlertRuleRequest
        @return: CreateAlertRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_alert_rule_with_options_async(request, headers, runtime)

    def create_alert_webhook_with_options(
        self,
        request: cms_20240330_models.CreateAlertWebhookRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAlertWebhookResponse:
        """
        @summary 创建Webhook
        
        @param request: CreateAlertWebhookRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAlertWebhookResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.content_type):
            body['contentType'] = request.content_type
        if not UtilClient.is_unset(request.headers):
            body['headers'] = request.headers
        if not UtilClient.is_unset(request.is_custom):
            body['isCustom'] = request.is_custom
        if not UtilClient.is_unset(request.lang):
            body['lang'] = request.lang
        if not UtilClient.is_unset(request.method):
            body['method'] = request.method
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        if not UtilClient.is_unset(request.url):
            body['url'] = request.url
        if not UtilClient.is_unset(request.webhook_id):
            body['webhookId'] = request.webhook_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateAlertWebhook',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/webhook',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertWebhookResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertWebhookResponse(),
                self.execute(params, req, runtime)
            )

    async def create_alert_webhook_with_options_async(
        self,
        request: cms_20240330_models.CreateAlertWebhookRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateAlertWebhookResponse:
        """
        @summary 创建Webhook
        
        @param request: CreateAlertWebhookRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateAlertWebhookResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.content_type):
            body['contentType'] = request.content_type
        if not UtilClient.is_unset(request.headers):
            body['headers'] = request.headers
        if not UtilClient.is_unset(request.is_custom):
            body['isCustom'] = request.is_custom
        if not UtilClient.is_unset(request.lang):
            body['lang'] = request.lang
        if not UtilClient.is_unset(request.method):
            body['method'] = request.method
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        if not UtilClient.is_unset(request.url):
            body['url'] = request.url
        if not UtilClient.is_unset(request.webhook_id):
            body['webhookId'] = request.webhook_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateAlertWebhook',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/webhook',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertWebhookResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateAlertWebhookResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_alert_webhook(
        self,
        request: cms_20240330_models.CreateAlertWebhookRequest,
    ) -> cms_20240330_models.CreateAlertWebhookResponse:
        """
        @summary 创建Webhook
        
        @param request: CreateAlertWebhookRequest
        @return: CreateAlertWebhookResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_alert_webhook_with_options(request, headers, runtime)

    async def create_alert_webhook_async(
        self,
        request: cms_20240330_models.CreateAlertWebhookRequest,
    ) -> cms_20240330_models.CreateAlertWebhookResponse:
        """
        @summary 创建Webhook
        
        @param request: CreateAlertWebhookRequest
        @return: CreateAlertWebhookResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_alert_webhook_with_options_async(request, headers, runtime)

    def create_application_insights_instance_with_options(
        self,
        request: cms_20240330_models.CreateApplicationInsightsInstanceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateApplicationInsightsInstanceResponse:
        """
        @summary 创建应用可观测实例
        
        @param request: CreateApplicationInsightsInstanceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateApplicationInsightsInstanceResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_codes):
            body['appCodes'] = request.app_codes
        if not UtilClient.is_unset(request.workspace_name):
            body['workspaceName'] = request.workspace_name
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateApplicationInsightsInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/application-insights/instance',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateApplicationInsightsInstanceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateApplicationInsightsInstanceResponse(),
                self.execute(params, req, runtime)
            )

    async def create_application_insights_instance_with_options_async(
        self,
        request: cms_20240330_models.CreateApplicationInsightsInstanceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateApplicationInsightsInstanceResponse:
        """
        @summary 创建应用可观测实例
        
        @param request: CreateApplicationInsightsInstanceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateApplicationInsightsInstanceResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.app_codes):
            body['appCodes'] = request.app_codes
        if not UtilClient.is_unset(request.workspace_name):
            body['workspaceName'] = request.workspace_name
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateApplicationInsightsInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/application-insights/instance',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateApplicationInsightsInstanceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateApplicationInsightsInstanceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_application_insights_instance(
        self,
        request: cms_20240330_models.CreateApplicationInsightsInstanceRequest,
    ) -> cms_20240330_models.CreateApplicationInsightsInstanceResponse:
        """
        @summary 创建应用可观测实例
        
        @param request: CreateApplicationInsightsInstanceRequest
        @return: CreateApplicationInsightsInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_application_insights_instance_with_options(request, headers, runtime)

    async def create_application_insights_instance_async(
        self,
        request: cms_20240330_models.CreateApplicationInsightsInstanceRequest,
    ) -> cms_20240330_models.CreateApplicationInsightsInstanceResponse:
        """
        @summary 创建应用可观测实例
        
        @param request: CreateApplicationInsightsInstanceRequest
        @return: CreateApplicationInsightsInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_application_insights_instance_with_options_async(request, headers, runtime)

    def create_biz_trace_with_options(
        self,
        request: cms_20240330_models.CreateBizTraceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateBizTraceResponse:
        """
        @summary 创建业务链路
        
        @param request: CreateBizTraceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateBizTraceResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.advanced_config):
            body['advancedConfig'] = request.advanced_config
        if not UtilClient.is_unset(request.biz_trace_code):
            body['bizTraceCode'] = request.biz_trace_code
        if not UtilClient.is_unset(request.biz_trace_name):
            body['bizTraceName'] = request.biz_trace_name
        if not UtilClient.is_unset(request.rule_config):
            body['ruleConfig'] = request.rule_config
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateBizTrace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/bizTrace',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateBizTraceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateBizTraceResponse(),
                self.execute(params, req, runtime)
            )

    async def create_biz_trace_with_options_async(
        self,
        request: cms_20240330_models.CreateBizTraceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateBizTraceResponse:
        """
        @summary 创建业务链路
        
        @param request: CreateBizTraceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateBizTraceResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.advanced_config):
            body['advancedConfig'] = request.advanced_config
        if not UtilClient.is_unset(request.biz_trace_code):
            body['bizTraceCode'] = request.biz_trace_code
        if not UtilClient.is_unset(request.biz_trace_name):
            body['bizTraceName'] = request.biz_trace_name
        if not UtilClient.is_unset(request.rule_config):
            body['ruleConfig'] = request.rule_config
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateBizTrace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/bizTrace',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateBizTraceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateBizTraceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_biz_trace(
        self,
        request: cms_20240330_models.CreateBizTraceRequest,
    ) -> cms_20240330_models.CreateBizTraceResponse:
        """
        @summary 创建业务链路
        
        @param request: CreateBizTraceRequest
        @return: CreateBizTraceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_biz_trace_with_options(request, headers, runtime)

    async def create_biz_trace_async(
        self,
        request: cms_20240330_models.CreateBizTraceRequest,
    ) -> cms_20240330_models.CreateBizTraceResponse:
        """
        @summary 创建业务链路
        
        @param request: CreateBizTraceRequest
        @return: CreateBizTraceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_biz_trace_with_options_async(request, headers, runtime)

    def create_cloud_resource_with_options(
        self,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateCloudResourceResponse:
        """
        @summary 创建云资源中心
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateCloudResourceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='CreateCloudResource',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/cloudresource',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateCloudResourceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateCloudResourceResponse(),
                self.execute(params, req, runtime)
            )

    async def create_cloud_resource_with_options_async(
        self,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateCloudResourceResponse:
        """
        @summary 创建云资源中心
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateCloudResourceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='CreateCloudResource',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/cloudresource',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateCloudResourceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateCloudResourceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_cloud_resource(self) -> cms_20240330_models.CreateCloudResourceResponse:
        """
        @summary 创建云资源中心
        
        @return: CreateCloudResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_cloud_resource_with_options(headers, runtime)

    async def create_cloud_resource_async(self) -> cms_20240330_models.CreateCloudResourceResponse:
        """
        @summary 创建云资源中心
        
        @return: CreateCloudResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_cloud_resource_with_options_async(headers, runtime)

    def create_contact_with_options(
        self,
        request: cms_20240330_models.CreateContactRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateContactResponse:
        """
        @summary 创建联系人
        
        @param request: CreateContactRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateContactResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.contact_id):
            body['contactId'] = request.contact_id
        if not UtilClient.is_unset(request.email):
            body['email'] = request.email
        if not UtilClient.is_unset(request.im_user_ids):
            body['imUserIds'] = request.im_user_ids
        if not UtilClient.is_unset(request.is_inner_call):
            body['isInnerCall'] = request.is_inner_call
        if not UtilClient.is_unset(request.lang):
            body['lang'] = request.lang
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.phone):
            body['phone'] = request.phone
        if not UtilClient.is_unset(request.phone_code):
            body['phoneCode'] = request.phone_code
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateContact',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contact',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateContactResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateContactResponse(),
                self.execute(params, req, runtime)
            )

    async def create_contact_with_options_async(
        self,
        request: cms_20240330_models.CreateContactRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateContactResponse:
        """
        @summary 创建联系人
        
        @param request: CreateContactRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateContactResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.contact_id):
            body['contactId'] = request.contact_id
        if not UtilClient.is_unset(request.email):
            body['email'] = request.email
        if not UtilClient.is_unset(request.im_user_ids):
            body['imUserIds'] = request.im_user_ids
        if not UtilClient.is_unset(request.is_inner_call):
            body['isInnerCall'] = request.is_inner_call
        if not UtilClient.is_unset(request.lang):
            body['lang'] = request.lang
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.phone):
            body['phone'] = request.phone
        if not UtilClient.is_unset(request.phone_code):
            body['phoneCode'] = request.phone_code
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateContact',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contact',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateContactResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateContactResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_contact(
        self,
        request: cms_20240330_models.CreateContactRequest,
    ) -> cms_20240330_models.CreateContactResponse:
        """
        @summary 创建联系人
        
        @param request: CreateContactRequest
        @return: CreateContactResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_contact_with_options(request, headers, runtime)

    async def create_contact_async(
        self,
        request: cms_20240330_models.CreateContactRequest,
    ) -> cms_20240330_models.CreateContactResponse:
        """
        @summary 创建联系人
        
        @param request: CreateContactRequest
        @return: CreateContactResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_contact_with_options_async(request, headers, runtime)

    def create_contact_group_with_options(
        self,
        request: cms_20240330_models.CreateContactGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateContactGroupResponse:
        """
        @summary 创建联系人组
        
        @param request: CreateContactGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateContactGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.contact_group_id):
            body['contactGroupId'] = request.contact_group_id
        if not UtilClient.is_unset(request.contacts):
            body['contacts'] = request.contacts
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateContactGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contactGroup',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateContactGroupResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateContactGroupResponse(),
                self.execute(params, req, runtime)
            )

    async def create_contact_group_with_options_async(
        self,
        request: cms_20240330_models.CreateContactGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateContactGroupResponse:
        """
        @summary 创建联系人组
        
        @param request: CreateContactGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateContactGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.contact_group_id):
            body['contactGroupId'] = request.contact_group_id
        if not UtilClient.is_unset(request.contacts):
            body['contacts'] = request.contacts
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateContactGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contactGroup',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateContactGroupResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateContactGroupResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_contact_group(
        self,
        request: cms_20240330_models.CreateContactGroupRequest,
    ) -> cms_20240330_models.CreateContactGroupResponse:
        """
        @summary 创建联系人组
        
        @param request: CreateContactGroupRequest
        @return: CreateContactGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_contact_group_with_options(request, headers, runtime)

    async def create_contact_group_async(
        self,
        request: cms_20240330_models.CreateContactGroupRequest,
    ) -> cms_20240330_models.CreateContactGroupResponse:
        """
        @summary 创建联系人组
        
        @param request: CreateContactGroupRequest
        @return: CreateContactGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_contact_group_with_options_async(request, headers, runtime)

    def create_entity_group_with_options(
        self,
        request: cms_20240330_models.CreateEntityGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateEntityGroupResponse:
        """
        @summary 创建实体组
        
        @param request: CreateEntityGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateEntityGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.description):
            body['description'] = request.description
        if not UtilClient.is_unset(request.entity_group_name):
            body['entityGroupName'] = request.entity_group_name
        if not UtilClient.is_unset(request.entity_rules):
            body['entityRules'] = request.entity_rules
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateEntityGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/entity-groups',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateEntityGroupResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateEntityGroupResponse(),
                self.execute(params, req, runtime)
            )

    async def create_entity_group_with_options_async(
        self,
        request: cms_20240330_models.CreateEntityGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateEntityGroupResponse:
        """
        @summary 创建实体组
        
        @param request: CreateEntityGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateEntityGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.description):
            body['description'] = request.description
        if not UtilClient.is_unset(request.entity_group_name):
            body['entityGroupName'] = request.entity_group_name
        if not UtilClient.is_unset(request.entity_rules):
            body['entityRules'] = request.entity_rules
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateEntityGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/entity-groups',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateEntityGroupResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateEntityGroupResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_entity_group(
        self,
        request: cms_20240330_models.CreateEntityGroupRequest,
    ) -> cms_20240330_models.CreateEntityGroupResponse:
        """
        @summary 创建实体组
        
        @param request: CreateEntityGroupRequest
        @return: CreateEntityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_entity_group_with_options(request, headers, runtime)

    async def create_entity_group_async(
        self,
        request: cms_20240330_models.CreateEntityGroupRequest,
    ) -> cms_20240330_models.CreateEntityGroupResponse:
        """
        @summary 创建实体组
        
        @param request: CreateEntityGroupRequest
        @return: CreateEntityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_entity_group_with_options_async(request, headers, runtime)

    def create_entity_store_with_options(
        self,
        workspace_name: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateEntityStoreResponse:
        """
        @summary 创建EntityStore相关存储
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateEntityStoreResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='CreateEntityStore',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace_name)}/entitystore',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateEntityStoreResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateEntityStoreResponse(),
                self.execute(params, req, runtime)
            )

    async def create_entity_store_with_options_async(
        self,
        workspace_name: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateEntityStoreResponse:
        """
        @summary 创建EntityStore相关存储
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateEntityStoreResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='CreateEntityStore',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace_name)}/entitystore',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateEntityStoreResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateEntityStoreResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_entity_store(
        self,
        workspace_name: str,
    ) -> cms_20240330_models.CreateEntityStoreResponse:
        """
        @summary 创建EntityStore相关存储
        
        @return: CreateEntityStoreResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_entity_store_with_options(workspace_name, headers, runtime)

    async def create_entity_store_async(
        self,
        workspace_name: str,
    ) -> cms_20240330_models.CreateEntityStoreResponse:
        """
        @summary 创建EntityStore相关存储
        
        @return: CreateEntityStoreResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_entity_store_with_options_async(workspace_name, headers, runtime)

    def create_environment_with_options(
        self,
        request: cms_20240330_models.CreateEnvironmentRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateEnvironmentResponse:
        """
        @summary 创建arms环境实例
        
        @param request: CreateEnvironmentRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateEnvironmentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['AliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.bind_resource_id):
            query['BindResourceId'] = request.bind_resource_id
        if not UtilClient.is_unset(request.environment_name):
            query['EnvironmentName'] = request.environment_name
        if not UtilClient.is_unset(request.environment_sub_type):
            query['EnvironmentSubType'] = request.environment_sub_type
        if not UtilClient.is_unset(request.environment_type):
            query['EnvironmentType'] = request.environment_type
        if not UtilClient.is_unset(request.fee_package):
            query['FeePackage'] = request.fee_package
        if not UtilClient.is_unset(request.init_environment):
            query['InitEnvironment'] = request.init_environment
        if not UtilClient.is_unset(request.managed_type):
            query['ManagedType'] = request.managed_type
        if not UtilClient.is_unset(request.prometheus_instance_id):
            query['PrometheusInstanceId'] = request.prometheus_instance_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.workspace):
            query['Workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateEnvironment',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/CreateEnvironment',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateEnvironmentResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateEnvironmentResponse(),
                self.execute(params, req, runtime)
            )

    async def create_environment_with_options_async(
        self,
        request: cms_20240330_models.CreateEnvironmentRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateEnvironmentResponse:
        """
        @summary 创建arms环境实例
        
        @param request: CreateEnvironmentRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateEnvironmentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['AliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.bind_resource_id):
            query['BindResourceId'] = request.bind_resource_id
        if not UtilClient.is_unset(request.environment_name):
            query['EnvironmentName'] = request.environment_name
        if not UtilClient.is_unset(request.environment_sub_type):
            query['EnvironmentSubType'] = request.environment_sub_type
        if not UtilClient.is_unset(request.environment_type):
            query['EnvironmentType'] = request.environment_type
        if not UtilClient.is_unset(request.fee_package):
            query['FeePackage'] = request.fee_package
        if not UtilClient.is_unset(request.init_environment):
            query['InitEnvironment'] = request.init_environment
        if not UtilClient.is_unset(request.managed_type):
            query['ManagedType'] = request.managed_type
        if not UtilClient.is_unset(request.prometheus_instance_id):
            query['PrometheusInstanceId'] = request.prometheus_instance_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.tags):
            query['Tags'] = request.tags
        if not UtilClient.is_unset(request.workspace):
            query['Workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateEnvironment',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/CreateEnvironment',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateEnvironmentResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateEnvironmentResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_environment(
        self,
        request: cms_20240330_models.CreateEnvironmentRequest,
    ) -> cms_20240330_models.CreateEnvironmentResponse:
        """
        @summary 创建arms环境实例
        
        @param request: CreateEnvironmentRequest
        @return: CreateEnvironmentResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_environment_with_options(request, headers, runtime)

    async def create_environment_async(
        self,
        request: cms_20240330_models.CreateEnvironmentRequest,
    ) -> cms_20240330_models.CreateEnvironmentResponse:
        """
        @summary 创建arms环境实例
        
        @param request: CreateEnvironmentRequest
        @return: CreateEnvironmentResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_environment_with_options_async(request, headers, runtime)

    def create_escalation_with_options(
        self,
        request: cms_20240330_models.CreateEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateEscalationResponse:
        """
        @summary 创建通知配置
        
        @param request: CreateEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='CreateEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/escalations',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateEscalationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateEscalationResponse(),
                self.execute(params, req, runtime)
            )

    async def create_escalation_with_options_async(
        self,
        request: cms_20240330_models.CreateEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateEscalationResponse:
        """
        @summary 创建通知配置
        
        @param request: CreateEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='CreateEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/escalations',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateEscalationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateEscalationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_escalation(
        self,
        request: cms_20240330_models.CreateEscalationRequest,
    ) -> cms_20240330_models.CreateEscalationResponse:
        """
        @summary 创建通知配置
        
        @param request: CreateEscalationRequest
        @return: CreateEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_escalation_with_options(request, headers, runtime)

    async def create_escalation_async(
        self,
        request: cms_20240330_models.CreateEscalationRequest,
    ) -> cms_20240330_models.CreateEscalationResponse:
        """
        @summary 创建通知配置
        
        @param request: CreateEscalationRequest
        @return: CreateEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_escalation_with_options_async(request, headers, runtime)

    def create_incident_escalation_with_options(
        self,
        request: cms_20240330_models.CreateIncidentEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateIncidentEscalationResponse:
        """
        @summary 创建Incident升级计划
        
        @param request: CreateIncidentEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIncidentEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.stage):
            query['stage'] = request.stage
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIncidentEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/escalation/create',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateIncidentEscalationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateIncidentEscalationResponse(),
                self.execute(params, req, runtime)
            )

    async def create_incident_escalation_with_options_async(
        self,
        request: cms_20240330_models.CreateIncidentEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateIncidentEscalationResponse:
        """
        @summary 创建Incident升级计划
        
        @param request: CreateIncidentEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIncidentEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['description'] = request.description
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.stage):
            query['stage'] = request.stage
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIncidentEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/escalation/create',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateIncidentEscalationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateIncidentEscalationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_incident_escalation(
        self,
        request: cms_20240330_models.CreateIncidentEscalationRequest,
    ) -> cms_20240330_models.CreateIncidentEscalationResponse:
        """
        @summary 创建Incident升级计划
        
        @param request: CreateIncidentEscalationRequest
        @return: CreateIncidentEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_incident_escalation_with_options(request, headers, runtime)

    async def create_incident_escalation_async(
        self,
        request: cms_20240330_models.CreateIncidentEscalationRequest,
    ) -> cms_20240330_models.CreateIncidentEscalationResponse:
        """
        @summary 创建Incident升级计划
        
        @param request: CreateIncidentEscalationRequest
        @return: CreateIncidentEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_incident_escalation_with_options_async(request, headers, runtime)

    def create_incident_plan_with_options(
        self,
        request: cms_20240330_models.CreateIncidentPlanRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateIncidentPlanResponse:
        """
        @summary 创建 Incident 处理计划
        
        @param request: CreateIncidentPlanRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIncidentPlanResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_recover_seconds):
            query['autoRecoverSeconds'] = request.auto_recover_seconds
        if not UtilClient.is_unset(request.corporation):
            query['corporation'] = request.corporation
        if not UtilClient.is_unset(request.description):
            query['description'] = request.description
        if not UtilClient.is_unset(request.escalation_id):
            query['escalationId'] = request.escalation_id
        if not UtilClient.is_unset(request.group_by):
            query['groupBy'] = request.group_by
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.resource_field):
            query['resourceField'] = request.resource_field
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIncidentPlan',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/plan/create',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateIncidentPlanResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateIncidentPlanResponse(),
                self.execute(params, req, runtime)
            )

    async def create_incident_plan_with_options_async(
        self,
        request: cms_20240330_models.CreateIncidentPlanRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateIncidentPlanResponse:
        """
        @summary 创建 Incident 处理计划
        
        @param request: CreateIncidentPlanRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIncidentPlanResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_recover_seconds):
            query['autoRecoverSeconds'] = request.auto_recover_seconds
        if not UtilClient.is_unset(request.corporation):
            query['corporation'] = request.corporation
        if not UtilClient.is_unset(request.description):
            query['description'] = request.description
        if not UtilClient.is_unset(request.escalation_id):
            query['escalationId'] = request.escalation_id
        if not UtilClient.is_unset(request.group_by):
            query['groupBy'] = request.group_by
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.resource_field):
            query['resourceField'] = request.resource_field
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='CreateIncidentPlan',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/plan/create',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateIncidentPlanResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateIncidentPlanResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_incident_plan(
        self,
        request: cms_20240330_models.CreateIncidentPlanRequest,
    ) -> cms_20240330_models.CreateIncidentPlanResponse:
        """
        @summary 创建 Incident 处理计划
        
        @param request: CreateIncidentPlanRequest
        @return: CreateIncidentPlanResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_incident_plan_with_options(request, headers, runtime)

    async def create_incident_plan_async(
        self,
        request: cms_20240330_models.CreateIncidentPlanRequest,
    ) -> cms_20240330_models.CreateIncidentPlanResponse:
        """
        @summary 创建 Incident 处理计划
        
        @param request: CreateIncidentPlanRequest
        @return: CreateIncidentPlanResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_incident_plan_with_options_async(request, headers, runtime)

    def create_integration_with_options(
        self,
        request: cms_20240330_models.CreateIntegrationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateIntegrationResponse:
        """
        @summary 创建集成
        
        @param request: CreateIntegrationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIntegrationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='CreateIntegration',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integrations',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateIntegrationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateIntegrationResponse(),
                self.execute(params, req, runtime)
            )

    async def create_integration_with_options_async(
        self,
        request: cms_20240330_models.CreateIntegrationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateIntegrationResponse:
        """
        @summary 创建集成
        
        @param request: CreateIntegrationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIntegrationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='CreateIntegration',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integrations',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateIntegrationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateIntegrationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_integration(
        self,
        request: cms_20240330_models.CreateIntegrationRequest,
    ) -> cms_20240330_models.CreateIntegrationResponse:
        """
        @summary 创建集成
        
        @param request: CreateIntegrationRequest
        @return: CreateIntegrationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_integration_with_options(request, headers, runtime)

    async def create_integration_async(
        self,
        request: cms_20240330_models.CreateIntegrationRequest,
    ) -> cms_20240330_models.CreateIntegrationResponse:
        """
        @summary 创建集成
        
        @param request: CreateIntegrationRequest
        @return: CreateIntegrationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_integration_with_options_async(request, headers, runtime)

    def create_integration_policy_with_options(
        self,
        request: cms_20240330_models.CreateIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateIntegrationPolicyResponse:
        """
        @summary 创建接入中心策略
        
        @param request: CreateIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.entity_group):
            body['entityGroup'] = request.entity_group
        if not UtilClient.is_unset(request.policy_name):
            body['policyName'] = request.policy_name
        if not UtilClient.is_unset(request.policy_type):
            body['policyType'] = request.policy_type
        if not UtilClient.is_unset(request.resource_group_id):
            body['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.tags):
            body['tags'] = request.tags
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateIntegrationPolicyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateIntegrationPolicyResponse(),
                self.execute(params, req, runtime)
            )

    async def create_integration_policy_with_options_async(
        self,
        request: cms_20240330_models.CreateIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateIntegrationPolicyResponse:
        """
        @summary 创建接入中心策略
        
        @param request: CreateIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.entity_group):
            body['entityGroup'] = request.entity_group
        if not UtilClient.is_unset(request.policy_name):
            body['policyName'] = request.policy_name
        if not UtilClient.is_unset(request.policy_type):
            body['policyType'] = request.policy_type
        if not UtilClient.is_unset(request.resource_group_id):
            body['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.tags):
            body['tags'] = request.tags
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateIntegrationPolicyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateIntegrationPolicyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_integration_policy(
        self,
        request: cms_20240330_models.CreateIntegrationPolicyRequest,
    ) -> cms_20240330_models.CreateIntegrationPolicyResponse:
        """
        @summary 创建接入中心策略
        
        @param request: CreateIntegrationPolicyRequest
        @return: CreateIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_integration_policy_with_options(request, headers, runtime)

    async def create_integration_policy_async(
        self,
        request: cms_20240330_models.CreateIntegrationPolicyRequest,
    ) -> cms_20240330_models.CreateIntegrationPolicyResponse:
        """
        @summary 创建接入中心策略
        
        @param request: CreateIntegrationPolicyRequest
        @return: CreateIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_integration_policy_with_options_async(request, headers, runtime)

    def create_maintain_window_with_options(
        self,
        request: cms_20240330_models.CreateMaintainWindowRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateMaintainWindowResponse:
        """
        @summary 创建订阅
        
        @param request: CreateMaintainWindowRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateMaintainWindowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='CreateMaintainWindow',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/maintainWindows',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateMaintainWindowResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateMaintainWindowResponse(),
                self.execute(params, req, runtime)
            )

    async def create_maintain_window_with_options_async(
        self,
        request: cms_20240330_models.CreateMaintainWindowRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateMaintainWindowResponse:
        """
        @summary 创建订阅
        
        @param request: CreateMaintainWindowRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateMaintainWindowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='CreateMaintainWindow',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/maintainWindows',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateMaintainWindowResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateMaintainWindowResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_maintain_window(
        self,
        request: cms_20240330_models.CreateMaintainWindowRequest,
    ) -> cms_20240330_models.CreateMaintainWindowResponse:
        """
        @summary 创建订阅
        
        @param request: CreateMaintainWindowRequest
        @return: CreateMaintainWindowResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_maintain_window_with_options(request, headers, runtime)

    async def create_maintain_window_async(
        self,
        request: cms_20240330_models.CreateMaintainWindowRequest,
    ) -> cms_20240330_models.CreateMaintainWindowResponse:
        """
        @summary 创建订阅
        
        @param request: CreateMaintainWindowRequest
        @return: CreateMaintainWindowResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_maintain_window_with_options_async(request, headers, runtime)

    def create_notify_strategy_with_options(
        self,
        request: cms_20240330_models.CreateNotifyStrategyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateNotifyStrategyResponse:
        """
        @summary 创建订阅
        
        @param request: CreateNotifyStrategyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateNotifyStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='CreateNotifyStrategy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/notifyStrategies',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateNotifyStrategyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateNotifyStrategyResponse(),
                self.execute(params, req, runtime)
            )

    async def create_notify_strategy_with_options_async(
        self,
        request: cms_20240330_models.CreateNotifyStrategyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateNotifyStrategyResponse:
        """
        @summary 创建订阅
        
        @param request: CreateNotifyStrategyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateNotifyStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='CreateNotifyStrategy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/notifyStrategies',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateNotifyStrategyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateNotifyStrategyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_notify_strategy(
        self,
        request: cms_20240330_models.CreateNotifyStrategyRequest,
    ) -> cms_20240330_models.CreateNotifyStrategyResponse:
        """
        @summary 创建订阅
        
        @param request: CreateNotifyStrategyRequest
        @return: CreateNotifyStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_notify_strategy_with_options(request, headers, runtime)

    async def create_notify_strategy_async(
        self,
        request: cms_20240330_models.CreateNotifyStrategyRequest,
    ) -> cms_20240330_models.CreateNotifyStrategyResponse:
        """
        @summary 创建订阅
        
        @param request: CreateNotifyStrategyRequest
        @return: CreateNotifyStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_notify_strategy_with_options_async(request, headers, runtime)

    def create_oncall_schedule_with_options(
        self,
        request: cms_20240330_models.CreateOncallScheduleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateOncallScheduleResponse:
        """
        @summary 创建OncallSchedule
        
        @param request: CreateOncallScheduleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateOncallScheduleResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.oncall_schedule_id):
            body['oncallScheduleId'] = request.oncall_schedule_id
        if not UtilClient.is_unset(request.oncall_schedule_name):
            body['oncallScheduleName'] = request.oncall_schedule_name
        if not UtilClient.is_unset(request.rotations):
            body['rotations'] = request.rotations
        if not UtilClient.is_unset(request.shift_robot_id):
            body['shiftRobotId'] = request.shift_robot_id
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateOncallSchedule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/oncallschedule',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateOncallScheduleResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateOncallScheduleResponse(),
                self.execute(params, req, runtime)
            )

    async def create_oncall_schedule_with_options_async(
        self,
        request: cms_20240330_models.CreateOncallScheduleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateOncallScheduleResponse:
        """
        @summary 创建OncallSchedule
        
        @param request: CreateOncallScheduleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateOncallScheduleResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.oncall_schedule_id):
            body['oncallScheduleId'] = request.oncall_schedule_id
        if not UtilClient.is_unset(request.oncall_schedule_name):
            body['oncallScheduleName'] = request.oncall_schedule_name
        if not UtilClient.is_unset(request.rotations):
            body['rotations'] = request.rotations
        if not UtilClient.is_unset(request.shift_robot_id):
            body['shiftRobotId'] = request.shift_robot_id
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateOncallSchedule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/oncallschedule',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateOncallScheduleResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateOncallScheduleResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_oncall_schedule(
        self,
        request: cms_20240330_models.CreateOncallScheduleRequest,
    ) -> cms_20240330_models.CreateOncallScheduleResponse:
        """
        @summary 创建OncallSchedule
        
        @param request: CreateOncallScheduleRequest
        @return: CreateOncallScheduleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_oncall_schedule_with_options(request, headers, runtime)

    async def create_oncall_schedule_async(
        self,
        request: cms_20240330_models.CreateOncallScheduleRequest,
    ) -> cms_20240330_models.CreateOncallScheduleResponse:
        """
        @summary 创建OncallSchedule
        
        @param request: CreateOncallScheduleRequest
        @return: CreateOncallScheduleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_oncall_schedule_with_options_async(request, headers, runtime)

    def create_policy_with_options(
        self,
        request: cms_20240330_models.CreatePolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreatePolicyResponse:
        """
        @summary 创建接入中心策略
        
        @param request: CreatePolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePolicyResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.filter):
            body['filter'] = request.filter
        if not UtilClient.is_unset(request.policy_name):
            body['policyName'] = request.policy_name
        if not UtilClient.is_unset(request.policy_type):
            body['policyType'] = request.policy_type
        if not UtilClient.is_unset(request.region):
            body['region'] = request.region
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreatePolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreatePolicyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreatePolicyResponse(),
                self.execute(params, req, runtime)
            )

    async def create_policy_with_options_async(
        self,
        request: cms_20240330_models.CreatePolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreatePolicyResponse:
        """
        @summary 创建接入中心策略
        
        @param request: CreatePolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePolicyResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.filter):
            body['filter'] = request.filter
        if not UtilClient.is_unset(request.policy_name):
            body['policyName'] = request.policy_name
        if not UtilClient.is_unset(request.policy_type):
            body['policyType'] = request.policy_type
        if not UtilClient.is_unset(request.region):
            body['region'] = request.region
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreatePolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreatePolicyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreatePolicyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_policy(
        self,
        request: cms_20240330_models.CreatePolicyRequest,
    ) -> cms_20240330_models.CreatePolicyResponse:
        """
        @summary 创建接入中心策略
        
        @param request: CreatePolicyRequest
        @return: CreatePolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_policy_with_options(request, headers, runtime)

    async def create_policy_async(
        self,
        request: cms_20240330_models.CreatePolicyRequest,
    ) -> cms_20240330_models.CreatePolicyResponse:
        """
        @summary 创建接入中心策略
        
        @param request: CreatePolicyRequest
        @return: CreatePolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_policy_with_options_async(request, headers, runtime)

    def create_prometheus_instance_with_options(
        self,
        request: cms_20240330_models.CreatePrometheusInstanceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreatePrometheusInstanceResponse:
        """
        @summary 创建Prometheus监控实例
        
        @param request: CreatePrometheusInstanceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePrometheusInstanceResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.archive_duration):
            body['archiveDuration'] = request.archive_duration
        if not UtilClient.is_unset(request.auth_free_read_policy):
            body['authFreeReadPolicy'] = request.auth_free_read_policy
        if not UtilClient.is_unset(request.auth_free_write_policy):
            body['authFreeWritePolicy'] = request.auth_free_write_policy
        if not UtilClient.is_unset(request.enable_auth_free_read):
            body['enableAuthFreeRead'] = request.enable_auth_free_read
        if not UtilClient.is_unset(request.enable_auth_free_write):
            body['enableAuthFreeWrite'] = request.enable_auth_free_write
        if not UtilClient.is_unset(request.enable_auth_token):
            body['enableAuthToken'] = request.enable_auth_token
        if not UtilClient.is_unset(request.payment_type):
            body['paymentType'] = request.payment_type
        if not UtilClient.is_unset(request.prometheus_instance_name):
            body['prometheusInstanceName'] = request.prometheus_instance_name
        if not UtilClient.is_unset(request.resource_group_id):
            body['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.status):
            body['status'] = request.status
        if not UtilClient.is_unset(request.storage_duration):
            body['storageDuration'] = request.storage_duration
        if not UtilClient.is_unset(request.tags):
            body['tags'] = request.tags
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreatePrometheusInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreatePrometheusInstanceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreatePrometheusInstanceResponse(),
                self.execute(params, req, runtime)
            )

    async def create_prometheus_instance_with_options_async(
        self,
        request: cms_20240330_models.CreatePrometheusInstanceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreatePrometheusInstanceResponse:
        """
        @summary 创建Prometheus监控实例
        
        @param request: CreatePrometheusInstanceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePrometheusInstanceResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.archive_duration):
            body['archiveDuration'] = request.archive_duration
        if not UtilClient.is_unset(request.auth_free_read_policy):
            body['authFreeReadPolicy'] = request.auth_free_read_policy
        if not UtilClient.is_unset(request.auth_free_write_policy):
            body['authFreeWritePolicy'] = request.auth_free_write_policy
        if not UtilClient.is_unset(request.enable_auth_free_read):
            body['enableAuthFreeRead'] = request.enable_auth_free_read
        if not UtilClient.is_unset(request.enable_auth_free_write):
            body['enableAuthFreeWrite'] = request.enable_auth_free_write
        if not UtilClient.is_unset(request.enable_auth_token):
            body['enableAuthToken'] = request.enable_auth_token
        if not UtilClient.is_unset(request.payment_type):
            body['paymentType'] = request.payment_type
        if not UtilClient.is_unset(request.prometheus_instance_name):
            body['prometheusInstanceName'] = request.prometheus_instance_name
        if not UtilClient.is_unset(request.resource_group_id):
            body['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.status):
            body['status'] = request.status
        if not UtilClient.is_unset(request.storage_duration):
            body['storageDuration'] = request.storage_duration
        if not UtilClient.is_unset(request.tags):
            body['tags'] = request.tags
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreatePrometheusInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreatePrometheusInstanceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreatePrometheusInstanceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_prometheus_instance(
        self,
        request: cms_20240330_models.CreatePrometheusInstanceRequest,
    ) -> cms_20240330_models.CreatePrometheusInstanceResponse:
        """
        @summary 创建Prometheus监控实例
        
        @param request: CreatePrometheusInstanceRequest
        @return: CreatePrometheusInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_prometheus_instance_with_options(request, headers, runtime)

    async def create_prometheus_instance_async(
        self,
        request: cms_20240330_models.CreatePrometheusInstanceRequest,
    ) -> cms_20240330_models.CreatePrometheusInstanceResponse:
        """
        @summary 创建Prometheus监控实例
        
        @param request: CreatePrometheusInstanceRequest
        @return: CreatePrometheusInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_prometheus_instance_with_options_async(request, headers, runtime)

    def create_prometheus_view_with_options(
        self,
        request: cms_20240330_models.CreatePrometheusViewRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreatePrometheusViewResponse:
        """
        @summary 创建prometheus视图
        
        @param request: CreatePrometheusViewRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePrometheusViewResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.auth_free_read_policy):
            body['authFreeReadPolicy'] = request.auth_free_read_policy
        if not UtilClient.is_unset(request.enable_auth_free_read):
            body['enableAuthFreeRead'] = request.enable_auth_free_read
        if not UtilClient.is_unset(request.enable_auth_token):
            body['enableAuthToken'] = request.enable_auth_token
        if not UtilClient.is_unset(request.prometheus_instances):
            body['prometheusInstances'] = request.prometheus_instances
        if not UtilClient.is_unset(request.prometheus_view_name):
            body['prometheusViewName'] = request.prometheus_view_name
        if not UtilClient.is_unset(request.resource_group_id):
            body['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.status):
            body['status'] = request.status
        if not UtilClient.is_unset(request.tags):
            body['tags'] = request.tags
        if not UtilClient.is_unset(request.version):
            body['version'] = request.version
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreatePrometheusView',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-views',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreatePrometheusViewResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreatePrometheusViewResponse(),
                self.execute(params, req, runtime)
            )

    async def create_prometheus_view_with_options_async(
        self,
        request: cms_20240330_models.CreatePrometheusViewRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreatePrometheusViewResponse:
        """
        @summary 创建prometheus视图
        
        @param request: CreatePrometheusViewRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreatePrometheusViewResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.auth_free_read_policy):
            body['authFreeReadPolicy'] = request.auth_free_read_policy
        if not UtilClient.is_unset(request.enable_auth_free_read):
            body['enableAuthFreeRead'] = request.enable_auth_free_read
        if not UtilClient.is_unset(request.enable_auth_token):
            body['enableAuthToken'] = request.enable_auth_token
        if not UtilClient.is_unset(request.prometheus_instances):
            body['prometheusInstances'] = request.prometheus_instances
        if not UtilClient.is_unset(request.prometheus_view_name):
            body['prometheusViewName'] = request.prometheus_view_name
        if not UtilClient.is_unset(request.resource_group_id):
            body['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.status):
            body['status'] = request.status
        if not UtilClient.is_unset(request.tags):
            body['tags'] = request.tags
        if not UtilClient.is_unset(request.version):
            body['version'] = request.version
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreatePrometheusView',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-views',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreatePrometheusViewResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreatePrometheusViewResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_prometheus_view(
        self,
        request: cms_20240330_models.CreatePrometheusViewRequest,
    ) -> cms_20240330_models.CreatePrometheusViewResponse:
        """
        @summary 创建prometheus视图
        
        @param request: CreatePrometheusViewRequest
        @return: CreatePrometheusViewResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_prometheus_view_with_options(request, headers, runtime)

    async def create_prometheus_view_async(
        self,
        request: cms_20240330_models.CreatePrometheusViewRequest,
    ) -> cms_20240330_models.CreatePrometheusViewResponse:
        """
        @summary 创建prometheus视图
        
        @param request: CreatePrometheusViewRequest
        @return: CreatePrometheusViewResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_prometheus_view_with_options_async(request, headers, runtime)

    def create_rum_instance_with_options(
        self,
        request: cms_20240330_models.CreateRumInstanceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateRumInstanceResponse:
        """
        @summary 创建RUM实例
        
        @param request: CreateRumInstanceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRumInstanceResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.region_id):
            body['regionId'] = request.region_id
        if not UtilClient.is_unset(request.rum_instance_id):
            body['rumInstanceId'] = request.rum_instance_id
        if not UtilClient.is_unset(request.rum_instance_name):
            body['rumInstanceName'] = request.rum_instance_name
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateRumInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/rum-instances',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateRumInstanceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateRumInstanceResponse(),
                self.execute(params, req, runtime)
            )

    async def create_rum_instance_with_options_async(
        self,
        request: cms_20240330_models.CreateRumInstanceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateRumInstanceResponse:
        """
        @summary 创建RUM实例
        
        @param request: CreateRumInstanceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateRumInstanceResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.region_id):
            body['regionId'] = request.region_id
        if not UtilClient.is_unset(request.rum_instance_id):
            body['rumInstanceId'] = request.rum_instance_id
        if not UtilClient.is_unset(request.rum_instance_name):
            body['rumInstanceName'] = request.rum_instance_name
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateRumInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/rum-instances',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateRumInstanceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateRumInstanceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_rum_instance(
        self,
        request: cms_20240330_models.CreateRumInstanceRequest,
    ) -> cms_20240330_models.CreateRumInstanceResponse:
        """
        @summary 创建RUM实例
        
        @param request: CreateRumInstanceRequest
        @return: CreateRumInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_rum_instance_with_options(request, headers, runtime)

    async def create_rum_instance_async(
        self,
        request: cms_20240330_models.CreateRumInstanceRequest,
    ) -> cms_20240330_models.CreateRumInstanceResponse:
        """
        @summary 创建RUM实例
        
        @param request: CreateRumInstanceRequest
        @return: CreateRumInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_rum_instance_with_options_async(request, headers, runtime)

    def create_subscription_with_options(
        self,
        request: cms_20240330_models.CreateSubscriptionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateSubscriptionResponse:
        """
        @summary 创建订阅
        
        @param request: CreateSubscriptionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSubscriptionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='CreateSubscription',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/subscriptions',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateSubscriptionResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateSubscriptionResponse(),
                self.execute(params, req, runtime)
            )

    async def create_subscription_with_options_async(
        self,
        request: cms_20240330_models.CreateSubscriptionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateSubscriptionResponse:
        """
        @summary 创建订阅
        
        @param request: CreateSubscriptionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateSubscriptionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='CreateSubscription',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/subscriptions',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateSubscriptionResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateSubscriptionResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_subscription(
        self,
        request: cms_20240330_models.CreateSubscriptionRequest,
    ) -> cms_20240330_models.CreateSubscriptionResponse:
        """
        @summary 创建订阅
        
        @param request: CreateSubscriptionRequest
        @return: CreateSubscriptionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_subscription_with_options(request, headers, runtime)

    async def create_subscription_async(
        self,
        request: cms_20240330_models.CreateSubscriptionRequest,
    ) -> cms_20240330_models.CreateSubscriptionResponse:
        """
        @summary 创建订阅
        
        @param request: CreateSubscriptionRequest
        @return: CreateSubscriptionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_subscription_with_options_async(request, headers, runtime)

    def create_transformer_with_options(
        self,
        request: cms_20240330_models.CreateTransformerRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateTransformerResponse:
        """
        @summary 创建订阅
        
        @param request: CreateTransformerRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateTransformerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='CreateTransformer',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/transformers',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateTransformerResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateTransformerResponse(),
                self.execute(params, req, runtime)
            )

    async def create_transformer_with_options_async(
        self,
        request: cms_20240330_models.CreateTransformerRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateTransformerResponse:
        """
        @summary 创建订阅
        
        @param request: CreateTransformerRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateTransformerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='CreateTransformer',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/transformers',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateTransformerResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateTransformerResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_transformer(
        self,
        request: cms_20240330_models.CreateTransformerRequest,
    ) -> cms_20240330_models.CreateTransformerResponse:
        """
        @summary 创建订阅
        
        @param request: CreateTransformerRequest
        @return: CreateTransformerResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_transformer_with_options(request, headers, runtime)

    async def create_transformer_async(
        self,
        request: cms_20240330_models.CreateTransformerRequest,
    ) -> cms_20240330_models.CreateTransformerResponse:
        """
        @summary 创建订阅
        
        @param request: CreateTransformerRequest
        @return: CreateTransformerResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_transformer_with_options_async(request, headers, runtime)

    def create_umodel_with_options(
        self,
        workspace: str,
        request: cms_20240330_models.CreateUmodelRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateUmodelResponse:
        """
        @summary 创建Umodel配置
        
        @param request: CreateUmodelRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateUmodelResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.common_schema_ref):
            body['commonSchemaRef'] = request.common_schema_ref
        if not UtilClient.is_unset(request.description):
            body['description'] = request.description
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateUmodel',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateUmodelResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateUmodelResponse(),
                self.execute(params, req, runtime)
            )

    async def create_umodel_with_options_async(
        self,
        workspace: str,
        request: cms_20240330_models.CreateUmodelRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.CreateUmodelResponse:
        """
        @summary 创建Umodel配置
        
        @param request: CreateUmodelRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: CreateUmodelResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.common_schema_ref):
            body['commonSchemaRef'] = request.common_schema_ref
        if not UtilClient.is_unset(request.description):
            body['description'] = request.description
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='CreateUmodel',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.CreateUmodelResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.CreateUmodelResponse(),
                await self.execute_async(params, req, runtime)
            )

    def create_umodel(
        self,
        workspace: str,
        request: cms_20240330_models.CreateUmodelRequest,
    ) -> cms_20240330_models.CreateUmodelResponse:
        """
        @summary 创建Umodel配置
        
        @param request: CreateUmodelRequest
        @return: CreateUmodelResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.create_umodel_with_options(workspace, request, headers, runtime)

    async def create_umodel_async(
        self,
        workspace: str,
        request: cms_20240330_models.CreateUmodelRequest,
    ) -> cms_20240330_models.CreateUmodelResponse:
        """
        @summary 创建Umodel配置
        
        @param request: CreateUmodelRequest
        @return: CreateUmodelResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.create_umodel_with_options_async(workspace, request, headers, runtime)

    def delete_addon_release_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.DeleteAddonReleaseRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAddonReleaseResponse:
        """
        @summary 删除addon release信息
        
        @param request: DeleteAddonReleaseRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAddonReleaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.force):
            query['force'] = request.force
        if not UtilClient.is_unset(request.release_name):
            query['releaseName'] = request.release_name
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAddonRelease',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/addon-releases',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAddonReleaseResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAddonReleaseResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_addon_release_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.DeleteAddonReleaseRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAddonReleaseResponse:
        """
        @summary 删除addon release信息
        
        @param request: DeleteAddonReleaseRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAddonReleaseResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.force):
            query['force'] = request.force
        if not UtilClient.is_unset(request.release_name):
            query['releaseName'] = request.release_name
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAddonRelease',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/addon-releases',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAddonReleaseResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAddonReleaseResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_addon_release(
        self,
        policy_id: str,
        request: cms_20240330_models.DeleteAddonReleaseRequest,
    ) -> cms_20240330_models.DeleteAddonReleaseResponse:
        """
        @summary 删除addon release信息
        
        @param request: DeleteAddonReleaseRequest
        @return: DeleteAddonReleaseResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_addon_release_with_options(policy_id, request, headers, runtime)

    async def delete_addon_release_async(
        self,
        policy_id: str,
        request: cms_20240330_models.DeleteAddonReleaseRequest,
    ) -> cms_20240330_models.DeleteAddonReleaseResponse:
        """
        @summary 删除addon release信息
        
        @param request: DeleteAddonReleaseRequest
        @return: DeleteAddonReleaseResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_addon_release_with_options_async(policy_id, request, headers, runtime)

    def delete_agg_task_group_with_options(
        self,
        instance_id: str,
        group_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAggTaskGroupResponse:
        """
        @summary 删除聚合任务组
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAggTaskGroupResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeleteAggTaskGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(instance_id)}/agg-task-groups/{OpenApiUtilClient.get_encode_param(group_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAggTaskGroupResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAggTaskGroupResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_agg_task_group_with_options_async(
        self,
        instance_id: str,
        group_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAggTaskGroupResponse:
        """
        @summary 删除聚合任务组
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAggTaskGroupResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeleteAggTaskGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(instance_id)}/agg-task-groups/{OpenApiUtilClient.get_encode_param(group_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAggTaskGroupResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAggTaskGroupResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_agg_task_group(
        self,
        instance_id: str,
        group_id: str,
    ) -> cms_20240330_models.DeleteAggTaskGroupResponse:
        """
        @summary 删除聚合任务组
        
        @return: DeleteAggTaskGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_agg_task_group_with_options(instance_id, group_id, headers, runtime)

    async def delete_agg_task_group_async(
        self,
        instance_id: str,
        group_id: str,
    ) -> cms_20240330_models.DeleteAggTaskGroupResponse:
        """
        @summary 删除聚合任务组
        
        @return: DeleteAggTaskGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_agg_task_group_with_options_async(instance_id, group_id, headers, runtime)

    def delete_alert_action_with_options(
        self,
        request: cms_20240330_models.DeleteAlertActionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAlertActionResponse:
        """
        @summary 删除告警动作
        
        @param request: DeleteAlertActionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAlertActionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.alert_action_id):
            query['alertActionId'] = request.alert_action_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAlertAction',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertAction',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertActionResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertActionResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_alert_action_with_options_async(
        self,
        request: cms_20240330_models.DeleteAlertActionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAlertActionResponse:
        """
        @summary 删除告警动作
        
        @param request: DeleteAlertActionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAlertActionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.alert_action_id):
            query['alertActionId'] = request.alert_action_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAlertAction',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertAction',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertActionResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertActionResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_alert_action(
        self,
        request: cms_20240330_models.DeleteAlertActionRequest,
    ) -> cms_20240330_models.DeleteAlertActionResponse:
        """
        @summary 删除告警动作
        
        @param request: DeleteAlertActionRequest
        @return: DeleteAlertActionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_alert_action_with_options(request, headers, runtime)

    async def delete_alert_action_async(
        self,
        request: cms_20240330_models.DeleteAlertActionRequest,
    ) -> cms_20240330_models.DeleteAlertActionResponse:
        """
        @summary 删除告警动作
        
        @param request: DeleteAlertActionRequest
        @return: DeleteAlertActionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_alert_action_with_options_async(request, headers, runtime)

    def delete_alert_actions_with_options(
        self,
        tmp_req: cms_20240330_models.DeleteAlertActionsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAlertActionsResponse:
        """
        @summary 删除告警动作
        
        @param tmp_req: DeleteAlertActionsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAlertActionsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteAlertActionsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.alert_action_ids):
            request.alert_action_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.alert_action_ids, 'alertActionIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_action_ids_shrink):
            query['alertActionIds'] = request.alert_action_ids_shrink
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAlertActions',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertActions',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertActionsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertActionsResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_alert_actions_with_options_async(
        self,
        tmp_req: cms_20240330_models.DeleteAlertActionsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAlertActionsResponse:
        """
        @summary 删除告警动作
        
        @param tmp_req: DeleteAlertActionsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAlertActionsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteAlertActionsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.alert_action_ids):
            request.alert_action_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.alert_action_ids, 'alertActionIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_action_ids_shrink):
            query['alertActionIds'] = request.alert_action_ids_shrink
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAlertActions',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertActions',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertActionsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertActionsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_alert_actions(
        self,
        request: cms_20240330_models.DeleteAlertActionsRequest,
    ) -> cms_20240330_models.DeleteAlertActionsResponse:
        """
        @summary 删除告警动作
        
        @param request: DeleteAlertActionsRequest
        @return: DeleteAlertActionsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_alert_actions_with_options(request, headers, runtime)

    async def delete_alert_actions_async(
        self,
        request: cms_20240330_models.DeleteAlertActionsRequest,
    ) -> cms_20240330_models.DeleteAlertActionsResponse:
        """
        @summary 删除告警动作
        
        @param request: DeleteAlertActionsRequest
        @return: DeleteAlertActionsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_alert_actions_with_options_async(request, headers, runtime)

    def delete_alert_event_integration_policy_with_options(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.DeleteAlertEventIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAlertEventIntegrationPolicyResponse:
        """
        @summary 删除集成
        
        @param request: DeleteAlertEventIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAlertEventIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAlertEventIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertEventIntegrationPolicies/{OpenApiUtilClient.get_encode_param(alert_event_integration_policy_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertEventIntegrationPolicyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertEventIntegrationPolicyResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_alert_event_integration_policy_with_options_async(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.DeleteAlertEventIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAlertEventIntegrationPolicyResponse:
        """
        @summary 删除集成
        
        @param request: DeleteAlertEventIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAlertEventIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAlertEventIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertEventIntegrationPolicies/{OpenApiUtilClient.get_encode_param(alert_event_integration_policy_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertEventIntegrationPolicyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertEventIntegrationPolicyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_alert_event_integration_policy(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.DeleteAlertEventIntegrationPolicyRequest,
    ) -> cms_20240330_models.DeleteAlertEventIntegrationPolicyResponse:
        """
        @summary 删除集成
        
        @param request: DeleteAlertEventIntegrationPolicyRequest
        @return: DeleteAlertEventIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_alert_event_integration_policy_with_options(alert_event_integration_policy_id, request, headers, runtime)

    async def delete_alert_event_integration_policy_async(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.DeleteAlertEventIntegrationPolicyRequest,
    ) -> cms_20240330_models.DeleteAlertEventIntegrationPolicyResponse:
        """
        @summary 删除集成
        
        @param request: DeleteAlertEventIntegrationPolicyRequest
        @return: DeleteAlertEventIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_alert_event_integration_policy_with_options_async(alert_event_integration_policy_id, request, headers, runtime)

    def delete_alert_notify_templates_with_options(
        self,
        tmp_req: cms_20240330_models.DeleteAlertNotifyTemplatesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAlertNotifyTemplatesResponse:
        """
        @summary 删除报警通知模板
        
        @param tmp_req: DeleteAlertNotifyTemplatesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAlertNotifyTemplatesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteAlertNotifyTemplatesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.alert_notify_template_ids):
            request.alert_notify_template_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.alert_notify_template_ids, 'alertNotifyTemplateIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_notify_template_ids_shrink):
            query['alertNotifyTemplateIds'] = request.alert_notify_template_ids_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAlertNotifyTemplates',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertNotifyTemplates',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertNotifyTemplatesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertNotifyTemplatesResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_alert_notify_templates_with_options_async(
        self,
        tmp_req: cms_20240330_models.DeleteAlertNotifyTemplatesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAlertNotifyTemplatesResponse:
        """
        @summary 删除报警通知模板
        
        @param tmp_req: DeleteAlertNotifyTemplatesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAlertNotifyTemplatesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteAlertNotifyTemplatesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.alert_notify_template_ids):
            request.alert_notify_template_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.alert_notify_template_ids, 'alertNotifyTemplateIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_notify_template_ids_shrink):
            query['alertNotifyTemplateIds'] = request.alert_notify_template_ids_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAlertNotifyTemplates',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertNotifyTemplates',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertNotifyTemplatesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertNotifyTemplatesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_alert_notify_templates(
        self,
        request: cms_20240330_models.DeleteAlertNotifyTemplatesRequest,
    ) -> cms_20240330_models.DeleteAlertNotifyTemplatesResponse:
        """
        @summary 删除报警通知模板
        
        @param request: DeleteAlertNotifyTemplatesRequest
        @return: DeleteAlertNotifyTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_alert_notify_templates_with_options(request, headers, runtime)

    async def delete_alert_notify_templates_async(
        self,
        request: cms_20240330_models.DeleteAlertNotifyTemplatesRequest,
    ) -> cms_20240330_models.DeleteAlertNotifyTemplatesResponse:
        """
        @summary 删除报警通知模板
        
        @param request: DeleteAlertNotifyTemplatesRequest
        @return: DeleteAlertNotifyTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_alert_notify_templates_with_options_async(request, headers, runtime)

    def delete_alert_robots_with_options(
        self,
        tmp_req: cms_20240330_models.DeleteAlertRobotsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAlertRobotsResponse:
        """
        @summary 删除机器人
        
        @param tmp_req: DeleteAlertRobotsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAlertRobotsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteAlertRobotsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.robot_ids):
            request.robot_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.robot_ids, 'robotIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.is_custom):
            query['isCustom'] = request.is_custom
        if not UtilClient.is_unset(request.robot_ids_shrink):
            query['robotIds'] = request.robot_ids_shrink
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.type):
            query['type'] = request.type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAlertRobots',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/robots',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertRobotsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertRobotsResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_alert_robots_with_options_async(
        self,
        tmp_req: cms_20240330_models.DeleteAlertRobotsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAlertRobotsResponse:
        """
        @summary 删除机器人
        
        @param tmp_req: DeleteAlertRobotsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAlertRobotsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteAlertRobotsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.robot_ids):
            request.robot_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.robot_ids, 'robotIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.is_custom):
            query['isCustom'] = request.is_custom
        if not UtilClient.is_unset(request.robot_ids_shrink):
            query['robotIds'] = request.robot_ids_shrink
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.type):
            query['type'] = request.type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAlertRobots',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/robots',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertRobotsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertRobotsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_alert_robots(
        self,
        request: cms_20240330_models.DeleteAlertRobotsRequest,
    ) -> cms_20240330_models.DeleteAlertRobotsResponse:
        """
        @summary 删除机器人
        
        @param request: DeleteAlertRobotsRequest
        @return: DeleteAlertRobotsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_alert_robots_with_options(request, headers, runtime)

    async def delete_alert_robots_async(
        self,
        request: cms_20240330_models.DeleteAlertRobotsRequest,
    ) -> cms_20240330_models.DeleteAlertRobotsResponse:
        """
        @summary 删除机器人
        
        @param request: DeleteAlertRobotsRequest
        @return: DeleteAlertRobotsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_alert_robots_with_options_async(request, headers, runtime)

    def delete_alert_rules_with_options(
        self,
        tmp_req: cms_20240330_models.DeleteAlertRulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAlertRulesResponse:
        """
        @summary 删除云监控2.0告警规则
        
        @param tmp_req: DeleteAlertRulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAlertRulesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteAlertRulesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.alert_rule_ids):
            request.alert_rule_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.alert_rule_ids, 'alertRuleIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_rule_ids_shrink):
            query['alertRuleIds'] = request.alert_rule_ids_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAlertRules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules/action/delete',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertRulesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertRulesResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_alert_rules_with_options_async(
        self,
        tmp_req: cms_20240330_models.DeleteAlertRulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAlertRulesResponse:
        """
        @summary 删除云监控2.0告警规则
        
        @param tmp_req: DeleteAlertRulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAlertRulesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteAlertRulesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.alert_rule_ids):
            request.alert_rule_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.alert_rule_ids, 'alertRuleIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_rule_ids_shrink):
            query['alertRuleIds'] = request.alert_rule_ids_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAlertRules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules/action/delete',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertRulesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertRulesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_alert_rules(
        self,
        request: cms_20240330_models.DeleteAlertRulesRequest,
    ) -> cms_20240330_models.DeleteAlertRulesResponse:
        """
        @summary 删除云监控2.0告警规则
        
        @param request: DeleteAlertRulesRequest
        @return: DeleteAlertRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_alert_rules_with_options(request, headers, runtime)

    async def delete_alert_rules_async(
        self,
        request: cms_20240330_models.DeleteAlertRulesRequest,
    ) -> cms_20240330_models.DeleteAlertRulesResponse:
        """
        @summary 删除云监控2.0告警规则
        
        @param request: DeleteAlertRulesRequest
        @return: DeleteAlertRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_alert_rules_with_options_async(request, headers, runtime)

    def delete_alert_webhook_with_options(
        self,
        tmp_req: cms_20240330_models.DeleteAlertWebhookRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAlertWebhookResponse:
        """
        @summary 删除Webhook
        
        @param tmp_req: DeleteAlertWebhookRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAlertWebhookResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteAlertWebhookShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.webhook_ids):
            request.webhook_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.webhook_ids, 'webhookIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.type):
            query['type'] = request.type
        if not UtilClient.is_unset(request.webhook_ids_shrink):
            query['webhookIds'] = request.webhook_ids_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAlertWebhook',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/webhook',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertWebhookResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertWebhookResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_alert_webhook_with_options_async(
        self,
        tmp_req: cms_20240330_models.DeleteAlertWebhookRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAlertWebhookResponse:
        """
        @summary 删除Webhook
        
        @param tmp_req: DeleteAlertWebhookRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAlertWebhookResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteAlertWebhookShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.webhook_ids):
            request.webhook_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.webhook_ids, 'webhookIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.type):
            query['type'] = request.type
        if not UtilClient.is_unset(request.webhook_ids_shrink):
            query['webhookIds'] = request.webhook_ids_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAlertWebhook',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/webhook',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertWebhookResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertWebhookResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_alert_webhook(
        self,
        request: cms_20240330_models.DeleteAlertWebhookRequest,
    ) -> cms_20240330_models.DeleteAlertWebhookResponse:
        """
        @summary 删除Webhook
        
        @param request: DeleteAlertWebhookRequest
        @return: DeleteAlertWebhookResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_alert_webhook_with_options(request, headers, runtime)

    async def delete_alert_webhook_async(
        self,
        request: cms_20240330_models.DeleteAlertWebhookRequest,
    ) -> cms_20240330_models.DeleteAlertWebhookResponse:
        """
        @summary 删除Webhook
        
        @param request: DeleteAlertWebhookRequest
        @return: DeleteAlertWebhookResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_alert_webhook_with_options_async(request, headers, runtime)

    def delete_alert_webhooks_with_options(
        self,
        tmp_req: cms_20240330_models.DeleteAlertWebhooksRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAlertWebhooksResponse:
        """
        @summary 删除Webhook
        
        @param tmp_req: DeleteAlertWebhooksRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAlertWebhooksResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteAlertWebhooksShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.webhook_ids):
            request.webhook_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.webhook_ids, 'webhookIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.is_custom):
            query['isCustom'] = request.is_custom
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.webhook_ids_shrink):
            query['webhookIds'] = request.webhook_ids_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAlertWebhooks',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/webhooks',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertWebhooksResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertWebhooksResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_alert_webhooks_with_options_async(
        self,
        tmp_req: cms_20240330_models.DeleteAlertWebhooksRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteAlertWebhooksResponse:
        """
        @summary 删除Webhook
        
        @param tmp_req: DeleteAlertWebhooksRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteAlertWebhooksResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteAlertWebhooksShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.webhook_ids):
            request.webhook_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.webhook_ids, 'webhookIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.is_custom):
            query['isCustom'] = request.is_custom
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.webhook_ids_shrink):
            query['webhookIds'] = request.webhook_ids_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteAlertWebhooks',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/webhooks',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertWebhooksResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteAlertWebhooksResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_alert_webhooks(
        self,
        request: cms_20240330_models.DeleteAlertWebhooksRequest,
    ) -> cms_20240330_models.DeleteAlertWebhooksResponse:
        """
        @summary 删除Webhook
        
        @param request: DeleteAlertWebhooksRequest
        @return: DeleteAlertWebhooksResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_alert_webhooks_with_options(request, headers, runtime)

    async def delete_alert_webhooks_async(
        self,
        request: cms_20240330_models.DeleteAlertWebhooksRequest,
    ) -> cms_20240330_models.DeleteAlertWebhooksResponse:
        """
        @summary 删除Webhook
        
        @param request: DeleteAlertWebhooksRequest
        @return: DeleteAlertWebhooksResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_alert_webhooks_with_options_async(request, headers, runtime)

    def delete_biz_trace_with_options(
        self,
        biz_trace_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteBizTraceResponse:
        """
        @summary 删除业务链路
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteBizTraceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeleteBizTrace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/bizTrace/{OpenApiUtilClient.get_encode_param(biz_trace_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteBizTraceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteBizTraceResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_biz_trace_with_options_async(
        self,
        biz_trace_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteBizTraceResponse:
        """
        @summary 删除业务链路
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteBizTraceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeleteBizTrace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/bizTrace/{OpenApiUtilClient.get_encode_param(biz_trace_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteBizTraceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteBizTraceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_biz_trace(
        self,
        biz_trace_id: str,
    ) -> cms_20240330_models.DeleteBizTraceResponse:
        """
        @summary 删除业务链路
        
        @return: DeleteBizTraceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_biz_trace_with_options(biz_trace_id, headers, runtime)

    async def delete_biz_trace_async(
        self,
        biz_trace_id: str,
    ) -> cms_20240330_models.DeleteBizTraceResponse:
        """
        @summary 删除业务链路
        
        @return: DeleteBizTraceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_biz_trace_with_options_async(biz_trace_id, headers, runtime)

    def delete_cloud_resource_with_options(
        self,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteCloudResourceResponse:
        """
        @summary 删除云资源中心
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCloudResourceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeleteCloudResource',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/cloudresource',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteCloudResourceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteCloudResourceResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_cloud_resource_with_options_async(
        self,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteCloudResourceResponse:
        """
        @summary 删除云资源中心
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteCloudResourceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeleteCloudResource',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/cloudresource',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteCloudResourceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteCloudResourceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_cloud_resource(self) -> cms_20240330_models.DeleteCloudResourceResponse:
        """
        @summary 删除云资源中心
        
        @return: DeleteCloudResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_cloud_resource_with_options(headers, runtime)

    async def delete_cloud_resource_async(self) -> cms_20240330_models.DeleteCloudResourceResponse:
        """
        @summary 删除云资源中心
        
        @return: DeleteCloudResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_cloud_resource_with_options_async(headers, runtime)

    def delete_contact_with_options(
        self,
        tmp_req: cms_20240330_models.DeleteContactRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteContactResponse:
        """
        @summary 删除联系人
        
        @param tmp_req: DeleteContactRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteContactResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteContactShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.contact_ids):
            request.contact_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.contact_ids, 'contactIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.contact_ids_shrink):
            query['contactIds'] = request.contact_ids_shrink
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteContact',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contact',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteContactResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteContactResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_contact_with_options_async(
        self,
        tmp_req: cms_20240330_models.DeleteContactRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteContactResponse:
        """
        @summary 删除联系人
        
        @param tmp_req: DeleteContactRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteContactResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteContactShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.contact_ids):
            request.contact_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.contact_ids, 'contactIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.contact_ids_shrink):
            query['contactIds'] = request.contact_ids_shrink
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteContact',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contact',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteContactResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteContactResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_contact(
        self,
        request: cms_20240330_models.DeleteContactRequest,
    ) -> cms_20240330_models.DeleteContactResponse:
        """
        @summary 删除联系人
        
        @param request: DeleteContactRequest
        @return: DeleteContactResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_contact_with_options(request, headers, runtime)

    async def delete_contact_async(
        self,
        request: cms_20240330_models.DeleteContactRequest,
    ) -> cms_20240330_models.DeleteContactResponse:
        """
        @summary 删除联系人
        
        @param request: DeleteContactRequest
        @return: DeleteContactResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_contact_with_options_async(request, headers, runtime)

    def delete_contact_group_with_options(
        self,
        tmp_req: cms_20240330_models.DeleteContactGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteContactGroupResponse:
        """
        @summary 删除联系人组
        
        @param tmp_req: DeleteContactGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteContactGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteContactGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.contact_group_ids):
            request.contact_group_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.contact_group_ids, 'contactGroupIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.contact_group_ids_shrink):
            query['contactGroupIds'] = request.contact_group_ids_shrink
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteContactGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contactGroup',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteContactGroupResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteContactGroupResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_contact_group_with_options_async(
        self,
        tmp_req: cms_20240330_models.DeleteContactGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteContactGroupResponse:
        """
        @summary 删除联系人组
        
        @param tmp_req: DeleteContactGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteContactGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteContactGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.contact_group_ids):
            request.contact_group_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.contact_group_ids, 'contactGroupIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.contact_group_ids_shrink):
            query['contactGroupIds'] = request.contact_group_ids_shrink
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteContactGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contactGroup',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteContactGroupResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteContactGroupResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_contact_group(
        self,
        request: cms_20240330_models.DeleteContactGroupRequest,
    ) -> cms_20240330_models.DeleteContactGroupResponse:
        """
        @summary 删除联系人组
        
        @param request: DeleteContactGroupRequest
        @return: DeleteContactGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_contact_group_with_options(request, headers, runtime)

    async def delete_contact_group_async(
        self,
        request: cms_20240330_models.DeleteContactGroupRequest,
    ) -> cms_20240330_models.DeleteContactGroupResponse:
        """
        @summary 删除联系人组
        
        @param request: DeleteContactGroupRequest
        @return: DeleteContactGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_contact_group_with_options_async(request, headers, runtime)

    def delete_contact_groups_with_options(
        self,
        tmp_req: cms_20240330_models.DeleteContactGroupsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteContactGroupsResponse:
        """
        @summary 删除联系人组
        
        @param tmp_req: DeleteContactGroupsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteContactGroupsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteContactGroupsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.contact_group_ids):
            request.contact_group_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.contact_group_ids, 'contactGroupIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.contact_group_ids_shrink):
            query['contactGroupIds'] = request.contact_group_ids_shrink
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteContactGroups',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contactGroups',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteContactGroupsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteContactGroupsResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_contact_groups_with_options_async(
        self,
        tmp_req: cms_20240330_models.DeleteContactGroupsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteContactGroupsResponse:
        """
        @summary 删除联系人组
        
        @param tmp_req: DeleteContactGroupsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteContactGroupsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteContactGroupsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.contact_group_ids):
            request.contact_group_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.contact_group_ids, 'contactGroupIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.contact_group_ids_shrink):
            query['contactGroupIds'] = request.contact_group_ids_shrink
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteContactGroups',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contactGroups',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteContactGroupsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteContactGroupsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_contact_groups(
        self,
        request: cms_20240330_models.DeleteContactGroupsRequest,
    ) -> cms_20240330_models.DeleteContactGroupsResponse:
        """
        @summary 删除联系人组
        
        @param request: DeleteContactGroupsRequest
        @return: DeleteContactGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_contact_groups_with_options(request, headers, runtime)

    async def delete_contact_groups_async(
        self,
        request: cms_20240330_models.DeleteContactGroupsRequest,
    ) -> cms_20240330_models.DeleteContactGroupsResponse:
        """
        @summary 删除联系人组
        
        @param request: DeleteContactGroupsRequest
        @return: DeleteContactGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_contact_groups_with_options_async(request, headers, runtime)

    def delete_contacts_with_options(
        self,
        tmp_req: cms_20240330_models.DeleteContactsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteContactsResponse:
        """
        @summary 删除联系人
        
        @param tmp_req: DeleteContactsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteContactsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteContactsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.contact_ids):
            request.contact_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.contact_ids, 'contactIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.contact_ids_shrink):
            query['contactIds'] = request.contact_ids_shrink
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteContacts',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contacts',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteContactsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteContactsResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_contacts_with_options_async(
        self,
        tmp_req: cms_20240330_models.DeleteContactsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteContactsResponse:
        """
        @summary 删除联系人
        
        @param tmp_req: DeleteContactsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteContactsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteContactsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.contact_ids):
            request.contact_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.contact_ids, 'contactIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.contact_ids_shrink):
            query['contactIds'] = request.contact_ids_shrink
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteContacts',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contacts',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteContactsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteContactsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_contacts(
        self,
        request: cms_20240330_models.DeleteContactsRequest,
    ) -> cms_20240330_models.DeleteContactsResponse:
        """
        @summary 删除联系人
        
        @param request: DeleteContactsRequest
        @return: DeleteContactsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_contacts_with_options(request, headers, runtime)

    async def delete_contacts_async(
        self,
        request: cms_20240330_models.DeleteContactsRequest,
    ) -> cms_20240330_models.DeleteContactsResponse:
        """
        @summary 删除联系人
        
        @param request: DeleteContactsRequest
        @return: DeleteContactsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_contacts_with_options_async(request, headers, runtime)

    def delete_entity_group_with_options(
        self,
        entity_group_id: str,
        request: cms_20240330_models.DeleteEntityGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteEntityGroupResponse:
        """
        @summary 删除实体组
        
        @param request: DeleteEntityGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEntityGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteEntityGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/entity-groups/{OpenApiUtilClient.get_encode_param(entity_group_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteEntityGroupResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteEntityGroupResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_entity_group_with_options_async(
        self,
        entity_group_id: str,
        request: cms_20240330_models.DeleteEntityGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteEntityGroupResponse:
        """
        @summary 删除实体组
        
        @param request: DeleteEntityGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEntityGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteEntityGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/entity-groups/{OpenApiUtilClient.get_encode_param(entity_group_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteEntityGroupResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteEntityGroupResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_entity_group(
        self,
        entity_group_id: str,
        request: cms_20240330_models.DeleteEntityGroupRequest,
    ) -> cms_20240330_models.DeleteEntityGroupResponse:
        """
        @summary 删除实体组
        
        @param request: DeleteEntityGroupRequest
        @return: DeleteEntityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_entity_group_with_options(entity_group_id, request, headers, runtime)

    async def delete_entity_group_async(
        self,
        entity_group_id: str,
        request: cms_20240330_models.DeleteEntityGroupRequest,
    ) -> cms_20240330_models.DeleteEntityGroupResponse:
        """
        @summary 删除实体组
        
        @param request: DeleteEntityGroupRequest
        @return: DeleteEntityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_entity_group_with_options_async(entity_group_id, request, headers, runtime)

    def delete_entity_store_with_options(
        self,
        workspace_name: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteEntityStoreResponse:
        """
        @summary 删除EntityStore相关存储
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEntityStoreResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeleteEntityStore',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace_name)}/entitystore',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteEntityStoreResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteEntityStoreResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_entity_store_with_options_async(
        self,
        workspace_name: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteEntityStoreResponse:
        """
        @summary 删除EntityStore相关存储
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEntityStoreResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeleteEntityStore',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace_name)}/entitystore',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteEntityStoreResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteEntityStoreResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_entity_store(
        self,
        workspace_name: str,
    ) -> cms_20240330_models.DeleteEntityStoreResponse:
        """
        @summary 删除EntityStore相关存储
        
        @return: DeleteEntityStoreResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_entity_store_with_options(workspace_name, headers, runtime)

    async def delete_entity_store_async(
        self,
        workspace_name: str,
    ) -> cms_20240330_models.DeleteEntityStoreResponse:
        """
        @summary 删除EntityStore相关存储
        
        @return: DeleteEntityStoreResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_entity_store_with_options_async(workspace_name, headers, runtime)

    def delete_environment_with_options(
        self,
        environment_id: str,
        request: cms_20240330_models.DeleteEnvironmentRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteEnvironmentResponse:
        """
        @summary 删除环境实例
        
        @param request: DeleteEnvironmentRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEnvironmentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.delete_prom_instance):
            query['DeletePromInstance'] = request.delete_prom_instance
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteEnvironment',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/environment/rest/{OpenApiUtilClient.get_encode_param(environment_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteEnvironmentResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteEnvironmentResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_environment_with_options_async(
        self,
        environment_id: str,
        request: cms_20240330_models.DeleteEnvironmentRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteEnvironmentResponse:
        """
        @summary 删除环境实例
        
        @param request: DeleteEnvironmentRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEnvironmentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.delete_prom_instance):
            query['DeletePromInstance'] = request.delete_prom_instance
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteEnvironment',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/environment/rest/{OpenApiUtilClient.get_encode_param(environment_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteEnvironmentResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteEnvironmentResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_environment(
        self,
        environment_id: str,
        request: cms_20240330_models.DeleteEnvironmentRequest,
    ) -> cms_20240330_models.DeleteEnvironmentResponse:
        """
        @summary 删除环境实例
        
        @param request: DeleteEnvironmentRequest
        @return: DeleteEnvironmentResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_environment_with_options(environment_id, request, headers, runtime)

    async def delete_environment_async(
        self,
        environment_id: str,
        request: cms_20240330_models.DeleteEnvironmentRequest,
    ) -> cms_20240330_models.DeleteEnvironmentResponse:
        """
        @summary 删除环境实例
        
        @param request: DeleteEnvironmentRequest
        @return: DeleteEnvironmentResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_environment_with_options_async(environment_id, request, headers, runtime)

    def delete_environment_feature_with_options(
        self,
        environment_id: str,
        feature_name: str,
        request: cms_20240330_models.DeleteEnvironmentFeatureRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteEnvironmentFeatureResponse:
        """
        @summary 删除feature信息
        
        @param request: DeleteEnvironmentFeatureRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEnvironmentFeatureResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteEnvironmentFeature',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/feature/rest/{OpenApiUtilClient.get_encode_param(environment_id)}/{OpenApiUtilClient.get_encode_param(feature_name)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteEnvironmentFeatureResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteEnvironmentFeatureResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_environment_feature_with_options_async(
        self,
        environment_id: str,
        feature_name: str,
        request: cms_20240330_models.DeleteEnvironmentFeatureRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteEnvironmentFeatureResponse:
        """
        @summary 删除feature信息
        
        @param request: DeleteEnvironmentFeatureRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEnvironmentFeatureResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteEnvironmentFeature',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/feature/rest/{OpenApiUtilClient.get_encode_param(environment_id)}/{OpenApiUtilClient.get_encode_param(feature_name)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteEnvironmentFeatureResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteEnvironmentFeatureResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_environment_feature(
        self,
        environment_id: str,
        feature_name: str,
        request: cms_20240330_models.DeleteEnvironmentFeatureRequest,
    ) -> cms_20240330_models.DeleteEnvironmentFeatureResponse:
        """
        @summary 删除feature信息
        
        @param request: DeleteEnvironmentFeatureRequest
        @return: DeleteEnvironmentFeatureResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_environment_feature_with_options(environment_id, feature_name, request, headers, runtime)

    async def delete_environment_feature_async(
        self,
        environment_id: str,
        feature_name: str,
        request: cms_20240330_models.DeleteEnvironmentFeatureRequest,
    ) -> cms_20240330_models.DeleteEnvironmentFeatureResponse:
        """
        @summary 删除feature信息
        
        @param request: DeleteEnvironmentFeatureRequest
        @return: DeleteEnvironmentFeatureResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_environment_feature_with_options_async(environment_id, feature_name, request, headers, runtime)

    def delete_escalation_with_options(
        self,
        uuid: str,
        request: cms_20240330_models.DeleteEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteEscalationResponse:
        """
        @summary 删除通知配置
        
        @param request: DeleteEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/escalations/{OpenApiUtilClient.get_encode_param(uuid)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteEscalationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteEscalationResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_escalation_with_options_async(
        self,
        uuid: str,
        request: cms_20240330_models.DeleteEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteEscalationResponse:
        """
        @summary 删除通知配置
        
        @param request: DeleteEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/escalations/{OpenApiUtilClient.get_encode_param(uuid)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteEscalationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteEscalationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_escalation(
        self,
        uuid: str,
        request: cms_20240330_models.DeleteEscalationRequest,
    ) -> cms_20240330_models.DeleteEscalationResponse:
        """
        @summary 删除通知配置
        
        @param request: DeleteEscalationRequest
        @return: DeleteEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_escalation_with_options(uuid, request, headers, runtime)

    async def delete_escalation_async(
        self,
        uuid: str,
        request: cms_20240330_models.DeleteEscalationRequest,
    ) -> cms_20240330_models.DeleteEscalationResponse:
        """
        @summary 删除通知配置
        
        @param request: DeleteEscalationRequest
        @return: DeleteEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_escalation_with_options_async(uuid, request, headers, runtime)

    def delete_incident_escalation_with_options(
        self,
        request: cms_20240330_models.DeleteIncidentEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteIncidentEscalationResponse:
        """
        @summary 删除Incident升级计划
        
        @param request: DeleteIncidentEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIncidentEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_escalation_id):
            query['incidentEscalationId'] = request.incident_escalation_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIncidentEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/escalation/delete',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteIncidentEscalationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteIncidentEscalationResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_incident_escalation_with_options_async(
        self,
        request: cms_20240330_models.DeleteIncidentEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteIncidentEscalationResponse:
        """
        @summary 删除Incident升级计划
        
        @param request: DeleteIncidentEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIncidentEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_escalation_id):
            query['incidentEscalationId'] = request.incident_escalation_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIncidentEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/escalation/delete',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteIncidentEscalationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteIncidentEscalationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_incident_escalation(
        self,
        request: cms_20240330_models.DeleteIncidentEscalationRequest,
    ) -> cms_20240330_models.DeleteIncidentEscalationResponse:
        """
        @summary 删除Incident升级计划
        
        @param request: DeleteIncidentEscalationRequest
        @return: DeleteIncidentEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_incident_escalation_with_options(request, headers, runtime)

    async def delete_incident_escalation_async(
        self,
        request: cms_20240330_models.DeleteIncidentEscalationRequest,
    ) -> cms_20240330_models.DeleteIncidentEscalationResponse:
        """
        @summary 删除Incident升级计划
        
        @param request: DeleteIncidentEscalationRequest
        @return: DeleteIncidentEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_incident_escalation_with_options_async(request, headers, runtime)

    def delete_incident_plan_with_options(
        self,
        request: cms_20240330_models.DeleteIncidentPlanRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteIncidentPlanResponse:
        """
        @summary 删除Incident 计划
        
        @param request: DeleteIncidentPlanRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIncidentPlanResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_plan_id):
            query['incidentPlanId'] = request.incident_plan_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIncidentPlan',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/plan/delete',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteIncidentPlanResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteIncidentPlanResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_incident_plan_with_options_async(
        self,
        request: cms_20240330_models.DeleteIncidentPlanRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteIncidentPlanResponse:
        """
        @summary 删除Incident 计划
        
        @param request: DeleteIncidentPlanRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIncidentPlanResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_plan_id):
            query['incidentPlanId'] = request.incident_plan_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIncidentPlan',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/plan/delete',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteIncidentPlanResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteIncidentPlanResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_incident_plan(
        self,
        request: cms_20240330_models.DeleteIncidentPlanRequest,
    ) -> cms_20240330_models.DeleteIncidentPlanResponse:
        """
        @summary 删除Incident 计划
        
        @param request: DeleteIncidentPlanRequest
        @return: DeleteIncidentPlanResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_incident_plan_with_options(request, headers, runtime)

    async def delete_incident_plan_async(
        self,
        request: cms_20240330_models.DeleteIncidentPlanRequest,
    ) -> cms_20240330_models.DeleteIncidentPlanResponse:
        """
        @summary 删除Incident 计划
        
        @param request: DeleteIncidentPlanRequest
        @return: DeleteIncidentPlanResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_incident_plan_with_options_async(request, headers, runtime)

    def delete_integration_with_options(
        self,
        integration_id: str,
        request: cms_20240330_models.DeleteIntegrationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteIntegrationResponse:
        """
        @summary 删除集成
        
        @param request: DeleteIntegrationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIntegrationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIntegration',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integrations/{OpenApiUtilClient.get_encode_param(integration_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteIntegrationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteIntegrationResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_integration_with_options_async(
        self,
        integration_id: str,
        request: cms_20240330_models.DeleteIntegrationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteIntegrationResponse:
        """
        @summary 删除集成
        
        @param request: DeleteIntegrationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIntegrationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIntegration',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integrations/{OpenApiUtilClient.get_encode_param(integration_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteIntegrationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteIntegrationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_integration(
        self,
        integration_id: str,
        request: cms_20240330_models.DeleteIntegrationRequest,
    ) -> cms_20240330_models.DeleteIntegrationResponse:
        """
        @summary 删除集成
        
        @param request: DeleteIntegrationRequest
        @return: DeleteIntegrationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_integration_with_options(integration_id, request, headers, runtime)

    async def delete_integration_async(
        self,
        integration_id: str,
        request: cms_20240330_models.DeleteIntegrationRequest,
    ) -> cms_20240330_models.DeleteIntegrationResponse:
        """
        @summary 删除集成
        
        @param request: DeleteIntegrationRequest
        @return: DeleteIntegrationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_integration_with_options_async(integration_id, request, headers, runtime)

    def delete_integration_policy_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.DeleteIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteIntegrationPolicyResponse:
        """
        @summary 删除接入中心策略
        
        @param request: DeleteIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force):
            query['force'] = request.force
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteIntegrationPolicyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteIntegrationPolicyResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_integration_policy_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.DeleteIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteIntegrationPolicyResponse:
        """
        @summary 删除接入中心策略
        
        @param request: DeleteIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force):
            query['force'] = request.force
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteIntegrationPolicyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteIntegrationPolicyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_integration_policy(
        self,
        policy_id: str,
        request: cms_20240330_models.DeleteIntegrationPolicyRequest,
    ) -> cms_20240330_models.DeleteIntegrationPolicyResponse:
        """
        @summary 删除接入中心策略
        
        @param request: DeleteIntegrationPolicyRequest
        @return: DeleteIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_integration_policy_with_options(policy_id, request, headers, runtime)

    async def delete_integration_policy_async(
        self,
        policy_id: str,
        request: cms_20240330_models.DeleteIntegrationPolicyRequest,
    ) -> cms_20240330_models.DeleteIntegrationPolicyResponse:
        """
        @summary 删除接入中心策略
        
        @param request: DeleteIntegrationPolicyRequest
        @return: DeleteIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_integration_policy_with_options_async(policy_id, request, headers, runtime)

    def delete_maintain_window_with_options(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.DeleteMaintainWindowRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteMaintainWindowResponse:
        """
        @summary 删除转换器
        
        @param request: DeleteMaintainWindowRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMaintainWindowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMaintainWindow',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/maintainWindows/{OpenApiUtilClient.get_encode_param(maintain_window_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteMaintainWindowResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteMaintainWindowResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_maintain_window_with_options_async(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.DeleteMaintainWindowRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteMaintainWindowResponse:
        """
        @summary 删除转换器
        
        @param request: DeleteMaintainWindowRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteMaintainWindowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteMaintainWindow',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/maintainWindows/{OpenApiUtilClient.get_encode_param(maintain_window_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteMaintainWindowResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteMaintainWindowResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_maintain_window(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.DeleteMaintainWindowRequest,
    ) -> cms_20240330_models.DeleteMaintainWindowResponse:
        """
        @summary 删除转换器
        
        @param request: DeleteMaintainWindowRequest
        @return: DeleteMaintainWindowResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_maintain_window_with_options(maintain_window_id, request, headers, runtime)

    async def delete_maintain_window_async(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.DeleteMaintainWindowRequest,
    ) -> cms_20240330_models.DeleteMaintainWindowResponse:
        """
        @summary 删除转换器
        
        @param request: DeleteMaintainWindowRequest
        @return: DeleteMaintainWindowResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_maintain_window_with_options_async(maintain_window_id, request, headers, runtime)

    def delete_notify_strategy_with_options(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.DeleteNotifyStrategyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteNotifyStrategyResponse:
        """
        @summary 删除订阅
        
        @param request: DeleteNotifyStrategyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteNotifyStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteNotifyStrategy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/notifyStrategies/{OpenApiUtilClient.get_encode_param(notify_strategy_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteNotifyStrategyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteNotifyStrategyResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_notify_strategy_with_options_async(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.DeleteNotifyStrategyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteNotifyStrategyResponse:
        """
        @summary 删除订阅
        
        @param request: DeleteNotifyStrategyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteNotifyStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteNotifyStrategy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/notifyStrategies/{OpenApiUtilClient.get_encode_param(notify_strategy_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteNotifyStrategyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteNotifyStrategyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_notify_strategy(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.DeleteNotifyStrategyRequest,
    ) -> cms_20240330_models.DeleteNotifyStrategyResponse:
        """
        @summary 删除订阅
        
        @param request: DeleteNotifyStrategyRequest
        @return: DeleteNotifyStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_notify_strategy_with_options(notify_strategy_id, request, headers, runtime)

    async def delete_notify_strategy_async(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.DeleteNotifyStrategyRequest,
    ) -> cms_20240330_models.DeleteNotifyStrategyResponse:
        """
        @summary 删除订阅
        
        @param request: DeleteNotifyStrategyRequest
        @return: DeleteNotifyStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_notify_strategy_with_options_async(notify_strategy_id, request, headers, runtime)

    def delete_oncall_schedules_with_options(
        self,
        tmp_req: cms_20240330_models.DeleteOncallSchedulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteOncallSchedulesResponse:
        """
        @summary 删除OncallSchedule
        
        @param tmp_req: DeleteOncallSchedulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteOncallSchedulesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteOncallSchedulesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.oncall_schedule_ids):
            request.oncall_schedule_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.oncall_schedule_ids, 'oncallScheduleIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.oncall_schedule_ids_shrink):
            query['oncallScheduleIds'] = request.oncall_schedule_ids_shrink
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteOncallSchedules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/oncallSchedule',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteOncallSchedulesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteOncallSchedulesResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_oncall_schedules_with_options_async(
        self,
        tmp_req: cms_20240330_models.DeleteOncallSchedulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteOncallSchedulesResponse:
        """
        @summary 删除OncallSchedule
        
        @param tmp_req: DeleteOncallSchedulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteOncallSchedulesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DeleteOncallSchedulesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.oncall_schedule_ids):
            request.oncall_schedule_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.oncall_schedule_ids, 'oncallScheduleIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.oncall_schedule_ids_shrink):
            query['oncallScheduleIds'] = request.oncall_schedule_ids_shrink
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteOncallSchedules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/oncallSchedule',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteOncallSchedulesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteOncallSchedulesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_oncall_schedules(
        self,
        request: cms_20240330_models.DeleteOncallSchedulesRequest,
    ) -> cms_20240330_models.DeleteOncallSchedulesResponse:
        """
        @summary 删除OncallSchedule
        
        @param request: DeleteOncallSchedulesRequest
        @return: DeleteOncallSchedulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_oncall_schedules_with_options(request, headers, runtime)

    async def delete_oncall_schedules_async(
        self,
        request: cms_20240330_models.DeleteOncallSchedulesRequest,
    ) -> cms_20240330_models.DeleteOncallSchedulesResponse:
        """
        @summary 删除OncallSchedule
        
        @param request: DeleteOncallSchedulesRequest
        @return: DeleteOncallSchedulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_oncall_schedules_with_options_async(request, headers, runtime)

    def delete_policy_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.DeletePolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeletePolicyResponse:
        """
        @summary 删除接入中心策略
        
        @param request: DeletePolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force):
            query['force'] = request.force
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy/{OpenApiUtilClient.get_encode_param(policy_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeletePolicyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeletePolicyResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_policy_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.DeletePolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeletePolicyResponse:
        """
        @summary 删除接入中心策略
        
        @param request: DeletePolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.force):
            query['force'] = request.force
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeletePolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy/{OpenApiUtilClient.get_encode_param(policy_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeletePolicyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeletePolicyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_policy(
        self,
        policy_id: str,
        request: cms_20240330_models.DeletePolicyRequest,
    ) -> cms_20240330_models.DeletePolicyResponse:
        """
        @summary 删除接入中心策略
        
        @param request: DeletePolicyRequest
        @return: DeletePolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_policy_with_options(policy_id, request, headers, runtime)

    async def delete_policy_async(
        self,
        policy_id: str,
        request: cms_20240330_models.DeletePolicyRequest,
    ) -> cms_20240330_models.DeletePolicyResponse:
        """
        @summary 删除接入中心策略
        
        @param request: DeletePolicyRequest
        @return: DeletePolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_policy_with_options_async(policy_id, request, headers, runtime)

    def delete_prometheus_instance_with_options(
        self,
        prometheus_instance_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeletePrometheusInstanceResponse:
        """
        @summary 删除prom实例
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePrometheusInstanceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeletePrometheusInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(prometheus_instance_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeletePrometheusInstanceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeletePrometheusInstanceResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_prometheus_instance_with_options_async(
        self,
        prometheus_instance_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeletePrometheusInstanceResponse:
        """
        @summary 删除prom实例
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePrometheusInstanceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeletePrometheusInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(prometheus_instance_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeletePrometheusInstanceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeletePrometheusInstanceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_prometheus_instance(
        self,
        prometheus_instance_id: str,
    ) -> cms_20240330_models.DeletePrometheusInstanceResponse:
        """
        @summary 删除prom实例
        
        @return: DeletePrometheusInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_prometheus_instance_with_options(prometheus_instance_id, headers, runtime)

    async def delete_prometheus_instance_async(
        self,
        prometheus_instance_id: str,
    ) -> cms_20240330_models.DeletePrometheusInstanceResponse:
        """
        @summary 删除prom实例
        
        @return: DeletePrometheusInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_prometheus_instance_with_options_async(prometheus_instance_id, headers, runtime)

    def delete_prometheus_view_with_options(
        self,
        prometheus_view_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeletePrometheusViewResponse:
        """
        @summary 删除prometheus视图实例
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePrometheusViewResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeletePrometheusView',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-views/{OpenApiUtilClient.get_encode_param(prometheus_view_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeletePrometheusViewResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeletePrometheusViewResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_prometheus_view_with_options_async(
        self,
        prometheus_view_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeletePrometheusViewResponse:
        """
        @summary 删除prometheus视图实例
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeletePrometheusViewResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeletePrometheusView',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-views/{OpenApiUtilClient.get_encode_param(prometheus_view_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeletePrometheusViewResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeletePrometheusViewResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_prometheus_view(
        self,
        prometheus_view_id: str,
    ) -> cms_20240330_models.DeletePrometheusViewResponse:
        """
        @summary 删除prometheus视图实例
        
        @return: DeletePrometheusViewResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_prometheus_view_with_options(prometheus_view_id, headers, runtime)

    async def delete_prometheus_view_async(
        self,
        prometheus_view_id: str,
    ) -> cms_20240330_models.DeletePrometheusViewResponse:
        """
        @summary 删除prometheus视图实例
        
        @return: DeletePrometheusViewResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_prometheus_view_with_options_async(prometheus_view_id, headers, runtime)

    def delete_rum_instance_with_options(
        self,
        rum_instance_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteRumInstanceResponse:
        """
        @summary 删除RUM实例
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRumInstanceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeleteRumInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/rum-instances/{OpenApiUtilClient.get_encode_param(rum_instance_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteRumInstanceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteRumInstanceResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_rum_instance_with_options_async(
        self,
        rum_instance_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteRumInstanceResponse:
        """
        @summary 删除RUM实例
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteRumInstanceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeleteRumInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/rum-instances/{OpenApiUtilClient.get_encode_param(rum_instance_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteRumInstanceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteRumInstanceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_rum_instance(
        self,
        rum_instance_id: str,
    ) -> cms_20240330_models.DeleteRumInstanceResponse:
        """
        @summary 删除RUM实例
        
        @return: DeleteRumInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_rum_instance_with_options(rum_instance_id, headers, runtime)

    async def delete_rum_instance_async(
        self,
        rum_instance_id: str,
    ) -> cms_20240330_models.DeleteRumInstanceResponse:
        """
        @summary 删除RUM实例
        
        @return: DeleteRumInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_rum_instance_with_options_async(rum_instance_id, headers, runtime)

    def delete_site_monitor_with_options(
        self,
        request: cms_20240330_models.DeleteSiteMonitorRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteSiteMonitorResponse:
        """
        @summary 删除SiteMonitor
        
        @param request: DeleteSiteMonitorRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSiteMonitorResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.site_monitor_id):
            query['siteMonitorId'] = request.site_monitor_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSiteMonitor',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/sitemonitor',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteSiteMonitorResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteSiteMonitorResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_site_monitor_with_options_async(
        self,
        request: cms_20240330_models.DeleteSiteMonitorRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteSiteMonitorResponse:
        """
        @summary 删除SiteMonitor
        
        @param request: DeleteSiteMonitorRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSiteMonitorResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.site_monitor_id):
            query['siteMonitorId'] = request.site_monitor_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSiteMonitor',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/sitemonitor',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteSiteMonitorResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteSiteMonitorResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_site_monitor(
        self,
        request: cms_20240330_models.DeleteSiteMonitorRequest,
    ) -> cms_20240330_models.DeleteSiteMonitorResponse:
        """
        @summary 删除SiteMonitor
        
        @param request: DeleteSiteMonitorRequest
        @return: DeleteSiteMonitorResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_site_monitor_with_options(request, headers, runtime)

    async def delete_site_monitor_async(
        self,
        request: cms_20240330_models.DeleteSiteMonitorRequest,
    ) -> cms_20240330_models.DeleteSiteMonitorResponse:
        """
        @summary 删除SiteMonitor
        
        @param request: DeleteSiteMonitorRequest
        @return: DeleteSiteMonitorResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_site_monitor_with_options_async(request, headers, runtime)

    def delete_subscription_with_options(
        self,
        subscription_id: str,
        request: cms_20240330_models.DeleteSubscriptionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteSubscriptionResponse:
        """
        @summary 删除订阅
        
        @param request: DeleteSubscriptionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSubscriptionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSubscription',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/subscriptions/{OpenApiUtilClient.get_encode_param(subscription_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteSubscriptionResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteSubscriptionResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_subscription_with_options_async(
        self,
        subscription_id: str,
        request: cms_20240330_models.DeleteSubscriptionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteSubscriptionResponse:
        """
        @summary 删除订阅
        
        @param request: DeleteSubscriptionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteSubscriptionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteSubscription',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/subscriptions/{OpenApiUtilClient.get_encode_param(subscription_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteSubscriptionResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteSubscriptionResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_subscription(
        self,
        subscription_id: str,
        request: cms_20240330_models.DeleteSubscriptionRequest,
    ) -> cms_20240330_models.DeleteSubscriptionResponse:
        """
        @summary 删除订阅
        
        @param request: DeleteSubscriptionRequest
        @return: DeleteSubscriptionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_subscription_with_options(subscription_id, request, headers, runtime)

    async def delete_subscription_async(
        self,
        subscription_id: str,
        request: cms_20240330_models.DeleteSubscriptionRequest,
    ) -> cms_20240330_models.DeleteSubscriptionResponse:
        """
        @summary 删除订阅
        
        @param request: DeleteSubscriptionRequest
        @return: DeleteSubscriptionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_subscription_with_options_async(subscription_id, request, headers, runtime)

    def delete_transformer_with_options(
        self,
        transformer_id: str,
        request: cms_20240330_models.DeleteTransformerRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteTransformerResponse:
        """
        @summary 删除转换器
        
        @param request: DeleteTransformerRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTransformerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTransformer',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/transformers/{OpenApiUtilClient.get_encode_param(transformer_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteTransformerResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteTransformerResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_transformer_with_options_async(
        self,
        transformer_id: str,
        request: cms_20240330_models.DeleteTransformerRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteTransformerResponse:
        """
        @summary 删除转换器
        
        @param request: DeleteTransformerRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteTransformerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteTransformer',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/transformers/{OpenApiUtilClient.get_encode_param(transformer_id)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteTransformerResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteTransformerResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_transformer(
        self,
        transformer_id: str,
        request: cms_20240330_models.DeleteTransformerRequest,
    ) -> cms_20240330_models.DeleteTransformerResponse:
        """
        @summary 删除转换器
        
        @param request: DeleteTransformerRequest
        @return: DeleteTransformerResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_transformer_with_options(transformer_id, request, headers, runtime)

    async def delete_transformer_async(
        self,
        transformer_id: str,
        request: cms_20240330_models.DeleteTransformerRequest,
    ) -> cms_20240330_models.DeleteTransformerResponse:
        """
        @summary 删除转换器
        
        @param request: DeleteTransformerRequest
        @return: DeleteTransformerResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_transformer_with_options_async(transformer_id, request, headers, runtime)

    def delete_umodel_with_options(
        self,
        workspace: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteUmodelResponse:
        """
        @summary 删除Umodel配置信息
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteUmodelResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeleteUmodel',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteUmodelResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteUmodelResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_umodel_with_options_async(
        self,
        workspace: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteUmodelResponse:
        """
        @summary 删除Umodel配置信息
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteUmodelResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeleteUmodel',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteUmodelResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteUmodelResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_umodel(
        self,
        workspace: str,
    ) -> cms_20240330_models.DeleteUmodelResponse:
        """
        @summary 删除Umodel配置信息
        
        @return: DeleteUmodelResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_umodel_with_options(workspace, headers, runtime)

    async def delete_umodel_async(
        self,
        workspace: str,
    ) -> cms_20240330_models.DeleteUmodelResponse:
        """
        @summary 删除Umodel配置信息
        
        @return: DeleteUmodelResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_umodel_with_options_async(workspace, headers, runtime)

    def delete_umodel_data_with_options(
        self,
        workspace: str,
        request: cms_20240330_models.DeleteUmodelDataRequest,
        headers: cms_20240330_models.DeleteUmodelDataHeaders,
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteUmodelDataResponse:
        """
        @summary 删除 Umodel Elements
        
        @param request: DeleteUmodelDataRequest
        @param headers: DeleteUmodelDataHeaders
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteUmodelDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain):
            query['domain'] = request.domain
        if not UtilClient.is_unset(request.kind):
            query['kind'] = request.kind
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        real_headers = {}
        if not UtilClient.is_unset(headers.common_headers):
            real_headers = headers.common_headers
        if not UtilClient.is_unset(headers.x_logapiversion):
            real_headers['X-LOG-APIVERSION'] = UtilClient.to_jsonstring(headers.x_logapiversion)
        req = open_api_models.OpenApiRequest(
            headers=real_headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteUmodelData',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel/data',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteUmodelDataResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteUmodelDataResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_umodel_data_with_options_async(
        self,
        workspace: str,
        request: cms_20240330_models.DeleteUmodelDataRequest,
        headers: cms_20240330_models.DeleteUmodelDataHeaders,
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteUmodelDataResponse:
        """
        @summary 删除 Umodel Elements
        
        @param request: DeleteUmodelDataRequest
        @param headers: DeleteUmodelDataHeaders
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteUmodelDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain):
            query['domain'] = request.domain
        if not UtilClient.is_unset(request.kind):
            query['kind'] = request.kind
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        real_headers = {}
        if not UtilClient.is_unset(headers.common_headers):
            real_headers = headers.common_headers
        if not UtilClient.is_unset(headers.x_logapiversion):
            real_headers['X-LOG-APIVERSION'] = UtilClient.to_jsonstring(headers.x_logapiversion)
        req = open_api_models.OpenApiRequest(
            headers=real_headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteUmodelData',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel/data',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteUmodelDataResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteUmodelDataResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_umodel_data(
        self,
        workspace: str,
        request: cms_20240330_models.DeleteUmodelDataRequest,
    ) -> cms_20240330_models.DeleteUmodelDataResponse:
        """
        @summary 删除 Umodel Elements
        
        @param request: DeleteUmodelDataRequest
        @return: DeleteUmodelDataResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = cms_20240330_models.DeleteUmodelDataHeaders()
        return self.delete_umodel_data_with_options(workspace, request, headers, runtime)

    async def delete_umodel_data_async(
        self,
        workspace: str,
        request: cms_20240330_models.DeleteUmodelDataRequest,
    ) -> cms_20240330_models.DeleteUmodelDataResponse:
        """
        @summary 删除 Umodel Elements
        
        @param request: DeleteUmodelDataRequest
        @return: DeleteUmodelDataResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = cms_20240330_models.DeleteUmodelDataHeaders()
        return await self.delete_umodel_data_with_options_async(workspace, request, headers, runtime)

    def delete_umodel_data_test_with_options(
        self,
        workspace: str,
        request: cms_20240330_models.DeleteUmodelDataTestRequest,
        headers: cms_20240330_models.DeleteUmodelDataTestHeaders,
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteUmodelDataTestResponse:
        """
        @summary 删除 Umodel Elements
        
        @param request: DeleteUmodelDataTestRequest
        @param headers: DeleteUmodelDataTestHeaders
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteUmodelDataTestResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain):
            query['domain'] = request.domain
        if not UtilClient.is_unset(request.kind):
            query['kind'] = request.kind
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        real_headers = {}
        if not UtilClient.is_unset(headers.common_headers):
            real_headers = headers.common_headers
        if not UtilClient.is_unset(headers.x_logapiversion):
            real_headers['X-LOG-APIVERSION'] = UtilClient.to_jsonstring(headers.x_logapiversion)
        req = open_api_models.OpenApiRequest(
            headers=real_headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteUmodelDataTest',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel/datat',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteUmodelDataTestResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteUmodelDataTestResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_umodel_data_test_with_options_async(
        self,
        workspace: str,
        request: cms_20240330_models.DeleteUmodelDataTestRequest,
        headers: cms_20240330_models.DeleteUmodelDataTestHeaders,
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteUmodelDataTestResponse:
        """
        @summary 删除 Umodel Elements
        
        @param request: DeleteUmodelDataTestRequest
        @param headers: DeleteUmodelDataTestHeaders
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteUmodelDataTestResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.domain):
            query['domain'] = request.domain
        if not UtilClient.is_unset(request.kind):
            query['kind'] = request.kind
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        real_headers = {}
        if not UtilClient.is_unset(headers.common_headers):
            real_headers = headers.common_headers
        if not UtilClient.is_unset(headers.x_logapiversion):
            real_headers['X-LOG-APIVERSION'] = UtilClient.to_jsonstring(headers.x_logapiversion)
        req = open_api_models.OpenApiRequest(
            headers=real_headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DeleteUmodelDataTest',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel/datat',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteUmodelDataTestResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteUmodelDataTestResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_umodel_data_test(
        self,
        workspace: str,
        request: cms_20240330_models.DeleteUmodelDataTestRequest,
    ) -> cms_20240330_models.DeleteUmodelDataTestResponse:
        """
        @summary 删除 Umodel Elements
        
        @param request: DeleteUmodelDataTestRequest
        @return: DeleteUmodelDataTestResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = cms_20240330_models.DeleteUmodelDataTestHeaders()
        return self.delete_umodel_data_test_with_options(workspace, request, headers, runtime)

    async def delete_umodel_data_test_async(
        self,
        workspace: str,
        request: cms_20240330_models.DeleteUmodelDataTestRequest,
    ) -> cms_20240330_models.DeleteUmodelDataTestResponse:
        """
        @summary 删除 Umodel Elements
        
        @param request: DeleteUmodelDataTestRequest
        @return: DeleteUmodelDataTestResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = cms_20240330_models.DeleteUmodelDataTestHeaders()
        return await self.delete_umodel_data_test_with_options_async(workspace, request, headers, runtime)

    def delete_workspace_with_options(
        self,
        workspace_name: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteWorkspaceResponse:
        """
        @summary 删除工作空间
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteWorkspaceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeleteWorkspace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace_name)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteWorkspaceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteWorkspaceResponse(),
                self.execute(params, req, runtime)
            )

    async def delete_workspace_with_options_async(
        self,
        workspace_name: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DeleteWorkspaceResponse:
        """
        @summary 删除工作空间
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DeleteWorkspaceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DeleteWorkspace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace_name)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DeleteWorkspaceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DeleteWorkspaceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def delete_workspace(
        self,
        workspace_name: str,
    ) -> cms_20240330_models.DeleteWorkspaceResponse:
        """
        @summary 删除工作空间
        
        @return: DeleteWorkspaceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.delete_workspace_with_options(workspace_name, headers, runtime)

    async def delete_workspace_async(
        self,
        workspace_name: str,
    ) -> cms_20240330_models.DeleteWorkspaceResponse:
        """
        @summary 删除工作空间
        
        @return: DeleteWorkspaceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.delete_workspace_with_options_async(workspace_name, headers, runtime)

    def describe_addon_with_options(
        self,
        addon_name: str,
        request: cms_20240330_models.DescribeAddonRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeAddonResponse:
        """
        @summary 插件详情(Addon)
        
        @param request: DescribeAddonRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAddonResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAddon',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addons/{OpenApiUtilClient.get_encode_param(addon_name)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_addon_with_options_async(
        self,
        addon_name: str,
        request: cms_20240330_models.DescribeAddonRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeAddonResponse:
        """
        @summary 插件详情(Addon)
        
        @param request: DescribeAddonRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAddonResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAddon',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addons/{OpenApiUtilClient.get_encode_param(addon_name)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_addon(
        self,
        addon_name: str,
        request: cms_20240330_models.DescribeAddonRequest,
    ) -> cms_20240330_models.DescribeAddonResponse:
        """
        @summary 插件详情(Addon)
        
        @param request: DescribeAddonRequest
        @return: DescribeAddonResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_addon_with_options(addon_name, request, headers, runtime)

    async def describe_addon_async(
        self,
        addon_name: str,
        request: cms_20240330_models.DescribeAddonRequest,
    ) -> cms_20240330_models.DescribeAddonResponse:
        """
        @summary 插件详情(Addon)
        
        @param request: DescribeAddonRequest
        @return: DescribeAddonResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_addon_with_options_async(addon_name, request, headers, runtime)

    def describe_addon_alert_rules_with_options(
        self,
        addon_name: str,
        request: cms_20240330_models.DescribeAddonAlertRulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeAddonAlertRulesResponse:
        """
        @summary 插件metrics详情(Addon)
        
        @param request: DescribeAddonAlertRulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAddonAlertRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_version):
            query['addonVersion'] = request.addon_version
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_type):
            query['environmentType'] = request.environment_type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAddonAlertRules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addons/{OpenApiUtilClient.get_encode_param(addon_name)}/alert-templates',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonAlertRulesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonAlertRulesResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_addon_alert_rules_with_options_async(
        self,
        addon_name: str,
        request: cms_20240330_models.DescribeAddonAlertRulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeAddonAlertRulesResponse:
        """
        @summary 插件metrics详情(Addon)
        
        @param request: DescribeAddonAlertRulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAddonAlertRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_version):
            query['addonVersion'] = request.addon_version
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_type):
            query['environmentType'] = request.environment_type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAddonAlertRules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addons/{OpenApiUtilClient.get_encode_param(addon_name)}/alert-templates',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonAlertRulesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonAlertRulesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_addon_alert_rules(
        self,
        addon_name: str,
        request: cms_20240330_models.DescribeAddonAlertRulesRequest,
    ) -> cms_20240330_models.DescribeAddonAlertRulesResponse:
        """
        @summary 插件metrics详情(Addon)
        
        @param request: DescribeAddonAlertRulesRequest
        @return: DescribeAddonAlertRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_addon_alert_rules_with_options(addon_name, request, headers, runtime)

    async def describe_addon_alert_rules_async(
        self,
        addon_name: str,
        request: cms_20240330_models.DescribeAddonAlertRulesRequest,
    ) -> cms_20240330_models.DescribeAddonAlertRulesResponse:
        """
        @summary 插件metrics详情(Addon)
        
        @param request: DescribeAddonAlertRulesRequest
        @return: DescribeAddonAlertRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_addon_alert_rules_with_options_async(addon_name, request, headers, runtime)

    def describe_addon_codes_with_options(
        self,
        name: str,
        request: cms_20240330_models.DescribeAddonCodesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeAddonCodesResponse:
        """
        @summary 插件schema详情(Addon)
        
        @param request: DescribeAddonCodesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAddonCodesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_type):
            query['environmentType'] = request.environment_type
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAddonCodes',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addon/{OpenApiUtilClient.get_encode_param(name)}/codes',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonCodesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonCodesResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_addon_codes_with_options_async(
        self,
        name: str,
        request: cms_20240330_models.DescribeAddonCodesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeAddonCodesResponse:
        """
        @summary 插件schema详情(Addon)
        
        @param request: DescribeAddonCodesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAddonCodesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_type):
            query['environmentType'] = request.environment_type
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAddonCodes',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addon/{OpenApiUtilClient.get_encode_param(name)}/codes',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonCodesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonCodesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_addon_codes(
        self,
        name: str,
        request: cms_20240330_models.DescribeAddonCodesRequest,
    ) -> cms_20240330_models.DescribeAddonCodesResponse:
        """
        @summary 插件schema详情(Addon)
        
        @param request: DescribeAddonCodesRequest
        @return: DescribeAddonCodesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_addon_codes_with_options(name, request, headers, runtime)

    async def describe_addon_codes_async(
        self,
        name: str,
        request: cms_20240330_models.DescribeAddonCodesRequest,
    ) -> cms_20240330_models.DescribeAddonCodesResponse:
        """
        @summary 插件schema详情(Addon)
        
        @param request: DescribeAddonCodesRequest
        @return: DescribeAddonCodesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_addon_codes_with_options_async(name, request, headers, runtime)

    def describe_addon_metrics_with_options(
        self,
        name: str,
        request: cms_20240330_models.DescribeAddonMetricsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeAddonMetricsResponse:
        """
        @summary 插件metrics详情(Addon)
        
        @param request: DescribeAddonMetricsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAddonMetricsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_type):
            query['environmentType'] = request.environment_type
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAddonMetrics',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addon/{OpenApiUtilClient.get_encode_param(name)}/metrics',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonMetricsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonMetricsResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_addon_metrics_with_options_async(
        self,
        name: str,
        request: cms_20240330_models.DescribeAddonMetricsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeAddonMetricsResponse:
        """
        @summary 插件metrics详情(Addon)
        
        @param request: DescribeAddonMetricsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAddonMetricsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_type):
            query['environmentType'] = request.environment_type
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAddonMetrics',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addon/{OpenApiUtilClient.get_encode_param(name)}/metrics',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonMetricsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonMetricsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_addon_metrics(
        self,
        name: str,
        request: cms_20240330_models.DescribeAddonMetricsRequest,
    ) -> cms_20240330_models.DescribeAddonMetricsResponse:
        """
        @summary 插件metrics详情(Addon)
        
        @param request: DescribeAddonMetricsRequest
        @return: DescribeAddonMetricsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_addon_metrics_with_options(name, request, headers, runtime)

    async def describe_addon_metrics_async(
        self,
        name: str,
        request: cms_20240330_models.DescribeAddonMetricsRequest,
    ) -> cms_20240330_models.DescribeAddonMetricsResponse:
        """
        @summary 插件metrics详情(Addon)
        
        @param request: DescribeAddonMetricsRequest
        @return: DescribeAddonMetricsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_addon_metrics_with_options_async(name, request, headers, runtime)

    def describe_addon_release_with_options(
        self,
        release_name: str,
        policy_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeAddonReleaseResponse:
        """
        @summary 查看addon release(查看接入状态)
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAddonReleaseResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DescribeAddonRelease',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy/{OpenApiUtilClient.get_encode_param(policy_id)}/addonrelease/{OpenApiUtilClient.get_encode_param(release_name)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonReleaseResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonReleaseResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_addon_release_with_options_async(
        self,
        release_name: str,
        policy_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeAddonReleaseResponse:
        """
        @summary 查看addon release(查看接入状态)
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAddonReleaseResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='DescribeAddonRelease',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy/{OpenApiUtilClient.get_encode_param(policy_id)}/addonrelease/{OpenApiUtilClient.get_encode_param(release_name)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonReleaseResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonReleaseResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_addon_release(
        self,
        release_name: str,
        policy_id: str,
    ) -> cms_20240330_models.DescribeAddonReleaseResponse:
        """
        @summary 查看addon release(查看接入状态)
        
        @return: DescribeAddonReleaseResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_addon_release_with_options(release_name, policy_id, headers, runtime)

    async def describe_addon_release_async(
        self,
        release_name: str,
        policy_id: str,
    ) -> cms_20240330_models.DescribeAddonReleaseResponse:
        """
        @summary 查看addon release(查看接入状态)
        
        @return: DescribeAddonReleaseResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_addon_release_with_options_async(release_name, policy_id, headers, runtime)

    def describe_addon_schema_with_options(
        self,
        name: str,
        request: cms_20240330_models.DescribeAddonSchemaRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeAddonSchemaResponse:
        """
        @summary 插件schema详情(Addon)
        
        @param request: DescribeAddonSchemaRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAddonSchemaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_type):
            query['environmentType'] = request.environment_type
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAddonSchema',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addon/{OpenApiUtilClient.get_encode_param(name)}/schema',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonSchemaResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonSchemaResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_addon_schema_with_options_async(
        self,
        name: str,
        request: cms_20240330_models.DescribeAddonSchemaRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeAddonSchemaResponse:
        """
        @summary 插件schema详情(Addon)
        
        @param request: DescribeAddonSchemaRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeAddonSchemaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_type):
            query['environmentType'] = request.environment_type
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeAddonSchema',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addon/{OpenApiUtilClient.get_encode_param(name)}/schema',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonSchemaResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeAddonSchemaResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_addon_schema(
        self,
        name: str,
        request: cms_20240330_models.DescribeAddonSchemaRequest,
    ) -> cms_20240330_models.DescribeAddonSchemaResponse:
        """
        @summary 插件schema详情(Addon)
        
        @param request: DescribeAddonSchemaRequest
        @return: DescribeAddonSchemaResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_addon_schema_with_options(name, request, headers, runtime)

    async def describe_addon_schema_async(
        self,
        name: str,
        request: cms_20240330_models.DescribeAddonSchemaRequest,
    ) -> cms_20240330_models.DescribeAddonSchemaResponse:
        """
        @summary 插件schema详情(Addon)
        
        @param request: DescribeAddonSchemaRequest
        @return: DescribeAddonSchemaResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_addon_schema_with_options_async(name, request, headers, runtime)

    def describe_common_incident_info_with_options(
        self,
        request: cms_20240330_models.DescribeCommonIncidentInfoRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeCommonIncidentInfoResponse:
        """
        @summary incident的通用查询，查询问题、事件
        
        @param request: DescribeCommonIncidentInfoRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCommonIncidentInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aggregate):
            query['aggregate'] = request.aggregate
        if not UtilClient.is_unset(request.and_filter):
            query['andFilter'] = request.and_filter
        if not UtilClient.is_unset(request.end_time):
            query['endTime'] = request.end_time
        if not UtilClient.is_unset(request.group_by):
            query['groupBy'] = request.group_by
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.or_filter):
            query['orFilter'] = request.or_filter
        if not UtilClient.is_unset(request.query_table):
            query['queryTable'] = request.query_table
        if not UtilClient.is_unset(request.query_type):
            query['queryType'] = request.query_type
        if not UtilClient.is_unset(request.start_time):
            query['startTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCommonIncidentInfo',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/common/info',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeCommonIncidentInfoResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeCommonIncidentInfoResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_common_incident_info_with_options_async(
        self,
        request: cms_20240330_models.DescribeCommonIncidentInfoRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeCommonIncidentInfoResponse:
        """
        @summary incident的通用查询，查询问题、事件
        
        @param request: DescribeCommonIncidentInfoRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeCommonIncidentInfoResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aggregate):
            query['aggregate'] = request.aggregate
        if not UtilClient.is_unset(request.and_filter):
            query['andFilter'] = request.and_filter
        if not UtilClient.is_unset(request.end_time):
            query['endTime'] = request.end_time
        if not UtilClient.is_unset(request.group_by):
            query['groupBy'] = request.group_by
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.or_filter):
            query['orFilter'] = request.or_filter
        if not UtilClient.is_unset(request.query_table):
            query['queryTable'] = request.query_table
        if not UtilClient.is_unset(request.query_type):
            query['queryType'] = request.query_type
        if not UtilClient.is_unset(request.start_time):
            query['startTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeCommonIncidentInfo',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/common/info',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeCommonIncidentInfoResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeCommonIncidentInfoResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_common_incident_info(
        self,
        request: cms_20240330_models.DescribeCommonIncidentInfoRequest,
    ) -> cms_20240330_models.DescribeCommonIncidentInfoResponse:
        """
        @summary incident的通用查询，查询问题、事件
        
        @param request: DescribeCommonIncidentInfoRequest
        @return: DescribeCommonIncidentInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_common_incident_info_with_options(request, headers, runtime)

    async def describe_common_incident_info_async(
        self,
        request: cms_20240330_models.DescribeCommonIncidentInfoRequest,
    ) -> cms_20240330_models.DescribeCommonIncidentInfoResponse:
        """
        @summary incident的通用查询，查询问题、事件
        
        @param request: DescribeCommonIncidentInfoRequest
        @return: DescribeCommonIncidentInfoResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_common_incident_info_with_options_async(request, headers, runtime)

    def describe_env_drop_metrics_rule_with_options(
        self,
        request: cms_20240330_models.DescribeEnvDropMetricsRuleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeEnvDropMetricsRuleResponse:
        """
        @summary 查询指定环境实例的废弃指标列表
        
        @param request: DescribeEnvDropMetricsRuleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEnvDropMetricsRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEnvDropMetricsRule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/DescribeEnvDropMetricsRule',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeEnvDropMetricsRuleResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeEnvDropMetricsRuleResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_env_drop_metrics_rule_with_options_async(
        self,
        request: cms_20240330_models.DescribeEnvDropMetricsRuleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeEnvDropMetricsRuleResponse:
        """
        @summary 查询指定环境实例的废弃指标列表
        
        @param request: DescribeEnvDropMetricsRuleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEnvDropMetricsRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEnvDropMetricsRule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/DescribeEnvDropMetricsRule',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeEnvDropMetricsRuleResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeEnvDropMetricsRuleResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_env_drop_metrics_rule(
        self,
        request: cms_20240330_models.DescribeEnvDropMetricsRuleRequest,
    ) -> cms_20240330_models.DescribeEnvDropMetricsRuleResponse:
        """
        @summary 查询指定环境实例的废弃指标列表
        
        @param request: DescribeEnvDropMetricsRuleRequest
        @return: DescribeEnvDropMetricsRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_env_drop_metrics_rule_with_options(request, headers, runtime)

    async def describe_env_drop_metrics_rule_async(
        self,
        request: cms_20240330_models.DescribeEnvDropMetricsRuleRequest,
    ) -> cms_20240330_models.DescribeEnvDropMetricsRuleResponse:
        """
        @summary 查询指定环境实例的废弃指标列表
        
        @param request: DescribeEnvDropMetricsRuleRequest
        @return: DescribeEnvDropMetricsRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_env_drop_metrics_rule_with_options_async(request, headers, runtime)

    def describe_environment_with_options(
        self,
        environment_id: str,
        request: cms_20240330_models.DescribeEnvironmentRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeEnvironmentResponse:
        """
        @summary 查询指定环境实例
        
        @param request: DescribeEnvironmentRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEnvironmentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEnvironment',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/environment/rest/{OpenApiUtilClient.get_encode_param(environment_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeEnvironmentResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeEnvironmentResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_environment_with_options_async(
        self,
        environment_id: str,
        request: cms_20240330_models.DescribeEnvironmentRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeEnvironmentResponse:
        """
        @summary 查询指定环境实例
        
        @param request: DescribeEnvironmentRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEnvironmentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEnvironment',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/environment/rest/{OpenApiUtilClient.get_encode_param(environment_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeEnvironmentResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeEnvironmentResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_environment(
        self,
        environment_id: str,
        request: cms_20240330_models.DescribeEnvironmentRequest,
    ) -> cms_20240330_models.DescribeEnvironmentResponse:
        """
        @summary 查询指定环境实例
        
        @param request: DescribeEnvironmentRequest
        @return: DescribeEnvironmentResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_environment_with_options(environment_id, request, headers, runtime)

    async def describe_environment_async(
        self,
        environment_id: str,
        request: cms_20240330_models.DescribeEnvironmentRequest,
    ) -> cms_20240330_models.DescribeEnvironmentResponse:
        """
        @summary 查询指定环境实例
        
        @param request: DescribeEnvironmentRequest
        @return: DescribeEnvironmentResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_environment_with_options_async(environment_id, request, headers, runtime)

    def describe_environment_feature_with_options(
        self,
        environment_id: str,
        feature_name: str,
        request: cms_20240330_models.DescribeEnvironmentFeatureRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeEnvironmentFeatureResponse:
        """
        @summary 查看 feature详情
        
        @param request: DescribeEnvironmentFeatureRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEnvironmentFeatureResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['AliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEnvironmentFeature',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/feature/rest/{OpenApiUtilClient.get_encode_param(environment_id)}/{OpenApiUtilClient.get_encode_param(feature_name)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeEnvironmentFeatureResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeEnvironmentFeatureResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_environment_feature_with_options_async(
        self,
        environment_id: str,
        feature_name: str,
        request: cms_20240330_models.DescribeEnvironmentFeatureRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeEnvironmentFeatureResponse:
        """
        @summary 查看 feature详情
        
        @param request: DescribeEnvironmentFeatureRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeEnvironmentFeatureResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['AliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeEnvironmentFeature',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/feature/rest/{OpenApiUtilClient.get_encode_param(environment_id)}/{OpenApiUtilClient.get_encode_param(feature_name)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeEnvironmentFeatureResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeEnvironmentFeatureResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_environment_feature(
        self,
        environment_id: str,
        feature_name: str,
        request: cms_20240330_models.DescribeEnvironmentFeatureRequest,
    ) -> cms_20240330_models.DescribeEnvironmentFeatureResponse:
        """
        @summary 查看 feature详情
        
        @param request: DescribeEnvironmentFeatureRequest
        @return: DescribeEnvironmentFeatureResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_environment_feature_with_options(environment_id, feature_name, request, headers, runtime)

    async def describe_environment_feature_async(
        self,
        environment_id: str,
        feature_name: str,
        request: cms_20240330_models.DescribeEnvironmentFeatureRequest,
    ) -> cms_20240330_models.DescribeEnvironmentFeatureResponse:
        """
        @summary 查看 feature详情
        
        @param request: DescribeEnvironmentFeatureRequest
        @return: DescribeEnvironmentFeatureResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_environment_feature_with_options_async(environment_id, feature_name, request, headers, runtime)

    def describe_incident_with_options(
        self,
        request: cms_20240330_models.DescribeIncidentRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeIncidentResponse:
        """
        @summary 查询Incident
        
        @param request: DescribeIncidentRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIncidentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.and_filter):
            query['andFilter'] = request.and_filter
        if not UtilClient.is_unset(request.end_time):
            query['endTime'] = request.end_time
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.incident_status):
            query['incidentStatus'] = request.incident_status
        if not UtilClient.is_unset(request.keyword):
            query['keyword'] = request.keyword
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.or_filter):
            query['orFilter'] = request.or_filter
        if not UtilClient.is_unset(request.order):
            query['order'] = request.order
        if not UtilClient.is_unset(request.start_time):
            query['startTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIncident',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_incident_with_options_async(
        self,
        request: cms_20240330_models.DescribeIncidentRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeIncidentResponse:
        """
        @summary 查询Incident
        
        @param request: DescribeIncidentRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIncidentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.and_filter):
            query['andFilter'] = request.and_filter
        if not UtilClient.is_unset(request.end_time):
            query['endTime'] = request.end_time
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.incident_status):
            query['incidentStatus'] = request.incident_status
        if not UtilClient.is_unset(request.keyword):
            query['keyword'] = request.keyword
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.or_filter):
            query['orFilter'] = request.or_filter
        if not UtilClient.is_unset(request.order):
            query['order'] = request.order
        if not UtilClient.is_unset(request.start_time):
            query['startTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIncident',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_incident(
        self,
        request: cms_20240330_models.DescribeIncidentRequest,
    ) -> cms_20240330_models.DescribeIncidentResponse:
        """
        @summary 查询Incident
        
        @param request: DescribeIncidentRequest
        @return: DescribeIncidentResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_incident_with_options(request, headers, runtime)

    async def describe_incident_async(
        self,
        request: cms_20240330_models.DescribeIncidentRequest,
    ) -> cms_20240330_models.DescribeIncidentResponse:
        """
        @summary 查询Incident
        
        @param request: DescribeIncidentRequest
        @return: DescribeIncidentResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_incident_with_options_async(request, headers, runtime)

    def describe_incident_escalation_with_options(
        self,
        request: cms_20240330_models.DescribeIncidentEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeIncidentEscalationResponse:
        """
        @summary 查询Incident升级计划列表
        
        @param request: DescribeIncidentEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIncidentEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_escalation_id):
            query['incidentEscalationId'] = request.incident_escalation_id
        if not UtilClient.is_unset(request.keyword):
            query['keyword'] = request.keyword
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIncidentEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/escalation/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentEscalationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentEscalationResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_incident_escalation_with_options_async(
        self,
        request: cms_20240330_models.DescribeIncidentEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeIncidentEscalationResponse:
        """
        @summary 查询Incident升级计划列表
        
        @param request: DescribeIncidentEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIncidentEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_escalation_id):
            query['incidentEscalationId'] = request.incident_escalation_id
        if not UtilClient.is_unset(request.keyword):
            query['keyword'] = request.keyword
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIncidentEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/escalation/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentEscalationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentEscalationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_incident_escalation(
        self,
        request: cms_20240330_models.DescribeIncidentEscalationRequest,
    ) -> cms_20240330_models.DescribeIncidentEscalationResponse:
        """
        @summary 查询Incident升级计划列表
        
        @param request: DescribeIncidentEscalationRequest
        @return: DescribeIncidentEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_incident_escalation_with_options(request, headers, runtime)

    async def describe_incident_escalation_async(
        self,
        request: cms_20240330_models.DescribeIncidentEscalationRequest,
    ) -> cms_20240330_models.DescribeIncidentEscalationResponse:
        """
        @summary 查询Incident升级计划列表
        
        @param request: DescribeIncidentEscalationRequest
        @return: DescribeIncidentEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_incident_escalation_with_options_async(request, headers, runtime)

    def describe_incident_event_with_options(
        self,
        request: cms_20240330_models.DescribeIncidentEventRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeIncidentEventResponse:
        """
        @summary 查询Incident相关的事件
        
        @param request: DescribeIncidentEventRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIncidentEventResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.max_result):
            query['maxResult'] = request.max_result
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.order):
            query['order'] = request.order
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIncidentEvent',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/event/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentEventResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentEventResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_incident_event_with_options_async(
        self,
        request: cms_20240330_models.DescribeIncidentEventRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeIncidentEventResponse:
        """
        @summary 查询Incident相关的事件
        
        @param request: DescribeIncidentEventRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIncidentEventResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.max_result):
            query['maxResult'] = request.max_result
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.order):
            query['order'] = request.order
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIncidentEvent',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/event/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentEventResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentEventResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_incident_event(
        self,
        request: cms_20240330_models.DescribeIncidentEventRequest,
    ) -> cms_20240330_models.DescribeIncidentEventResponse:
        """
        @summary 查询Incident相关的事件
        
        @param request: DescribeIncidentEventRequest
        @return: DescribeIncidentEventResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_incident_event_with_options(request, headers, runtime)

    async def describe_incident_event_async(
        self,
        request: cms_20240330_models.DescribeIncidentEventRequest,
    ) -> cms_20240330_models.DescribeIncidentEventResponse:
        """
        @summary 查询Incident相关的事件
        
        @param request: DescribeIncidentEventRequest
        @return: DescribeIncidentEventResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_incident_event_with_options_async(request, headers, runtime)

    def describe_incident_member_with_options(
        self,
        request: cms_20240330_models.DescribeIncidentMemberRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeIncidentMemberResponse:
        """
        @summary 列出Incident的参与者
        
        @param request: DescribeIncidentMemberRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIncidentMemberResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['endTime'] = request.end_time
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.order):
            query['order'] = request.order
        if not UtilClient.is_unset(request.start_time):
            query['startTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIncidentMember',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/member/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentMemberResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentMemberResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_incident_member_with_options_async(
        self,
        request: cms_20240330_models.DescribeIncidentMemberRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeIncidentMemberResponse:
        """
        @summary 列出Incident的参与者
        
        @param request: DescribeIncidentMemberRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIncidentMemberResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['endTime'] = request.end_time
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.order):
            query['order'] = request.order
        if not UtilClient.is_unset(request.start_time):
            query['startTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIncidentMember',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/member/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentMemberResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentMemberResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_incident_member(
        self,
        request: cms_20240330_models.DescribeIncidentMemberRequest,
    ) -> cms_20240330_models.DescribeIncidentMemberResponse:
        """
        @summary 列出Incident的参与者
        
        @param request: DescribeIncidentMemberRequest
        @return: DescribeIncidentMemberResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_incident_member_with_options(request, headers, runtime)

    async def describe_incident_member_async(
        self,
        request: cms_20240330_models.DescribeIncidentMemberRequest,
    ) -> cms_20240330_models.DescribeIncidentMemberResponse:
        """
        @summary 列出Incident的参与者
        
        @param request: DescribeIncidentMemberRequest
        @return: DescribeIncidentMemberResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_incident_member_with_options_async(request, headers, runtime)

    def describe_incident_note_list_with_options(
        self,
        request: cms_20240330_models.DescribeIncidentNoteListRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeIncidentNoteListResponse:
        """
        @summary 查询note列表
        
        @param request: DescribeIncidentNoteListRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIncidentNoteListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIncidentNoteList',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/note/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentNoteListResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentNoteListResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_incident_note_list_with_options_async(
        self,
        request: cms_20240330_models.DescribeIncidentNoteListRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeIncidentNoteListResponse:
        """
        @summary 查询note列表
        
        @param request: DescribeIncidentNoteListRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIncidentNoteListResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIncidentNoteList',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/note/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentNoteListResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentNoteListResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_incident_note_list(
        self,
        request: cms_20240330_models.DescribeIncidentNoteListRequest,
    ) -> cms_20240330_models.DescribeIncidentNoteListResponse:
        """
        @summary 查询note列表
        
        @param request: DescribeIncidentNoteListRequest
        @return: DescribeIncidentNoteListResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_incident_note_list_with_options(request, headers, runtime)

    async def describe_incident_note_list_async(
        self,
        request: cms_20240330_models.DescribeIncidentNoteListRequest,
    ) -> cms_20240330_models.DescribeIncidentNoteListResponse:
        """
        @summary 查询note列表
        
        @param request: DescribeIncidentNoteListRequest
        @return: DescribeIncidentNoteListResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_incident_note_list_with_options_async(request, headers, runtime)

    def describe_incident_plan_with_options(
        self,
        request: cms_20240330_models.DescribeIncidentPlanRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeIncidentPlanResponse:
        """
        @summary 查询Incident计划列表
        
        @param request: DescribeIncidentPlanRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIncidentPlanResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_plan_id):
            query['incidentPlanId'] = request.incident_plan_id
        if not UtilClient.is_unset(request.keyword):
            query['keyword'] = request.keyword
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIncidentPlan',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/plan/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentPlanResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentPlanResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_incident_plan_with_options_async(
        self,
        request: cms_20240330_models.DescribeIncidentPlanRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeIncidentPlanResponse:
        """
        @summary 查询Incident计划列表
        
        @param request: DescribeIncidentPlanRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIncidentPlanResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_plan_id):
            query['incidentPlanId'] = request.incident_plan_id
        if not UtilClient.is_unset(request.keyword):
            query['keyword'] = request.keyword
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIncidentPlan',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/plan/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentPlanResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentPlanResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_incident_plan(
        self,
        request: cms_20240330_models.DescribeIncidentPlanRequest,
    ) -> cms_20240330_models.DescribeIncidentPlanResponse:
        """
        @summary 查询Incident计划列表
        
        @param request: DescribeIncidentPlanRequest
        @return: DescribeIncidentPlanResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_incident_plan_with_options(request, headers, runtime)

    async def describe_incident_plan_async(
        self,
        request: cms_20240330_models.DescribeIncidentPlanRequest,
    ) -> cms_20240330_models.DescribeIncidentPlanResponse:
        """
        @summary 查询Incident计划列表
        
        @param request: DescribeIncidentPlanRequest
        @return: DescribeIncidentPlanResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_incident_plan_with_options_async(request, headers, runtime)

    def describe_incident_resource_with_options(
        self,
        request: cms_20240330_models.DescribeIncidentResourceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeIncidentResourceResponse:
        """
        @summary 查询Incident资源列表
        
        @param request: DescribeIncidentResourceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIncidentResourceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.order):
            query['order'] = request.order
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIncidentResource',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/resource/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentResourceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentResourceResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_incident_resource_with_options_async(
        self,
        request: cms_20240330_models.DescribeIncidentResourceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeIncidentResourceResponse:
        """
        @summary 查询Incident资源列表
        
        @param request: DescribeIncidentResourceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIncidentResourceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.order):
            query['order'] = request.order
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIncidentResource',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/resource/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentResourceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentResourceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_incident_resource(
        self,
        request: cms_20240330_models.DescribeIncidentResourceRequest,
    ) -> cms_20240330_models.DescribeIncidentResourceResponse:
        """
        @summary 查询Incident资源列表
        
        @param request: DescribeIncidentResourceRequest
        @return: DescribeIncidentResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_incident_resource_with_options(request, headers, runtime)

    async def describe_incident_resource_async(
        self,
        request: cms_20240330_models.DescribeIncidentResourceRequest,
    ) -> cms_20240330_models.DescribeIncidentResourceResponse:
        """
        @summary 查询Incident资源列表
        
        @param request: DescribeIncidentResourceRequest
        @return: DescribeIncidentResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_incident_resource_with_options_async(request, headers, runtime)

    def describe_incident_timeline_with_options(
        self,
        request: cms_20240330_models.DescribeIncidentTimelineRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeIncidentTimelineResponse:
        """
        @summary 查询Incident的时间线
        
        @param request: DescribeIncidentTimelineRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIncidentTimelineResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['endTime'] = request.end_time
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.order):
            query['order'] = request.order
        if not UtilClient.is_unset(request.start_time):
            query['startTime'] = request.start_time
        if not UtilClient.is_unset(request.type):
            query['type'] = request.type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIncidentTimeline',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/timeline/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentTimelineResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentTimelineResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_incident_timeline_with_options_async(
        self,
        request: cms_20240330_models.DescribeIncidentTimelineRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeIncidentTimelineResponse:
        """
        @summary 查询Incident的时间线
        
        @param request: DescribeIncidentTimelineRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeIncidentTimelineResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.end_time):
            query['endTime'] = request.end_time
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.order):
            query['order'] = request.order
        if not UtilClient.is_unset(request.start_time):
            query['startTime'] = request.start_time
        if not UtilClient.is_unset(request.type):
            query['type'] = request.type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeIncidentTimeline',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/timeline/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentTimelineResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeIncidentTimelineResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_incident_timeline(
        self,
        request: cms_20240330_models.DescribeIncidentTimelineRequest,
    ) -> cms_20240330_models.DescribeIncidentTimelineResponse:
        """
        @summary 查询Incident的时间线
        
        @param request: DescribeIncidentTimelineRequest
        @return: DescribeIncidentTimelineResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_incident_timeline_with_options(request, headers, runtime)

    async def describe_incident_timeline_async(
        self,
        request: cms_20240330_models.DescribeIncidentTimelineRequest,
    ) -> cms_20240330_models.DescribeIncidentTimelineResponse:
        """
        @summary 查询Incident的时间线
        
        @param request: DescribeIncidentTimelineRequest
        @return: DescribeIncidentTimelineResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_incident_timeline_with_options_async(request, headers, runtime)

    def describe_layout_with_options(
        self,
        request: cms_20240330_models.DescribeLayoutRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeLayoutResponse:
        """
        @summary 查看环境的视图
        
        @param request: DescribeLayoutRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLayoutResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['AliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.bind_resource_id):
            query['BindResourceId'] = request.bind_resource_id
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLayout',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/DescribeLayout',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeLayoutResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeLayoutResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_layout_with_options_async(
        self,
        request: cms_20240330_models.DescribeLayoutRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeLayoutResponse:
        """
        @summary 查看环境的视图
        
        @param request: DescribeLayoutRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLayoutResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['AliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.bind_resource_id):
            query['BindResourceId'] = request.bind_resource_id
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_type):
            query['ResourceType'] = request.resource_type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLayout',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/DescribeLayout',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeLayoutResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeLayoutResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_layout(
        self,
        request: cms_20240330_models.DescribeLayoutRequest,
    ) -> cms_20240330_models.DescribeLayoutResponse:
        """
        @summary 查看环境的视图
        
        @param request: DescribeLayoutRequest
        @return: DescribeLayoutResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_layout_with_options(request, headers, runtime)

    async def describe_layout_async(
        self,
        request: cms_20240330_models.DescribeLayoutRequest,
    ) -> cms_20240330_models.DescribeLayoutResponse:
        """
        @summary 查看环境的视图
        
        @param request: DescribeLayoutRequest
        @return: DescribeLayoutResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_layout_with_options_async(request, headers, runtime)

    def describe_layout_view_with_options(
        self,
        request: cms_20240330_models.DescribeLayoutViewRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeLayoutViewResponse:
        """
        @summary 查看环境的视图
        
        @param request: DescribeLayoutViewRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLayoutViewResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene):
            query['Scene'] = request.scene
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLayoutView',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/DescribeLayoutView',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeLayoutViewResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeLayoutViewResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_layout_view_with_options_async(
        self,
        request: cms_20240330_models.DescribeLayoutViewRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeLayoutViewResponse:
        """
        @summary 查看环境的视图
        
        @param request: DescribeLayoutViewRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeLayoutViewResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene):
            query['Scene'] = request.scene
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeLayoutView',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/DescribeLayoutView',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeLayoutViewResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeLayoutViewResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_layout_view(
        self,
        request: cms_20240330_models.DescribeLayoutViewRequest,
    ) -> cms_20240330_models.DescribeLayoutViewResponse:
        """
        @summary 查看环境的视图
        
        @param request: DescribeLayoutViewRequest
        @return: DescribeLayoutViewResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_layout_view_with_options(request, headers, runtime)

    async def describe_layout_view_async(
        self,
        request: cms_20240330_models.DescribeLayoutViewRequest,
    ) -> cms_20240330_models.DescribeLayoutViewResponse:
        """
        @summary 查看环境的视图
        
        @param request: DescribeLayoutViewRequest
        @return: DescribeLayoutViewResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_layout_view_with_options_async(request, headers, runtime)

    def describe_metric_data_for_alert_preview_with_options(
        self,
        request: cms_20240330_models.DescribeMetricDataForAlertPreviewRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeMetricDataForAlertPreviewResponse:
        """
        @summary 报警预览查询监控数据
        
        @param request: DescribeMetricDataForAlertPreviewRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeMetricDataForAlertPreviewResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.datasource):
            query['datasource'] = request.datasource
        if not UtilClient.is_unset(request.end_time):
            query['endTime'] = request.end_time
        if not UtilClient.is_unset(request.limit):
            query['limit'] = request.limit
        if not UtilClient.is_unset(request.query):
            query['query'] = request.query
        if not UtilClient.is_unset(request.start_time):
            query['startTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeMetricDataForAlertPreview',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/metric/preview/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeMetricDataForAlertPreviewResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeMetricDataForAlertPreviewResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_metric_data_for_alert_preview_with_options_async(
        self,
        request: cms_20240330_models.DescribeMetricDataForAlertPreviewRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribeMetricDataForAlertPreviewResponse:
        """
        @summary 报警预览查询监控数据
        
        @param request: DescribeMetricDataForAlertPreviewRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribeMetricDataForAlertPreviewResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.datasource):
            query['datasource'] = request.datasource
        if not UtilClient.is_unset(request.end_time):
            query['endTime'] = request.end_time
        if not UtilClient.is_unset(request.limit):
            query['limit'] = request.limit
        if not UtilClient.is_unset(request.query):
            query['query'] = request.query
        if not UtilClient.is_unset(request.start_time):
            query['startTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribeMetricDataForAlertPreview',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/metric/preview/list',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribeMetricDataForAlertPreviewResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribeMetricDataForAlertPreviewResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_metric_data_for_alert_preview(
        self,
        request: cms_20240330_models.DescribeMetricDataForAlertPreviewRequest,
    ) -> cms_20240330_models.DescribeMetricDataForAlertPreviewResponse:
        """
        @summary 报警预览查询监控数据
        
        @param request: DescribeMetricDataForAlertPreviewRequest
        @return: DescribeMetricDataForAlertPreviewResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_metric_data_for_alert_preview_with_options(request, headers, runtime)

    async def describe_metric_data_for_alert_preview_async(
        self,
        request: cms_20240330_models.DescribeMetricDataForAlertPreviewRequest,
    ) -> cms_20240330_models.DescribeMetricDataForAlertPreviewResponse:
        """
        @summary 报警预览查询监控数据
        
        @param request: DescribeMetricDataForAlertPreviewRequest
        @return: DescribeMetricDataForAlertPreviewResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_metric_data_for_alert_preview_with_options_async(request, headers, runtime)

    def describe_policy_with_options(
        self,
        request: cms_20240330_models.DescribePolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribePolicyResponse:
        """
        @summary 查询接入中心策略列表信息
        
        @param request: DescribePolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.filter_region_ids):
            query['filterRegionIDs'] = request.filter_region_ids
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.policy_id):
            query['policyId'] = request.policy_id
        if not UtilClient.is_unset(request.policy_name):
            query['policyName'] = request.policy_name
        if not UtilClient.is_unset(request.policy_type):
            query['policyType'] = request.policy_type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribePolicyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribePolicyResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_policy_with_options_async(
        self,
        request: cms_20240330_models.DescribePolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribePolicyResponse:
        """
        @summary 查询接入中心策略列表信息
        
        @param request: DescribePolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.filter_region_ids):
            query['filterRegionIDs'] = request.filter_region_ids
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.policy_id):
            query['policyId'] = request.policy_id
        if not UtilClient.is_unset(request.policy_name):
            query['policyName'] = request.policy_name
        if not UtilClient.is_unset(request.policy_type):
            query['policyType'] = request.policy_type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribePolicyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribePolicyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_policy(
        self,
        request: cms_20240330_models.DescribePolicyRequest,
    ) -> cms_20240330_models.DescribePolicyResponse:
        """
        @summary 查询接入中心策略列表信息
        
        @param request: DescribePolicyRequest
        @return: DescribePolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_policy_with_options(request, headers, runtime)

    async def describe_policy_async(
        self,
        request: cms_20240330_models.DescribePolicyRequest,
    ) -> cms_20240330_models.DescribePolicyResponse:
        """
        @summary 查询接入中心策略列表信息
        
        @param request: DescribePolicyRequest
        @return: DescribePolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_policy_with_options_async(request, headers, runtime)

    def describe_prometheus_instance_with_options(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.DescribePrometheusInstanceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribePrometheusInstanceResponse:
        """
        @summary 查询指定环境实例
        
        @param request: DescribePrometheusInstanceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePrometheusInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePrometheusInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/{OpenApiUtilClient.get_encode_param(prometheus_instance_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribePrometheusInstanceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribePrometheusInstanceResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_prometheus_instance_with_options_async(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.DescribePrometheusInstanceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribePrometheusInstanceResponse:
        """
        @summary 查询指定环境实例
        
        @param request: DescribePrometheusInstanceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePrometheusInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePrometheusInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/{OpenApiUtilClient.get_encode_param(prometheus_instance_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribePrometheusInstanceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribePrometheusInstanceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_prometheus_instance(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.DescribePrometheusInstanceRequest,
    ) -> cms_20240330_models.DescribePrometheusInstanceResponse:
        """
        @summary 查询指定环境实例
        
        @param request: DescribePrometheusInstanceRequest
        @return: DescribePrometheusInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_prometheus_instance_with_options(prometheus_instance_id, request, headers, runtime)

    async def describe_prometheus_instance_async(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.DescribePrometheusInstanceRequest,
    ) -> cms_20240330_models.DescribePrometheusInstanceResponse:
        """
        @summary 查询指定环境实例
        
        @param request: DescribePrometheusInstanceRequest
        @return: DescribePrometheusInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_prometheus_instance_with_options_async(prometheus_instance_id, request, headers, runtime)

    def describe_prometheus_view_with_options(
        self,
        prometheus_view_id: str,
        request: cms_20240330_models.DescribePrometheusViewRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribePrometheusViewResponse:
        """
        @summary 查询指定Prometheus视图实例
        
        @param request: DescribePrometheusViewRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePrometheusViewResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePrometheusView',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus_view/{OpenApiUtilClient.get_encode_param(prometheus_view_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribePrometheusViewResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribePrometheusViewResponse(),
                self.execute(params, req, runtime)
            )

    async def describe_prometheus_view_with_options_async(
        self,
        prometheus_view_id: str,
        request: cms_20240330_models.DescribePrometheusViewRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DescribePrometheusViewResponse:
        """
        @summary 查询指定Prometheus视图实例
        
        @param request: DescribePrometheusViewRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DescribePrometheusViewResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DescribePrometheusView',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus_view/{OpenApiUtilClient.get_encode_param(prometheus_view_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DescribePrometheusViewResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DescribePrometheusViewResponse(),
                await self.execute_async(params, req, runtime)
            )

    def describe_prometheus_view(
        self,
        prometheus_view_id: str,
        request: cms_20240330_models.DescribePrometheusViewRequest,
    ) -> cms_20240330_models.DescribePrometheusViewResponse:
        """
        @summary 查询指定Prometheus视图实例
        
        @param request: DescribePrometheusViewRequest
        @return: DescribePrometheusViewResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.describe_prometheus_view_with_options(prometheus_view_id, request, headers, runtime)

    async def describe_prometheus_view_async(
        self,
        prometheus_view_id: str,
        request: cms_20240330_models.DescribePrometheusViewRequest,
    ) -> cms_20240330_models.DescribePrometheusViewResponse:
        """
        @summary 查询指定Prometheus视图实例
        
        @param request: DescribePrometheusViewRequest
        @return: DescribePrometheusViewResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.describe_prometheus_view_with_options_async(prometheus_view_id, request, headers, runtime)

    def detail_metric_target_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.DetailMetricTargetRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DetailMetricTargetResponse:
        """
        @summary 策略指标target详情
        
        @param request: DetailMetricTargetRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DetailMetricTargetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_name):
            query['jobName'] = request.job_name
        if not UtilClient.is_unset(request.target_url):
            query['targetUrl'] = request.target_url
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DetailMetricTarget',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy/{OpenApiUtilClient.get_encode_param(policy_id)}/target',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DetailMetricTargetResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DetailMetricTargetResponse(),
                self.execute(params, req, runtime)
            )

    async def detail_metric_target_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.DetailMetricTargetRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DetailMetricTargetResponse:
        """
        @summary 策略指标target详情
        
        @param request: DetailMetricTargetRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DetailMetricTargetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_name):
            query['jobName'] = request.job_name
        if not UtilClient.is_unset(request.target_url):
            query['targetUrl'] = request.target_url
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DetailMetricTarget',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy/{OpenApiUtilClient.get_encode_param(policy_id)}/target',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DetailMetricTargetResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DetailMetricTargetResponse(),
                await self.execute_async(params, req, runtime)
            )

    def detail_metric_target(
        self,
        policy_id: str,
        request: cms_20240330_models.DetailMetricTargetRequest,
    ) -> cms_20240330_models.DetailMetricTargetResponse:
        """
        @summary 策略指标target详情
        
        @param request: DetailMetricTargetRequest
        @return: DetailMetricTargetResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.detail_metric_target_with_options(policy_id, request, headers, runtime)

    async def detail_metric_target_async(
        self,
        policy_id: str,
        request: cms_20240330_models.DetailMetricTargetRequest,
    ) -> cms_20240330_models.DetailMetricTargetResponse:
        """
        @summary 策略指标target详情
        
        @param request: DetailMetricTargetRequest
        @return: DetailMetricTargetResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.detail_metric_target_with_options_async(policy_id, request, headers, runtime)

    def disable_alert_event_integration_policy_with_options(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.DisableAlertEventIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DisableAlertEventIntegrationPolicyResponse:
        """
        @summary 暂停集成
        
        @param request: DisableAlertEventIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableAlertEventIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableAlertEventIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertEventIntegrationPolicies/{OpenApiUtilClient.get_encode_param(alert_event_integration_policy_id)}/disable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DisableAlertEventIntegrationPolicyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DisableAlertEventIntegrationPolicyResponse(),
                self.execute(params, req, runtime)
            )

    async def disable_alert_event_integration_policy_with_options_async(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.DisableAlertEventIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DisableAlertEventIntegrationPolicyResponse:
        """
        @summary 暂停集成
        
        @param request: DisableAlertEventIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableAlertEventIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableAlertEventIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertEventIntegrationPolicies/{OpenApiUtilClient.get_encode_param(alert_event_integration_policy_id)}/disable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DisableAlertEventIntegrationPolicyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DisableAlertEventIntegrationPolicyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def disable_alert_event_integration_policy(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.DisableAlertEventIntegrationPolicyRequest,
    ) -> cms_20240330_models.DisableAlertEventIntegrationPolicyResponse:
        """
        @summary 暂停集成
        
        @param request: DisableAlertEventIntegrationPolicyRequest
        @return: DisableAlertEventIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.disable_alert_event_integration_policy_with_options(alert_event_integration_policy_id, request, headers, runtime)

    async def disable_alert_event_integration_policy_async(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.DisableAlertEventIntegrationPolicyRequest,
    ) -> cms_20240330_models.DisableAlertEventIntegrationPolicyResponse:
        """
        @summary 暂停集成
        
        @param request: DisableAlertEventIntegrationPolicyRequest
        @return: DisableAlertEventIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.disable_alert_event_integration_policy_with_options_async(alert_event_integration_policy_id, request, headers, runtime)

    def disable_alert_rule_with_options(
        self,
        request: cms_20240330_models.DisableAlertRuleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DisableAlertRuleResponse:
        """
        @summary 禁用云监控2.0告警规则
        
        @param request: DisableAlertRuleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableAlertRuleResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_rule_ids):
            body['alertRuleIds'] = request.alert_rule_ids
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='DisableAlertRule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules/action/disable',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DisableAlertRuleResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DisableAlertRuleResponse(),
                self.execute(params, req, runtime)
            )

    async def disable_alert_rule_with_options_async(
        self,
        request: cms_20240330_models.DisableAlertRuleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DisableAlertRuleResponse:
        """
        @summary 禁用云监控2.0告警规则
        
        @param request: DisableAlertRuleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableAlertRuleResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_rule_ids):
            body['alertRuleIds'] = request.alert_rule_ids
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='DisableAlertRule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules/action/disable',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DisableAlertRuleResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DisableAlertRuleResponse(),
                await self.execute_async(params, req, runtime)
            )

    def disable_alert_rule(
        self,
        request: cms_20240330_models.DisableAlertRuleRequest,
    ) -> cms_20240330_models.DisableAlertRuleResponse:
        """
        @summary 禁用云监控2.0告警规则
        
        @param request: DisableAlertRuleRequest
        @return: DisableAlertRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.disable_alert_rule_with_options(request, headers, runtime)

    async def disable_alert_rule_async(
        self,
        request: cms_20240330_models.DisableAlertRuleRequest,
    ) -> cms_20240330_models.DisableAlertRuleResponse:
        """
        @summary 禁用云监控2.0告警规则
        
        @param request: DisableAlertRuleRequest
        @return: DisableAlertRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.disable_alert_rule_with_options_async(request, headers, runtime)

    def disable_alert_rules_with_options(
        self,
        tmp_req: cms_20240330_models.DisableAlertRulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DisableAlertRulesResponse:
        """
        @summary 禁用云监控2.0告警规则
        
        @param tmp_req: DisableAlertRulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableAlertRulesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DisableAlertRulesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.alert_rule_ids):
            request.alert_rule_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.alert_rule_ids, 'alertRuleIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_rule_ids_shrink):
            query['alertRuleIds'] = request.alert_rule_ids_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableAlertRules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules/action/disable',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DisableAlertRulesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DisableAlertRulesResponse(),
                self.execute(params, req, runtime)
            )

    async def disable_alert_rules_with_options_async(
        self,
        tmp_req: cms_20240330_models.DisableAlertRulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DisableAlertRulesResponse:
        """
        @summary 禁用云监控2.0告警规则
        
        @param tmp_req: DisableAlertRulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableAlertRulesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.DisableAlertRulesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.alert_rule_ids):
            request.alert_rule_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.alert_rule_ids, 'alertRuleIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_rule_ids_shrink):
            query['alertRuleIds'] = request.alert_rule_ids_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableAlertRules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules/action/disable',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DisableAlertRulesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DisableAlertRulesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def disable_alert_rules(
        self,
        request: cms_20240330_models.DisableAlertRulesRequest,
    ) -> cms_20240330_models.DisableAlertRulesResponse:
        """
        @summary 禁用云监控2.0告警规则
        
        @param request: DisableAlertRulesRequest
        @return: DisableAlertRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.disable_alert_rules_with_options(request, headers, runtime)

    async def disable_alert_rules_async(
        self,
        request: cms_20240330_models.DisableAlertRulesRequest,
    ) -> cms_20240330_models.DisableAlertRulesResponse:
        """
        @summary 禁用云监控2.0告警规则
        
        @param request: DisableAlertRulesRequest
        @return: DisableAlertRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.disable_alert_rules_with_options_async(request, headers, runtime)

    def disable_integration_with_options(
        self,
        integration_id: str,
        request: cms_20240330_models.DisableIntegrationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DisableIntegrationResponse:
        """
        @summary 暂停集成
        
        @param request: DisableIntegrationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableIntegrationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableIntegration',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integrations/{OpenApiUtilClient.get_encode_param(integration_id)}/disable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DisableIntegrationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DisableIntegrationResponse(),
                self.execute(params, req, runtime)
            )

    async def disable_integration_with_options_async(
        self,
        integration_id: str,
        request: cms_20240330_models.DisableIntegrationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DisableIntegrationResponse:
        """
        @summary 暂停集成
        
        @param request: DisableIntegrationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableIntegrationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableIntegration',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integrations/{OpenApiUtilClient.get_encode_param(integration_id)}/disable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DisableIntegrationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DisableIntegrationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def disable_integration(
        self,
        integration_id: str,
        request: cms_20240330_models.DisableIntegrationRequest,
    ) -> cms_20240330_models.DisableIntegrationResponse:
        """
        @summary 暂停集成
        
        @param request: DisableIntegrationRequest
        @return: DisableIntegrationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.disable_integration_with_options(integration_id, request, headers, runtime)

    async def disable_integration_async(
        self,
        integration_id: str,
        request: cms_20240330_models.DisableIntegrationRequest,
    ) -> cms_20240330_models.DisableIntegrationResponse:
        """
        @summary 暂停集成
        
        @param request: DisableIntegrationRequest
        @return: DisableIntegrationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.disable_integration_with_options_async(integration_id, request, headers, runtime)

    def disable_maintain_window_with_options(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.DisableMaintainWindowRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DisableMaintainWindowResponse:
        """
        @summary 暂停转换器
        
        @param request: DisableMaintainWindowRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableMaintainWindowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableMaintainWindow',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/maintainWindows/{OpenApiUtilClient.get_encode_param(maintain_window_id)}/disable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DisableMaintainWindowResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DisableMaintainWindowResponse(),
                self.execute(params, req, runtime)
            )

    async def disable_maintain_window_with_options_async(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.DisableMaintainWindowRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DisableMaintainWindowResponse:
        """
        @summary 暂停转换器
        
        @param request: DisableMaintainWindowRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableMaintainWindowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableMaintainWindow',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/maintainWindows/{OpenApiUtilClient.get_encode_param(maintain_window_id)}/disable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DisableMaintainWindowResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DisableMaintainWindowResponse(),
                await self.execute_async(params, req, runtime)
            )

    def disable_maintain_window(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.DisableMaintainWindowRequest,
    ) -> cms_20240330_models.DisableMaintainWindowResponse:
        """
        @summary 暂停转换器
        
        @param request: DisableMaintainWindowRequest
        @return: DisableMaintainWindowResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.disable_maintain_window_with_options(maintain_window_id, request, headers, runtime)

    async def disable_maintain_window_async(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.DisableMaintainWindowRequest,
    ) -> cms_20240330_models.DisableMaintainWindowResponse:
        """
        @summary 暂停转换器
        
        @param request: DisableMaintainWindowRequest
        @return: DisableMaintainWindowResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.disable_maintain_window_with_options_async(maintain_window_id, request, headers, runtime)

    def disable_notify_strategy_with_options(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.DisableNotifyStrategyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DisableNotifyStrategyResponse:
        """
        @summary 暂停订阅
        
        @param request: DisableNotifyStrategyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableNotifyStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableNotifyStrategy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/notifyStrategies/{OpenApiUtilClient.get_encode_param(notify_strategy_id)}/disable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DisableNotifyStrategyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DisableNotifyStrategyResponse(),
                self.execute(params, req, runtime)
            )

    async def disable_notify_strategy_with_options_async(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.DisableNotifyStrategyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DisableNotifyStrategyResponse:
        """
        @summary 暂停订阅
        
        @param request: DisableNotifyStrategyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableNotifyStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableNotifyStrategy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/notifyStrategies/{OpenApiUtilClient.get_encode_param(notify_strategy_id)}/disable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DisableNotifyStrategyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DisableNotifyStrategyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def disable_notify_strategy(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.DisableNotifyStrategyRequest,
    ) -> cms_20240330_models.DisableNotifyStrategyResponse:
        """
        @summary 暂停订阅
        
        @param request: DisableNotifyStrategyRequest
        @return: DisableNotifyStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.disable_notify_strategy_with_options(notify_strategy_id, request, headers, runtime)

    async def disable_notify_strategy_async(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.DisableNotifyStrategyRequest,
    ) -> cms_20240330_models.DisableNotifyStrategyResponse:
        """
        @summary 暂停订阅
        
        @param request: DisableNotifyStrategyRequest
        @return: DisableNotifyStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.disable_notify_strategy_with_options_async(notify_strategy_id, request, headers, runtime)

    def disable_subscription_with_options(
        self,
        subscription_id: str,
        request: cms_20240330_models.DisableSubscriptionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DisableSubscriptionResponse:
        """
        @summary 暂停订阅
        
        @param request: DisableSubscriptionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableSubscriptionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableSubscription',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/subscriptions/{OpenApiUtilClient.get_encode_param(subscription_id)}/disable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DisableSubscriptionResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DisableSubscriptionResponse(),
                self.execute(params, req, runtime)
            )

    async def disable_subscription_with_options_async(
        self,
        subscription_id: str,
        request: cms_20240330_models.DisableSubscriptionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DisableSubscriptionResponse:
        """
        @summary 暂停订阅
        
        @param request: DisableSubscriptionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableSubscriptionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableSubscription',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/subscriptions/{OpenApiUtilClient.get_encode_param(subscription_id)}/disable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DisableSubscriptionResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DisableSubscriptionResponse(),
                await self.execute_async(params, req, runtime)
            )

    def disable_subscription(
        self,
        subscription_id: str,
        request: cms_20240330_models.DisableSubscriptionRequest,
    ) -> cms_20240330_models.DisableSubscriptionResponse:
        """
        @summary 暂停订阅
        
        @param request: DisableSubscriptionRequest
        @return: DisableSubscriptionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.disable_subscription_with_options(subscription_id, request, headers, runtime)

    async def disable_subscription_async(
        self,
        subscription_id: str,
        request: cms_20240330_models.DisableSubscriptionRequest,
    ) -> cms_20240330_models.DisableSubscriptionResponse:
        """
        @summary 暂停订阅
        
        @param request: DisableSubscriptionRequest
        @return: DisableSubscriptionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.disable_subscription_with_options_async(subscription_id, request, headers, runtime)

    def disable_transformer_with_options(
        self,
        transformer_id: str,
        request: cms_20240330_models.DisableTransformerRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DisableTransformerResponse:
        """
        @summary 暂停转换器
        
        @param request: DisableTransformerRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableTransformerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableTransformer',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/transformers/{OpenApiUtilClient.get_encode_param(transformer_id)}/disable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DisableTransformerResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DisableTransformerResponse(),
                self.execute(params, req, runtime)
            )

    async def disable_transformer_with_options_async(
        self,
        transformer_id: str,
        request: cms_20240330_models.DisableTransformerRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.DisableTransformerResponse:
        """
        @summary 暂停转换器
        
        @param request: DisableTransformerRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: DisableTransformerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='DisableTransformer',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/transformers/{OpenApiUtilClient.get_encode_param(transformer_id)}/disable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.DisableTransformerResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.DisableTransformerResponse(),
                await self.execute_async(params, req, runtime)
            )

    def disable_transformer(
        self,
        transformer_id: str,
        request: cms_20240330_models.DisableTransformerRequest,
    ) -> cms_20240330_models.DisableTransformerResponse:
        """
        @summary 暂停转换器
        
        @param request: DisableTransformerRequest
        @return: DisableTransformerResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.disable_transformer_with_options(transformer_id, request, headers, runtime)

    async def disable_transformer_async(
        self,
        transformer_id: str,
        request: cms_20240330_models.DisableTransformerRequest,
    ) -> cms_20240330_models.DisableTransformerResponse:
        """
        @summary 暂停转换器
        
        @param request: DisableTransformerRequest
        @return: DisableTransformerResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.disable_transformer_with_options_async(transformer_id, request, headers, runtime)

    def enable_alert_event_integration_policy_with_options(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.EnableAlertEventIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.EnableAlertEventIntegrationPolicyResponse:
        """
        @summary 启动集成
        
        @param request: EnableAlertEventIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableAlertEventIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableAlertEventIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertEventIntegrationPolicies/{OpenApiUtilClient.get_encode_param(alert_event_integration_policy_id)}/enable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.EnableAlertEventIntegrationPolicyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.EnableAlertEventIntegrationPolicyResponse(),
                self.execute(params, req, runtime)
            )

    async def enable_alert_event_integration_policy_with_options_async(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.EnableAlertEventIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.EnableAlertEventIntegrationPolicyResponse:
        """
        @summary 启动集成
        
        @param request: EnableAlertEventIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableAlertEventIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableAlertEventIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertEventIntegrationPolicies/{OpenApiUtilClient.get_encode_param(alert_event_integration_policy_id)}/enable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.EnableAlertEventIntegrationPolicyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.EnableAlertEventIntegrationPolicyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def enable_alert_event_integration_policy(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.EnableAlertEventIntegrationPolicyRequest,
    ) -> cms_20240330_models.EnableAlertEventIntegrationPolicyResponse:
        """
        @summary 启动集成
        
        @param request: EnableAlertEventIntegrationPolicyRequest
        @return: EnableAlertEventIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.enable_alert_event_integration_policy_with_options(alert_event_integration_policy_id, request, headers, runtime)

    async def enable_alert_event_integration_policy_async(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.EnableAlertEventIntegrationPolicyRequest,
    ) -> cms_20240330_models.EnableAlertEventIntegrationPolicyResponse:
        """
        @summary 启动集成
        
        @param request: EnableAlertEventIntegrationPolicyRequest
        @return: EnableAlertEventIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.enable_alert_event_integration_policy_with_options_async(alert_event_integration_policy_id, request, headers, runtime)

    def enable_alert_rule_with_options(
        self,
        request: cms_20240330_models.EnableAlertRuleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.EnableAlertRuleResponse:
        """
        @summary 启用云监控2.0告警规则
        
        @param request: EnableAlertRuleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableAlertRuleResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_rule_ids):
            body['alertRuleIds'] = request.alert_rule_ids
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='EnableAlertRule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules/action/enable',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.EnableAlertRuleResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.EnableAlertRuleResponse(),
                self.execute(params, req, runtime)
            )

    async def enable_alert_rule_with_options_async(
        self,
        request: cms_20240330_models.EnableAlertRuleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.EnableAlertRuleResponse:
        """
        @summary 启用云监控2.0告警规则
        
        @param request: EnableAlertRuleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableAlertRuleResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_rule_ids):
            body['alertRuleIds'] = request.alert_rule_ids
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='EnableAlertRule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules/action/enable',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.EnableAlertRuleResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.EnableAlertRuleResponse(),
                await self.execute_async(params, req, runtime)
            )

    def enable_alert_rule(
        self,
        request: cms_20240330_models.EnableAlertRuleRequest,
    ) -> cms_20240330_models.EnableAlertRuleResponse:
        """
        @summary 启用云监控2.0告警规则
        
        @param request: EnableAlertRuleRequest
        @return: EnableAlertRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.enable_alert_rule_with_options(request, headers, runtime)

    async def enable_alert_rule_async(
        self,
        request: cms_20240330_models.EnableAlertRuleRequest,
    ) -> cms_20240330_models.EnableAlertRuleResponse:
        """
        @summary 启用云监控2.0告警规则
        
        @param request: EnableAlertRuleRequest
        @return: EnableAlertRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.enable_alert_rule_with_options_async(request, headers, runtime)

    def enable_alert_rules_with_options(
        self,
        tmp_req: cms_20240330_models.EnableAlertRulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.EnableAlertRulesResponse:
        """
        @summary 启用云监控2.0告警规则
        
        @param tmp_req: EnableAlertRulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableAlertRulesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.EnableAlertRulesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.alert_rule_ids):
            request.alert_rule_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.alert_rule_ids, 'alertRuleIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_rule_ids_shrink):
            query['alertRuleIds'] = request.alert_rule_ids_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableAlertRules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules/action/enable',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.EnableAlertRulesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.EnableAlertRulesResponse(),
                self.execute(params, req, runtime)
            )

    async def enable_alert_rules_with_options_async(
        self,
        tmp_req: cms_20240330_models.EnableAlertRulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.EnableAlertRulesResponse:
        """
        @summary 启用云监控2.0告警规则
        
        @param tmp_req: EnableAlertRulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableAlertRulesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.EnableAlertRulesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.alert_rule_ids):
            request.alert_rule_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.alert_rule_ids, 'alertRuleIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_rule_ids_shrink):
            query['alertRuleIds'] = request.alert_rule_ids_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableAlertRules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules/action/enable',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.EnableAlertRulesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.EnableAlertRulesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def enable_alert_rules(
        self,
        request: cms_20240330_models.EnableAlertRulesRequest,
    ) -> cms_20240330_models.EnableAlertRulesResponse:
        """
        @summary 启用云监控2.0告警规则
        
        @param request: EnableAlertRulesRequest
        @return: EnableAlertRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.enable_alert_rules_with_options(request, headers, runtime)

    async def enable_alert_rules_async(
        self,
        request: cms_20240330_models.EnableAlertRulesRequest,
    ) -> cms_20240330_models.EnableAlertRulesResponse:
        """
        @summary 启用云监控2.0告警规则
        
        @param request: EnableAlertRulesRequest
        @return: EnableAlertRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.enable_alert_rules_with_options_async(request, headers, runtime)

    def enable_integration_with_options(
        self,
        integration_id: str,
        request: cms_20240330_models.EnableIntegrationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.EnableIntegrationResponse:
        """
        @summary 启动集成
        
        @param request: EnableIntegrationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableIntegrationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableIntegration',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integrations/{OpenApiUtilClient.get_encode_param(integration_id)}/enable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.EnableIntegrationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.EnableIntegrationResponse(),
                self.execute(params, req, runtime)
            )

    async def enable_integration_with_options_async(
        self,
        integration_id: str,
        request: cms_20240330_models.EnableIntegrationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.EnableIntegrationResponse:
        """
        @summary 启动集成
        
        @param request: EnableIntegrationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableIntegrationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableIntegration',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integrations/{OpenApiUtilClient.get_encode_param(integration_id)}/enable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.EnableIntegrationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.EnableIntegrationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def enable_integration(
        self,
        integration_id: str,
        request: cms_20240330_models.EnableIntegrationRequest,
    ) -> cms_20240330_models.EnableIntegrationResponse:
        """
        @summary 启动集成
        
        @param request: EnableIntegrationRequest
        @return: EnableIntegrationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.enable_integration_with_options(integration_id, request, headers, runtime)

    async def enable_integration_async(
        self,
        integration_id: str,
        request: cms_20240330_models.EnableIntegrationRequest,
    ) -> cms_20240330_models.EnableIntegrationResponse:
        """
        @summary 启动集成
        
        @param request: EnableIntegrationRequest
        @return: EnableIntegrationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.enable_integration_with_options_async(integration_id, request, headers, runtime)

    def enable_maintain_window_with_options(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.EnableMaintainWindowRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.EnableMaintainWindowResponse:
        """
        @summary 启动转换器
        
        @param request: EnableMaintainWindowRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableMaintainWindowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableMaintainWindow',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/maintainWindows/{OpenApiUtilClient.get_encode_param(maintain_window_id)}/enable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.EnableMaintainWindowResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.EnableMaintainWindowResponse(),
                self.execute(params, req, runtime)
            )

    async def enable_maintain_window_with_options_async(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.EnableMaintainWindowRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.EnableMaintainWindowResponse:
        """
        @summary 启动转换器
        
        @param request: EnableMaintainWindowRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableMaintainWindowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableMaintainWindow',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/maintainWindows/{OpenApiUtilClient.get_encode_param(maintain_window_id)}/enable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.EnableMaintainWindowResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.EnableMaintainWindowResponse(),
                await self.execute_async(params, req, runtime)
            )

    def enable_maintain_window(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.EnableMaintainWindowRequest,
    ) -> cms_20240330_models.EnableMaintainWindowResponse:
        """
        @summary 启动转换器
        
        @param request: EnableMaintainWindowRequest
        @return: EnableMaintainWindowResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.enable_maintain_window_with_options(maintain_window_id, request, headers, runtime)

    async def enable_maintain_window_async(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.EnableMaintainWindowRequest,
    ) -> cms_20240330_models.EnableMaintainWindowResponse:
        """
        @summary 启动转换器
        
        @param request: EnableMaintainWindowRequest
        @return: EnableMaintainWindowResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.enable_maintain_window_with_options_async(maintain_window_id, request, headers, runtime)

    def enable_notify_strategy_with_options(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.EnableNotifyStrategyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.EnableNotifyStrategyResponse:
        """
        @summary 启动订阅
        
        @param request: EnableNotifyStrategyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableNotifyStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableNotifyStrategy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/notifyStrategies/{OpenApiUtilClient.get_encode_param(notify_strategy_id)}/enable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.EnableNotifyStrategyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.EnableNotifyStrategyResponse(),
                self.execute(params, req, runtime)
            )

    async def enable_notify_strategy_with_options_async(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.EnableNotifyStrategyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.EnableNotifyStrategyResponse:
        """
        @summary 启动订阅
        
        @param request: EnableNotifyStrategyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableNotifyStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableNotifyStrategy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/notifyStrategies/{OpenApiUtilClient.get_encode_param(notify_strategy_id)}/enable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.EnableNotifyStrategyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.EnableNotifyStrategyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def enable_notify_strategy(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.EnableNotifyStrategyRequest,
    ) -> cms_20240330_models.EnableNotifyStrategyResponse:
        """
        @summary 启动订阅
        
        @param request: EnableNotifyStrategyRequest
        @return: EnableNotifyStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.enable_notify_strategy_with_options(notify_strategy_id, request, headers, runtime)

    async def enable_notify_strategy_async(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.EnableNotifyStrategyRequest,
    ) -> cms_20240330_models.EnableNotifyStrategyResponse:
        """
        @summary 启动订阅
        
        @param request: EnableNotifyStrategyRequest
        @return: EnableNotifyStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.enable_notify_strategy_with_options_async(notify_strategy_id, request, headers, runtime)

    def enable_subscription_with_options(
        self,
        subscription_id: str,
        request: cms_20240330_models.EnableSubscriptionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.EnableSubscriptionResponse:
        """
        @summary 启动订阅
        
        @param request: EnableSubscriptionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableSubscriptionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableSubscription',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/subscriptions/{OpenApiUtilClient.get_encode_param(subscription_id)}/enable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.EnableSubscriptionResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.EnableSubscriptionResponse(),
                self.execute(params, req, runtime)
            )

    async def enable_subscription_with_options_async(
        self,
        subscription_id: str,
        request: cms_20240330_models.EnableSubscriptionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.EnableSubscriptionResponse:
        """
        @summary 启动订阅
        
        @param request: EnableSubscriptionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableSubscriptionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableSubscription',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/subscriptions/{OpenApiUtilClient.get_encode_param(subscription_id)}/enable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.EnableSubscriptionResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.EnableSubscriptionResponse(),
                await self.execute_async(params, req, runtime)
            )

    def enable_subscription(
        self,
        subscription_id: str,
        request: cms_20240330_models.EnableSubscriptionRequest,
    ) -> cms_20240330_models.EnableSubscriptionResponse:
        """
        @summary 启动订阅
        
        @param request: EnableSubscriptionRequest
        @return: EnableSubscriptionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.enable_subscription_with_options(subscription_id, request, headers, runtime)

    async def enable_subscription_async(
        self,
        subscription_id: str,
        request: cms_20240330_models.EnableSubscriptionRequest,
    ) -> cms_20240330_models.EnableSubscriptionResponse:
        """
        @summary 启动订阅
        
        @param request: EnableSubscriptionRequest
        @return: EnableSubscriptionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.enable_subscription_with_options_async(subscription_id, request, headers, runtime)

    def enable_transformer_with_options(
        self,
        transformer_id: str,
        request: cms_20240330_models.EnableTransformerRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.EnableTransformerResponse:
        """
        @summary 启动转换器
        
        @param request: EnableTransformerRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableTransformerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableTransformer',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/transformers/{OpenApiUtilClient.get_encode_param(transformer_id)}/enable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.EnableTransformerResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.EnableTransformerResponse(),
                self.execute(params, req, runtime)
            )

    async def enable_transformer_with_options_async(
        self,
        transformer_id: str,
        request: cms_20240330_models.EnableTransformerRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.EnableTransformerResponse:
        """
        @summary 启动转换器
        
        @param request: EnableTransformerRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: EnableTransformerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='EnableTransformer',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/transformers/{OpenApiUtilClient.get_encode_param(transformer_id)}/enable',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.EnableTransformerResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.EnableTransformerResponse(),
                await self.execute_async(params, req, runtime)
            )

    def enable_transformer(
        self,
        transformer_id: str,
        request: cms_20240330_models.EnableTransformerRequest,
    ) -> cms_20240330_models.EnableTransformerResponse:
        """
        @summary 启动转换器
        
        @param request: EnableTransformerRequest
        @return: EnableTransformerResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.enable_transformer_with_options(transformer_id, request, headers, runtime)

    async def enable_transformer_async(
        self,
        transformer_id: str,
        request: cms_20240330_models.EnableTransformerRequest,
    ) -> cms_20240330_models.EnableTransformerResponse:
        """
        @summary 启动转换器
        
        @param request: EnableTransformerRequest
        @return: EnableTransformerResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.enable_transformer_with_options_async(transformer_id, request, headers, runtime)

    def get_addon_with_options(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAddonResponse:
        """
        @summary 插件详情(Addon)
        
        @param request: GetAddonRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAddonResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAddon',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addons/{OpenApiUtilClient.get_encode_param(addon_name)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAddonResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAddonResponse(),
                self.execute(params, req, runtime)
            )

    async def get_addon_with_options_async(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAddonResponse:
        """
        @summary 插件详情(Addon)
        
        @param request: GetAddonRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAddonResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAddon',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addons/{OpenApiUtilClient.get_encode_param(addon_name)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAddonResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAddonResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_addon(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonRequest,
    ) -> cms_20240330_models.GetAddonResponse:
        """
        @summary 插件详情(Addon)
        
        @param request: GetAddonRequest
        @return: GetAddonResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_addon_with_options(addon_name, request, headers, runtime)

    async def get_addon_async(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonRequest,
    ) -> cms_20240330_models.GetAddonResponse:
        """
        @summary 插件详情(Addon)
        
        @param request: GetAddonRequest
        @return: GetAddonResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_addon_with_options_async(addon_name, request, headers, runtime)

    def get_addon_alert_templates_with_options(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonAlertTemplatesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAddonAlertTemplatesResponse:
        """
        @summary 插件metrics详情(Addon)
        
        @param request: GetAddonAlertTemplatesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAddonAlertTemplatesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_version):
            query['addonVersion'] = request.addon_version
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_type):
            query['environmentType'] = request.environment_type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAddonAlertTemplates',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addons/{OpenApiUtilClient.get_encode_param(addon_name)}/alert-templates',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAddonAlertTemplatesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAddonAlertTemplatesResponse(),
                self.execute(params, req, runtime)
            )

    async def get_addon_alert_templates_with_options_async(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonAlertTemplatesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAddonAlertTemplatesResponse:
        """
        @summary 插件metrics详情(Addon)
        
        @param request: GetAddonAlertTemplatesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAddonAlertTemplatesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_version):
            query['addonVersion'] = request.addon_version
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_type):
            query['environmentType'] = request.environment_type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAddonAlertTemplates',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addons/{OpenApiUtilClient.get_encode_param(addon_name)}/alert-templates',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAddonAlertTemplatesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAddonAlertTemplatesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_addon_alert_templates(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonAlertTemplatesRequest,
    ) -> cms_20240330_models.GetAddonAlertTemplatesResponse:
        """
        @summary 插件metrics详情(Addon)
        
        @param request: GetAddonAlertTemplatesRequest
        @return: GetAddonAlertTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_addon_alert_templates_with_options(addon_name, request, headers, runtime)

    async def get_addon_alert_templates_async(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonAlertTemplatesRequest,
    ) -> cms_20240330_models.GetAddonAlertTemplatesResponse:
        """
        @summary 插件metrics详情(Addon)
        
        @param request: GetAddonAlertTemplatesRequest
        @return: GetAddonAlertTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_addon_alert_templates_with_options_async(addon_name, request, headers, runtime)

    def get_addon_code_template_with_options(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonCodeTemplateRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAddonCodeTemplateResponse:
        """
        @summary 插件schema详情(Addon)
        
        @param request: GetAddonCodeTemplateRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAddonCodeTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_type):
            query['environmentType'] = request.environment_type
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAddonCodeTemplate',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addons/{OpenApiUtilClient.get_encode_param(addon_name)}/alert-code-template',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAddonCodeTemplateResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAddonCodeTemplateResponse(),
                self.execute(params, req, runtime)
            )

    async def get_addon_code_template_with_options_async(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonCodeTemplateRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAddonCodeTemplateResponse:
        """
        @summary 插件schema详情(Addon)
        
        @param request: GetAddonCodeTemplateRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAddonCodeTemplateResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_type):
            query['environmentType'] = request.environment_type
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAddonCodeTemplate',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addons/{OpenApiUtilClient.get_encode_param(addon_name)}/alert-code-template',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAddonCodeTemplateResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAddonCodeTemplateResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_addon_code_template(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonCodeTemplateRequest,
    ) -> cms_20240330_models.GetAddonCodeTemplateResponse:
        """
        @summary 插件schema详情(Addon)
        
        @param request: GetAddonCodeTemplateRequest
        @return: GetAddonCodeTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_addon_code_template_with_options(addon_name, request, headers, runtime)

    async def get_addon_code_template_async(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonCodeTemplateRequest,
    ) -> cms_20240330_models.GetAddonCodeTemplateResponse:
        """
        @summary 插件schema详情(Addon)
        
        @param request: GetAddonCodeTemplateRequest
        @return: GetAddonCodeTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_addon_code_template_with_options_async(addon_name, request, headers, runtime)

    def get_addon_metrics_with_options(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonMetricsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAddonMetricsResponse:
        """
        @summary 插件metrics详情(Addon)
        
        @param request: GetAddonMetricsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAddonMetricsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_type):
            query['environmentType'] = request.environment_type
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAddonMetrics',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addons/{OpenApiUtilClient.get_encode_param(addon_name)}/metrics',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAddonMetricsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAddonMetricsResponse(),
                self.execute(params, req, runtime)
            )

    async def get_addon_metrics_with_options_async(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonMetricsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAddonMetricsResponse:
        """
        @summary 插件metrics详情(Addon)
        
        @param request: GetAddonMetricsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAddonMetricsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_type):
            query['environmentType'] = request.environment_type
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAddonMetrics',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addons/{OpenApiUtilClient.get_encode_param(addon_name)}/metrics',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAddonMetricsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAddonMetricsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_addon_metrics(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonMetricsRequest,
    ) -> cms_20240330_models.GetAddonMetricsResponse:
        """
        @summary 插件metrics详情(Addon)
        
        @param request: GetAddonMetricsRequest
        @return: GetAddonMetricsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_addon_metrics_with_options(addon_name, request, headers, runtime)

    async def get_addon_metrics_async(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonMetricsRequest,
    ) -> cms_20240330_models.GetAddonMetricsResponse:
        """
        @summary 插件metrics详情(Addon)
        
        @param request: GetAddonMetricsRequest
        @return: GetAddonMetricsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_addon_metrics_with_options_async(addon_name, request, headers, runtime)

    def get_addon_release_with_options(
        self,
        release_name: str,
        policy_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAddonReleaseResponse:
        """
        @summary 查看addon release(查看接入状态)
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAddonReleaseResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetAddonRelease',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/addon-releases/{OpenApiUtilClient.get_encode_param(release_name)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAddonReleaseResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAddonReleaseResponse(),
                self.execute(params, req, runtime)
            )

    async def get_addon_release_with_options_async(
        self,
        release_name: str,
        policy_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAddonReleaseResponse:
        """
        @summary 查看addon release(查看接入状态)
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAddonReleaseResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetAddonRelease',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/addon-releases/{OpenApiUtilClient.get_encode_param(release_name)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAddonReleaseResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAddonReleaseResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_addon_release(
        self,
        release_name: str,
        policy_id: str,
    ) -> cms_20240330_models.GetAddonReleaseResponse:
        """
        @summary 查看addon release(查看接入状态)
        
        @return: GetAddonReleaseResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_addon_release_with_options(release_name, policy_id, headers, runtime)

    async def get_addon_release_async(
        self,
        release_name: str,
        policy_id: str,
    ) -> cms_20240330_models.GetAddonReleaseResponse:
        """
        @summary 查看addon release(查看接入状态)
        
        @return: GetAddonReleaseResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_addon_release_with_options_async(release_name, policy_id, headers, runtime)

    def get_addon_schema_with_options(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonSchemaRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAddonSchemaResponse:
        """
        @summary 插件schema详情(Addon)
        
        @param request: GetAddonSchemaRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAddonSchemaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_type):
            query['environmentType'] = request.environment_type
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAddonSchema',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addons/{OpenApiUtilClient.get_encode_param(addon_name)}/schema',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAddonSchemaResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAddonSchemaResponse(),
                self.execute(params, req, runtime)
            )

    async def get_addon_schema_with_options_async(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonSchemaRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAddonSchemaResponse:
        """
        @summary 插件schema详情(Addon)
        
        @param request: GetAddonSchemaRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAddonSchemaResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_type):
            query['environmentType'] = request.environment_type
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAddonSchema',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addons/{OpenApiUtilClient.get_encode_param(addon_name)}/schema',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAddonSchemaResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAddonSchemaResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_addon_schema(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonSchemaRequest,
    ) -> cms_20240330_models.GetAddonSchemaResponse:
        """
        @summary 插件schema详情(Addon)
        
        @param request: GetAddonSchemaRequest
        @return: GetAddonSchemaResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_addon_schema_with_options(addon_name, request, headers, runtime)

    async def get_addon_schema_async(
        self,
        addon_name: str,
        request: cms_20240330_models.GetAddonSchemaRequest,
    ) -> cms_20240330_models.GetAddonSchemaResponse:
        """
        @summary 插件schema详情(Addon)
        
        @param request: GetAddonSchemaRequest
        @return: GetAddonSchemaResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_addon_schema_with_options_async(addon_name, request, headers, runtime)

    def get_agg_task_group_with_options(
        self,
        instance_id: str,
        group_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAggTaskGroupResponse:
        """
        @summary 描述聚合任务组
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAggTaskGroupResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetAggTaskGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(instance_id)}/agg-task-groups/{OpenApiUtilClient.get_encode_param(group_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAggTaskGroupResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAggTaskGroupResponse(),
                self.execute(params, req, runtime)
            )

    async def get_agg_task_group_with_options_async(
        self,
        instance_id: str,
        group_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAggTaskGroupResponse:
        """
        @summary 描述聚合任务组
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAggTaskGroupResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetAggTaskGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(instance_id)}/agg-task-groups/{OpenApiUtilClient.get_encode_param(group_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAggTaskGroupResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAggTaskGroupResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_agg_task_group(
        self,
        instance_id: str,
        group_id: str,
    ) -> cms_20240330_models.GetAggTaskGroupResponse:
        """
        @summary 描述聚合任务组
        
        @return: GetAggTaskGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_agg_task_group_with_options(instance_id, group_id, headers, runtime)

    async def get_agg_task_group_async(
        self,
        instance_id: str,
        group_id: str,
    ) -> cms_20240330_models.GetAggTaskGroupResponse:
        """
        @summary 描述聚合任务组
        
        @return: GetAggTaskGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_agg_task_group_with_options_async(instance_id, group_id, headers, runtime)

    def get_alert_action_with_options(
        self,
        alert_action_id: str,
        request: cms_20240330_models.GetAlertActionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAlertActionResponse:
        """
        @summary 查询告警动作
        
        @param request: GetAlertActionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAlertActionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAlertAction',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertAction/{OpenApiUtilClient.get_encode_param(alert_action_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAlertActionResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAlertActionResponse(),
                self.execute(params, req, runtime)
            )

    async def get_alert_action_with_options_async(
        self,
        alert_action_id: str,
        request: cms_20240330_models.GetAlertActionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAlertActionResponse:
        """
        @summary 查询告警动作
        
        @param request: GetAlertActionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAlertActionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAlertAction',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertAction/{OpenApiUtilClient.get_encode_param(alert_action_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAlertActionResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAlertActionResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_alert_action(
        self,
        alert_action_id: str,
        request: cms_20240330_models.GetAlertActionRequest,
    ) -> cms_20240330_models.GetAlertActionResponse:
        """
        @summary 查询告警动作
        
        @param request: GetAlertActionRequest
        @return: GetAlertActionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_alert_action_with_options(alert_action_id, request, headers, runtime)

    async def get_alert_action_async(
        self,
        alert_action_id: str,
        request: cms_20240330_models.GetAlertActionRequest,
    ) -> cms_20240330_models.GetAlertActionResponse:
        """
        @summary 查询告警动作
        
        @param request: GetAlertActionRequest
        @return: GetAlertActionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_alert_action_with_options_async(alert_action_id, request, headers, runtime)

    def get_alert_event_integration_policy_with_options(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.GetAlertEventIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAlertEventIntegrationPolicyResponse:
        """
        @summary 获取订阅
        
        @param request: GetAlertEventIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAlertEventIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAlertEventIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertEventIntegrationPolicies/{OpenApiUtilClient.get_encode_param(alert_event_integration_policy_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAlertEventIntegrationPolicyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAlertEventIntegrationPolicyResponse(),
                self.execute(params, req, runtime)
            )

    async def get_alert_event_integration_policy_with_options_async(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.GetAlertEventIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetAlertEventIntegrationPolicyResponse:
        """
        @summary 获取订阅
        
        @param request: GetAlertEventIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetAlertEventIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetAlertEventIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertEventIntegrationPolicies/{OpenApiUtilClient.get_encode_param(alert_event_integration_policy_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetAlertEventIntegrationPolicyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetAlertEventIntegrationPolicyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_alert_event_integration_policy(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.GetAlertEventIntegrationPolicyRequest,
    ) -> cms_20240330_models.GetAlertEventIntegrationPolicyResponse:
        """
        @summary 获取订阅
        
        @param request: GetAlertEventIntegrationPolicyRequest
        @return: GetAlertEventIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_alert_event_integration_policy_with_options(alert_event_integration_policy_id, request, headers, runtime)

    async def get_alert_event_integration_policy_async(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.GetAlertEventIntegrationPolicyRequest,
    ) -> cms_20240330_models.GetAlertEventIntegrationPolicyResponse:
        """
        @summary 获取订阅
        
        @param request: GetAlertEventIntegrationPolicyRequest
        @return: GetAlertEventIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_alert_event_integration_policy_with_options_async(alert_event_integration_policy_id, request, headers, runtime)

    def get_biz_trace_with_options(
        self,
        biz_trace_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetBizTraceResponse:
        """
        @summary 查询业务链路
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetBizTraceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetBizTrace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/bizTrace/{OpenApiUtilClient.get_encode_param(biz_trace_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetBizTraceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetBizTraceResponse(),
                self.execute(params, req, runtime)
            )

    async def get_biz_trace_with_options_async(
        self,
        biz_trace_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetBizTraceResponse:
        """
        @summary 查询业务链路
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetBizTraceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetBizTrace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/bizTrace/{OpenApiUtilClient.get_encode_param(biz_trace_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetBizTraceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetBizTraceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_biz_trace(
        self,
        biz_trace_id: str,
    ) -> cms_20240330_models.GetBizTraceResponse:
        """
        @summary 查询业务链路
        
        @return: GetBizTraceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_biz_trace_with_options(biz_trace_id, headers, runtime)

    async def get_biz_trace_async(
        self,
        biz_trace_id: str,
    ) -> cms_20240330_models.GetBizTraceResponse:
        """
        @summary 查询业务链路
        
        @return: GetBizTraceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_biz_trace_with_options_async(biz_trace_id, headers, runtime)

    def get_cloud_environment_id_with_options(
        self,
        request: cms_20240330_models.GetCloudEnvironmentIdRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetCloudEnvironmentIdResponse:
        """
        @summary 获取云服务实例的Id
        
        @param request: GetCloudEnvironmentIdRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCloudEnvironmentIdResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetCloudEnvironmentId',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/GetCloudEnvironmentId',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetCloudEnvironmentIdResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetCloudEnvironmentIdResponse(),
                self.execute(params, req, runtime)
            )

    async def get_cloud_environment_id_with_options_async(
        self,
        request: cms_20240330_models.GetCloudEnvironmentIdRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetCloudEnvironmentIdResponse:
        """
        @summary 获取云服务实例的Id
        
        @param request: GetCloudEnvironmentIdRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCloudEnvironmentIdResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetCloudEnvironmentId',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/GetCloudEnvironmentId',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetCloudEnvironmentIdResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetCloudEnvironmentIdResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_cloud_environment_id(
        self,
        request: cms_20240330_models.GetCloudEnvironmentIdRequest,
    ) -> cms_20240330_models.GetCloudEnvironmentIdResponse:
        """
        @summary 获取云服务实例的Id
        
        @param request: GetCloudEnvironmentIdRequest
        @return: GetCloudEnvironmentIdResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_cloud_environment_id_with_options(request, headers, runtime)

    async def get_cloud_environment_id_async(
        self,
        request: cms_20240330_models.GetCloudEnvironmentIdRequest,
    ) -> cms_20240330_models.GetCloudEnvironmentIdResponse:
        """
        @summary 获取云服务实例的Id
        
        @param request: GetCloudEnvironmentIdRequest
        @return: GetCloudEnvironmentIdResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_cloud_environment_id_with_options_async(request, headers, runtime)

    def get_cloud_resource_with_options(
        self,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetCloudResourceResponse:
        """
        @summary 查询云资源中心
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCloudResourceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetCloudResource',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/cloudresource',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetCloudResourceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetCloudResourceResponse(),
                self.execute(params, req, runtime)
            )

    async def get_cloud_resource_with_options_async(
        self,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetCloudResourceResponse:
        """
        @summary 查询云资源中心
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCloudResourceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetCloudResource',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/cloudresource',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetCloudResourceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetCloudResourceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_cloud_resource(self) -> cms_20240330_models.GetCloudResourceResponse:
        """
        @summary 查询云资源中心
        
        @return: GetCloudResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_cloud_resource_with_options(headers, runtime)

    async def get_cloud_resource_async(self) -> cms_20240330_models.GetCloudResourceResponse:
        """
        @summary 查询云资源中心
        
        @return: GetCloudResourceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_cloud_resource_with_options_async(headers, runtime)

    def get_cloud_resource_data_with_options(
        self,
        request: cms_20240330_models.GetCloudResourceDataRequest,
        headers: cms_20240330_models.GetCloudResourceDataHeaders,
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetCloudResourceDataResponse:
        """
        @summary 查询云资源中心数据
        
        @param request: GetCloudResourceDataRequest
        @param headers: GetCloudResourceDataHeaders
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCloudResourceDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.from_):
            query['from'] = request.from_
        if not UtilClient.is_unset(request.query):
            query['query'] = request.query
        if not UtilClient.is_unset(request.to):
            query['to'] = request.to
        real_headers = {}
        if not UtilClient.is_unset(headers.common_headers):
            real_headers = headers.common_headers
        if not UtilClient.is_unset(headers.accept_encoding):
            real_headers['Accept-Encoding'] = UtilClient.to_jsonstring(headers.accept_encoding)
        req = open_api_models.OpenApiRequest(
            headers=real_headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetCloudResourceData',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/cloudresource/data',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetCloudResourceDataResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetCloudResourceDataResponse(),
                self.execute(params, req, runtime)
            )

    async def get_cloud_resource_data_with_options_async(
        self,
        request: cms_20240330_models.GetCloudResourceDataRequest,
        headers: cms_20240330_models.GetCloudResourceDataHeaders,
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetCloudResourceDataResponse:
        """
        @summary 查询云资源中心数据
        
        @param request: GetCloudResourceDataRequest
        @param headers: GetCloudResourceDataHeaders
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCloudResourceDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.from_):
            query['from'] = request.from_
        if not UtilClient.is_unset(request.query):
            query['query'] = request.query
        if not UtilClient.is_unset(request.to):
            query['to'] = request.to
        real_headers = {}
        if not UtilClient.is_unset(headers.common_headers):
            real_headers = headers.common_headers
        if not UtilClient.is_unset(headers.accept_encoding):
            real_headers['Accept-Encoding'] = UtilClient.to_jsonstring(headers.accept_encoding)
        req = open_api_models.OpenApiRequest(
            headers=real_headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetCloudResourceData',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/cloudresource/data',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetCloudResourceDataResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetCloudResourceDataResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_cloud_resource_data(
        self,
        request: cms_20240330_models.GetCloudResourceDataRequest,
    ) -> cms_20240330_models.GetCloudResourceDataResponse:
        """
        @summary 查询云资源中心数据
        
        @param request: GetCloudResourceDataRequest
        @return: GetCloudResourceDataResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = cms_20240330_models.GetCloudResourceDataHeaders()
        return self.get_cloud_resource_data_with_options(request, headers, runtime)

    async def get_cloud_resource_data_async(
        self,
        request: cms_20240330_models.GetCloudResourceDataRequest,
    ) -> cms_20240330_models.GetCloudResourceDataResponse:
        """
        @summary 查询云资源中心数据
        
        @param request: GetCloudResourceDataRequest
        @return: GetCloudResourceDataResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = cms_20240330_models.GetCloudResourceDataHeaders()
        return await self.get_cloud_resource_data_with_options_async(request, headers, runtime)

    def get_cms_service_with_options(
        self,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetCmsServiceResponse:
        """
        @summary 获取云监控开通状态
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCmsServiceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetCmsService',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/cmsservice',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetCmsServiceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetCmsServiceResponse(),
                self.execute(params, req, runtime)
            )

    async def get_cms_service_with_options_async(
        self,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetCmsServiceResponse:
        """
        @summary 获取云监控开通状态
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetCmsServiceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetCmsService',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/cmsservice',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetCmsServiceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetCmsServiceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_cms_service(self) -> cms_20240330_models.GetCmsServiceResponse:
        """
        @summary 获取云监控开通状态
        
        @return: GetCmsServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_cms_service_with_options(headers, runtime)

    async def get_cms_service_async(self) -> cms_20240330_models.GetCmsServiceResponse:
        """
        @summary 获取云监控开通状态
        
        @return: GetCmsServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_cms_service_with_options_async(headers, runtime)

    def get_entity_group_with_options(
        self,
        entity_group_id: str,
        request: cms_20240330_models.GetEntityGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetEntityGroupResponse:
        """
        @summary 获取实体组
        
        @param request: GetEntityGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEntityGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEntityGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/entity-groups/{OpenApiUtilClient.get_encode_param(entity_group_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetEntityGroupResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetEntityGroupResponse(),
                self.execute(params, req, runtime)
            )

    async def get_entity_group_with_options_async(
        self,
        entity_group_id: str,
        request: cms_20240330_models.GetEntityGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetEntityGroupResponse:
        """
        @summary 获取实体组
        
        @param request: GetEntityGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEntityGroupResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEntityGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/entity-groups/{OpenApiUtilClient.get_encode_param(entity_group_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetEntityGroupResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetEntityGroupResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_entity_group(
        self,
        entity_group_id: str,
        request: cms_20240330_models.GetEntityGroupRequest,
    ) -> cms_20240330_models.GetEntityGroupResponse:
        """
        @summary 获取实体组
        
        @param request: GetEntityGroupRequest
        @return: GetEntityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_entity_group_with_options(entity_group_id, request, headers, runtime)

    async def get_entity_group_async(
        self,
        entity_group_id: str,
        request: cms_20240330_models.GetEntityGroupRequest,
    ) -> cms_20240330_models.GetEntityGroupResponse:
        """
        @summary 获取实体组
        
        @param request: GetEntityGroupRequest
        @return: GetEntityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_entity_group_with_options_async(entity_group_id, request, headers, runtime)

    def get_entity_store_with_options(
        self,
        workspace_name: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetEntityStoreResponse:
        """
        @summary 获取EntityStore相关存储信息
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEntityStoreResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetEntityStore',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace_name)}/entitystore',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetEntityStoreResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetEntityStoreResponse(),
                self.execute(params, req, runtime)
            )

    async def get_entity_store_with_options_async(
        self,
        workspace_name: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetEntityStoreResponse:
        """
        @summary 获取EntityStore相关存储信息
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEntityStoreResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetEntityStore',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace_name)}/entitystore',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetEntityStoreResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetEntityStoreResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_entity_store(
        self,
        workspace_name: str,
    ) -> cms_20240330_models.GetEntityStoreResponse:
        """
        @summary 获取EntityStore相关存储信息
        
        @return: GetEntityStoreResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_entity_store_with_options(workspace_name, headers, runtime)

    async def get_entity_store_async(
        self,
        workspace_name: str,
    ) -> cms_20240330_models.GetEntityStoreResponse:
        """
        @summary 获取EntityStore相关存储信息
        
        @return: GetEntityStoreResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_entity_store_with_options_async(workspace_name, headers, runtime)

    def get_entity_store_data_with_options(
        self,
        workspace: str,
        request: cms_20240330_models.GetEntityStoreDataRequest,
        headers: cms_20240330_models.GetEntityStoreDataHeaders,
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetEntityStoreDataResponse:
        """
        @summary 查询指定Workspace下的实体和关系数据，返回结果显示某时间区间中的实体数据（返回结果压缩后传输）。
        
        @param request: GetEntityStoreDataRequest
        @param headers: GetEntityStoreDataHeaders
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEntityStoreDataResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.from_):
            body['from'] = request.from_
        if not UtilClient.is_unset(request.query):
            body['query'] = request.query
        if not UtilClient.is_unset(request.to):
            body['to'] = request.to
        real_headers = {}
        if not UtilClient.is_unset(headers.common_headers):
            real_headers = headers.common_headers
        if not UtilClient.is_unset(headers.accept_encoding):
            real_headers['acceptEncoding'] = UtilClient.to_jsonstring(headers.accept_encoding)
        req = open_api_models.OpenApiRequest(
            headers=real_headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetEntityStoreData',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/entitiesAndRelations',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetEntityStoreDataResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetEntityStoreDataResponse(),
                self.execute(params, req, runtime)
            )

    async def get_entity_store_data_with_options_async(
        self,
        workspace: str,
        request: cms_20240330_models.GetEntityStoreDataRequest,
        headers: cms_20240330_models.GetEntityStoreDataHeaders,
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetEntityStoreDataResponse:
        """
        @summary 查询指定Workspace下的实体和关系数据，返回结果显示某时间区间中的实体数据（返回结果压缩后传输）。
        
        @param request: GetEntityStoreDataRequest
        @param headers: GetEntityStoreDataHeaders
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEntityStoreDataResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.from_):
            body['from'] = request.from_
        if not UtilClient.is_unset(request.query):
            body['query'] = request.query
        if not UtilClient.is_unset(request.to):
            body['to'] = request.to
        real_headers = {}
        if not UtilClient.is_unset(headers.common_headers):
            real_headers = headers.common_headers
        if not UtilClient.is_unset(headers.accept_encoding):
            real_headers['acceptEncoding'] = UtilClient.to_jsonstring(headers.accept_encoding)
        req = open_api_models.OpenApiRequest(
            headers=real_headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetEntityStoreData',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/entitiesAndRelations',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetEntityStoreDataResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetEntityStoreDataResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_entity_store_data(
        self,
        workspace: str,
        request: cms_20240330_models.GetEntityStoreDataRequest,
    ) -> cms_20240330_models.GetEntityStoreDataResponse:
        """
        @summary 查询指定Workspace下的实体和关系数据，返回结果显示某时间区间中的实体数据（返回结果压缩后传输）。
        
        @param request: GetEntityStoreDataRequest
        @return: GetEntityStoreDataResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = cms_20240330_models.GetEntityStoreDataHeaders()
        return self.get_entity_store_data_with_options(workspace, request, headers, runtime)

    async def get_entity_store_data_async(
        self,
        workspace: str,
        request: cms_20240330_models.GetEntityStoreDataRequest,
    ) -> cms_20240330_models.GetEntityStoreDataResponse:
        """
        @summary 查询指定Workspace下的实体和关系数据，返回结果显示某时间区间中的实体数据（返回结果压缩后传输）。
        
        @param request: GetEntityStoreDataRequest
        @return: GetEntityStoreDataResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = cms_20240330_models.GetEntityStoreDataHeaders()
        return await self.get_entity_store_data_with_options_async(workspace, request, headers, runtime)

    def get_environment_count_with_options(
        self,
        request: cms_20240330_models.GetEnvironmentCountRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetEnvironmentCountResponse:
        """
        @summary 查询所有环境实例数量
        
        @param request: GetEnvironmentCountRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEnvironmentCountResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEnvironmentCount',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/GetEnvironmentCount',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetEnvironmentCountResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetEnvironmentCountResponse(),
                self.execute(params, req, runtime)
            )

    async def get_environment_count_with_options_async(
        self,
        request: cms_20240330_models.GetEnvironmentCountRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetEnvironmentCountResponse:
        """
        @summary 查询所有环境实例数量
        
        @param request: GetEnvironmentCountRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEnvironmentCountResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEnvironmentCount',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/GetEnvironmentCount',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetEnvironmentCountResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetEnvironmentCountResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_environment_count(
        self,
        request: cms_20240330_models.GetEnvironmentCountRequest,
    ) -> cms_20240330_models.GetEnvironmentCountResponse:
        """
        @summary 查询所有环境实例数量
        
        @param request: GetEnvironmentCountRequest
        @return: GetEnvironmentCountResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_environment_count_with_options(request, headers, runtime)

    async def get_environment_count_async(
        self,
        request: cms_20240330_models.GetEnvironmentCountRequest,
    ) -> cms_20240330_models.GetEnvironmentCountResponse:
        """
        @summary 查询所有环境实例数量
        
        @param request: GetEnvironmentCountRequest
        @return: GetEnvironmentCountResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_environment_count_with_options_async(request, headers, runtime)

    def get_environment_discovery_status_with_options(
        self,
        request: cms_20240330_models.GetEnvironmentDiscoveryStatusRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetEnvironmentDiscoveryStatusResponse:
        """
        @summary 获取环境中服务发现状态
        
        @param request: GetEnvironmentDiscoveryStatusRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEnvironmentDiscoveryStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEnvironmentDiscoveryStatus',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/GetEnvironmentDiscoveryStatus',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetEnvironmentDiscoveryStatusResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetEnvironmentDiscoveryStatusResponse(),
                self.execute(params, req, runtime)
            )

    async def get_environment_discovery_status_with_options_async(
        self,
        request: cms_20240330_models.GetEnvironmentDiscoveryStatusRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetEnvironmentDiscoveryStatusResponse:
        """
        @summary 获取环境中服务发现状态
        
        @param request: GetEnvironmentDiscoveryStatusRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEnvironmentDiscoveryStatusResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEnvironmentDiscoveryStatus',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/GetEnvironmentDiscoveryStatus',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetEnvironmentDiscoveryStatusResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetEnvironmentDiscoveryStatusResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_environment_discovery_status(
        self,
        request: cms_20240330_models.GetEnvironmentDiscoveryStatusRequest,
    ) -> cms_20240330_models.GetEnvironmentDiscoveryStatusResponse:
        """
        @summary 获取环境中服务发现状态
        
        @param request: GetEnvironmentDiscoveryStatusRequest
        @return: GetEnvironmentDiscoveryStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_environment_discovery_status_with_options(request, headers, runtime)

    async def get_environment_discovery_status_async(
        self,
        request: cms_20240330_models.GetEnvironmentDiscoveryStatusRequest,
    ) -> cms_20240330_models.GetEnvironmentDiscoveryStatusResponse:
        """
        @summary 获取环境中服务发现状态
        
        @param request: GetEnvironmentDiscoveryStatusRequest
        @return: GetEnvironmentDiscoveryStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_environment_discovery_status_with_options_async(request, headers, runtime)

    def get_escalation_with_options(
        self,
        uuid: str,
        request: cms_20240330_models.GetEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetEscalationResponse:
        """
        @summary 获取订阅
        
        @param request: GetEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/escalations/{OpenApiUtilClient.get_encode_param(uuid)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetEscalationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetEscalationResponse(),
                self.execute(params, req, runtime)
            )

    async def get_escalation_with_options_async(
        self,
        uuid: str,
        request: cms_20240330_models.GetEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetEscalationResponse:
        """
        @summary 获取订阅
        
        @param request: GetEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/escalations/{OpenApiUtilClient.get_encode_param(uuid)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetEscalationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetEscalationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_escalation(
        self,
        uuid: str,
        request: cms_20240330_models.GetEscalationRequest,
    ) -> cms_20240330_models.GetEscalationResponse:
        """
        @summary 获取订阅
        
        @param request: GetEscalationRequest
        @return: GetEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_escalation_with_options(uuid, request, headers, runtime)

    async def get_escalation_async(
        self,
        uuid: str,
        request: cms_20240330_models.GetEscalationRequest,
    ) -> cms_20240330_models.GetEscalationResponse:
        """
        @summary 获取订阅
        
        @param request: GetEscalationRequest
        @return: GetEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_escalation_with_options_async(uuid, request, headers, runtime)

    def get_incident_with_options(
        self,
        request: cms_20240330_models.GetIncidentRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetIncidentResponse:
        """
        @summary 查询一个Incident
        
        @param request: GetIncidentRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIncidentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetIncident',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/get',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetIncidentResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetIncidentResponse(),
                self.execute(params, req, runtime)
            )

    async def get_incident_with_options_async(
        self,
        request: cms_20240330_models.GetIncidentRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetIncidentResponse:
        """
        @summary 查询一个Incident
        
        @param request: GetIncidentRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIncidentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetIncident',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/get',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetIncidentResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetIncidentResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_incident(
        self,
        request: cms_20240330_models.GetIncidentRequest,
    ) -> cms_20240330_models.GetIncidentResponse:
        """
        @summary 查询一个Incident
        
        @param request: GetIncidentRequest
        @return: GetIncidentResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_incident_with_options(request, headers, runtime)

    async def get_incident_async(
        self,
        request: cms_20240330_models.GetIncidentRequest,
    ) -> cms_20240330_models.GetIncidentResponse:
        """
        @summary 查询一个Incident
        
        @param request: GetIncidentRequest
        @return: GetIncidentResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_incident_with_options_async(request, headers, runtime)

    def get_incident_escalation_with_options(
        self,
        request: cms_20240330_models.GetIncidentEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetIncidentEscalationResponse:
        """
        @summary 获取一个Incident 升级计划
        
        @param request: GetIncidentEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIncidentEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_escalation_id):
            query['incidentEscalationId'] = request.incident_escalation_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetIncidentEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/escalation/get',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetIncidentEscalationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetIncidentEscalationResponse(),
                self.execute(params, req, runtime)
            )

    async def get_incident_escalation_with_options_async(
        self,
        request: cms_20240330_models.GetIncidentEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetIncidentEscalationResponse:
        """
        @summary 获取一个Incident 升级计划
        
        @param request: GetIncidentEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIncidentEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_escalation_id):
            query['incidentEscalationId'] = request.incident_escalation_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetIncidentEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/escalation/get',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetIncidentEscalationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetIncidentEscalationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_incident_escalation(
        self,
        request: cms_20240330_models.GetIncidentEscalationRequest,
    ) -> cms_20240330_models.GetIncidentEscalationResponse:
        """
        @summary 获取一个Incident 升级计划
        
        @param request: GetIncidentEscalationRequest
        @return: GetIncidentEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_incident_escalation_with_options(request, headers, runtime)

    async def get_incident_escalation_async(
        self,
        request: cms_20240330_models.GetIncidentEscalationRequest,
    ) -> cms_20240330_models.GetIncidentEscalationResponse:
        """
        @summary 获取一个Incident 升级计划
        
        @param request: GetIncidentEscalationRequest
        @return: GetIncidentEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_incident_escalation_with_options_async(request, headers, runtime)

    def get_incident_plan_with_options(
        self,
        request: cms_20240330_models.GetIncidentPlanRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetIncidentPlanResponse:
        """
        @summary 获取一个事件处理计划
        
        @param request: GetIncidentPlanRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIncidentPlanResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_plan_id):
            query['incidentPlanId'] = request.incident_plan_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetIncidentPlan',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/plan/get',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetIncidentPlanResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetIncidentPlanResponse(),
                self.execute(params, req, runtime)
            )

    async def get_incident_plan_with_options_async(
        self,
        request: cms_20240330_models.GetIncidentPlanRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetIncidentPlanResponse:
        """
        @summary 获取一个事件处理计划
        
        @param request: GetIncidentPlanRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIncidentPlanResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_plan_id):
            query['incidentPlanId'] = request.incident_plan_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetIncidentPlan',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/plan/get',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetIncidentPlanResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetIncidentPlanResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_incident_plan(
        self,
        request: cms_20240330_models.GetIncidentPlanRequest,
    ) -> cms_20240330_models.GetIncidentPlanResponse:
        """
        @summary 获取一个事件处理计划
        
        @param request: GetIncidentPlanRequest
        @return: GetIncidentPlanResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_incident_plan_with_options(request, headers, runtime)

    async def get_incident_plan_async(
        self,
        request: cms_20240330_models.GetIncidentPlanRequest,
    ) -> cms_20240330_models.GetIncidentPlanResponse:
        """
        @summary 获取一个事件处理计划
        
        @param request: GetIncidentPlanRequest
        @return: GetIncidentPlanResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_incident_plan_with_options_async(request, headers, runtime)

    def get_integration_with_options(
        self,
        integration_id: str,
        request: cms_20240330_models.GetIntegrationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetIntegrationResponse:
        """
        @summary 获取订阅
        
        @param request: GetIntegrationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIntegrationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetIntegration',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integrations/{OpenApiUtilClient.get_encode_param(integration_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetIntegrationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetIntegrationResponse(),
                self.execute(params, req, runtime)
            )

    async def get_integration_with_options_async(
        self,
        integration_id: str,
        request: cms_20240330_models.GetIntegrationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetIntegrationResponse:
        """
        @summary 获取订阅
        
        @param request: GetIntegrationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIntegrationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetIntegration',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integrations/{OpenApiUtilClient.get_encode_param(integration_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetIntegrationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetIntegrationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_integration(
        self,
        integration_id: str,
        request: cms_20240330_models.GetIntegrationRequest,
    ) -> cms_20240330_models.GetIntegrationResponse:
        """
        @summary 获取订阅
        
        @param request: GetIntegrationRequest
        @return: GetIntegrationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_integration_with_options(integration_id, request, headers, runtime)

    async def get_integration_async(
        self,
        integration_id: str,
        request: cms_20240330_models.GetIntegrationRequest,
    ) -> cms_20240330_models.GetIntegrationResponse:
        """
        @summary 获取订阅
        
        @param request: GetIntegrationRequest
        @return: GetIntegrationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_integration_with_options_async(integration_id, request, headers, runtime)

    def get_integration_policy_with_options(
        self,
        policy_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetIntegrationPolicyResponse:
        """
        @summary 查询接入中心策略列表信息
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIntegrationPolicyResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetIntegrationPolicyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetIntegrationPolicyResponse(),
                self.execute(params, req, runtime)
            )

    async def get_integration_policy_with_options_async(
        self,
        policy_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetIntegrationPolicyResponse:
        """
        @summary 查询接入中心策略列表信息
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIntegrationPolicyResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetIntegrationPolicyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetIntegrationPolicyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_integration_policy(
        self,
        policy_id: str,
    ) -> cms_20240330_models.GetIntegrationPolicyResponse:
        """
        @summary 查询接入中心策略列表信息
        
        @return: GetIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_integration_policy_with_options(policy_id, headers, runtime)

    async def get_integration_policy_async(
        self,
        policy_id: str,
    ) -> cms_20240330_models.GetIntegrationPolicyResponse:
        """
        @summary 查询接入中心策略列表信息
        
        @return: GetIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_integration_policy_with_options_async(policy_id, headers, runtime)

    def get_integration_policy_target_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.GetIntegrationPolicyTargetRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetIntegrationPolicyTargetResponse:
        """
        @summary 策略指标target详情
        
        @param request: GetIntegrationPolicyTargetRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIntegrationPolicyTargetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_name):
            query['jobName'] = request.job_name
        if not UtilClient.is_unset(request.target_url):
            query['targetUrl'] = request.target_url
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetIntegrationPolicyTarget',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/target',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetIntegrationPolicyTargetResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetIntegrationPolicyTargetResponse(),
                self.execute(params, req, runtime)
            )

    async def get_integration_policy_target_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.GetIntegrationPolicyTargetRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetIntegrationPolicyTargetResponse:
        """
        @summary 策略指标target详情
        
        @param request: GetIntegrationPolicyTargetRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetIntegrationPolicyTargetResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_name):
            query['jobName'] = request.job_name
        if not UtilClient.is_unset(request.target_url):
            query['targetUrl'] = request.target_url
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetIntegrationPolicyTarget',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/target',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetIntegrationPolicyTargetResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetIntegrationPolicyTargetResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_integration_policy_target(
        self,
        policy_id: str,
        request: cms_20240330_models.GetIntegrationPolicyTargetRequest,
    ) -> cms_20240330_models.GetIntegrationPolicyTargetResponse:
        """
        @summary 策略指标target详情
        
        @param request: GetIntegrationPolicyTargetRequest
        @return: GetIntegrationPolicyTargetResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_integration_policy_target_with_options(policy_id, request, headers, runtime)

    async def get_integration_policy_target_async(
        self,
        policy_id: str,
        request: cms_20240330_models.GetIntegrationPolicyTargetRequest,
    ) -> cms_20240330_models.GetIntegrationPolicyTargetResponse:
        """
        @summary 策略指标target详情
        
        @param request: GetIntegrationPolicyTargetRequest
        @return: GetIntegrationPolicyTargetResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_integration_policy_target_with_options_async(policy_id, request, headers, runtime)

    def get_maintain_window_with_options(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.GetMaintainWindowRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetMaintainWindowResponse:
        """
        @summary 获取订阅
        
        @param request: GetMaintainWindowRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMaintainWindowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMaintainWindow',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/maintainWindows/{OpenApiUtilClient.get_encode_param(maintain_window_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetMaintainWindowResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetMaintainWindowResponse(),
                self.execute(params, req, runtime)
            )

    async def get_maintain_window_with_options_async(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.GetMaintainWindowRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetMaintainWindowResponse:
        """
        @summary 获取订阅
        
        @param request: GetMaintainWindowRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetMaintainWindowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetMaintainWindow',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/maintainWindows/{OpenApiUtilClient.get_encode_param(maintain_window_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetMaintainWindowResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetMaintainWindowResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_maintain_window(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.GetMaintainWindowRequest,
    ) -> cms_20240330_models.GetMaintainWindowResponse:
        """
        @summary 获取订阅
        
        @param request: GetMaintainWindowRequest
        @return: GetMaintainWindowResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_maintain_window_with_options(maintain_window_id, request, headers, runtime)

    async def get_maintain_window_async(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.GetMaintainWindowRequest,
    ) -> cms_20240330_models.GetMaintainWindowResponse:
        """
        @summary 获取订阅
        
        @param request: GetMaintainWindowRequest
        @return: GetMaintainWindowResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_maintain_window_with_options_async(maintain_window_id, request, headers, runtime)

    def get_notify_strategy_with_options(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.GetNotifyStrategyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetNotifyStrategyResponse:
        """
        @summary 获取订阅
        
        @param request: GetNotifyStrategyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetNotifyStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetNotifyStrategy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/notifyStrategies/{OpenApiUtilClient.get_encode_param(notify_strategy_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetNotifyStrategyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetNotifyStrategyResponse(),
                self.execute(params, req, runtime)
            )

    async def get_notify_strategy_with_options_async(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.GetNotifyStrategyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetNotifyStrategyResponse:
        """
        @summary 获取订阅
        
        @param request: GetNotifyStrategyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetNotifyStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetNotifyStrategy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/notifyStrategies/{OpenApiUtilClient.get_encode_param(notify_strategy_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetNotifyStrategyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetNotifyStrategyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_notify_strategy(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.GetNotifyStrategyRequest,
    ) -> cms_20240330_models.GetNotifyStrategyResponse:
        """
        @summary 获取订阅
        
        @param request: GetNotifyStrategyRequest
        @return: GetNotifyStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_notify_strategy_with_options(notify_strategy_id, request, headers, runtime)

    async def get_notify_strategy_async(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.GetNotifyStrategyRequest,
    ) -> cms_20240330_models.GetNotifyStrategyResponse:
        """
        @summary 获取订阅
        
        @param request: GetNotifyStrategyRequest
        @return: GetNotifyStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_notify_strategy_with_options_async(notify_strategy_id, request, headers, runtime)

    def get_oncall_schedule_with_options(
        self,
        oncall_schedule_id: str,
        request: cms_20240330_models.GetOncallScheduleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetOncallScheduleResponse:
        """
        @summary 查询 OncallSchedule
        
        @param request: GetOncallScheduleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetOncallScheduleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetOncallSchedule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/oncallSchedule/{OpenApiUtilClient.get_encode_param(oncall_schedule_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetOncallScheduleResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetOncallScheduleResponse(),
                self.execute(params, req, runtime)
            )

    async def get_oncall_schedule_with_options_async(
        self,
        oncall_schedule_id: str,
        request: cms_20240330_models.GetOncallScheduleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetOncallScheduleResponse:
        """
        @summary 查询 OncallSchedule
        
        @param request: GetOncallScheduleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetOncallScheduleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetOncallSchedule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/oncallSchedule/{OpenApiUtilClient.get_encode_param(oncall_schedule_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetOncallScheduleResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetOncallScheduleResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_oncall_schedule(
        self,
        oncall_schedule_id: str,
        request: cms_20240330_models.GetOncallScheduleRequest,
    ) -> cms_20240330_models.GetOncallScheduleResponse:
        """
        @summary 查询 OncallSchedule
        
        @param request: GetOncallScheduleRequest
        @return: GetOncallScheduleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_oncall_schedule_with_options(oncall_schedule_id, request, headers, runtime)

    async def get_oncall_schedule_async(
        self,
        oncall_schedule_id: str,
        request: cms_20240330_models.GetOncallScheduleRequest,
    ) -> cms_20240330_models.GetOncallScheduleResponse:
        """
        @summary 查询 OncallSchedule
        
        @param request: GetOncallScheduleRequest
        @return: GetOncallScheduleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_oncall_schedule_with_options_async(oncall_schedule_id, request, headers, runtime)

    def get_prometheus_instance_with_options(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.GetPrometheusInstanceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetPrometheusInstanceResponse:
        """
        @summary 查询指定环境实例
        
        @param request: GetPrometheusInstanceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPrometheusInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPrometheusInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(prometheus_instance_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetPrometheusInstanceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetPrometheusInstanceResponse(),
                self.execute(params, req, runtime)
            )

    async def get_prometheus_instance_with_options_async(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.GetPrometheusInstanceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetPrometheusInstanceResponse:
        """
        @summary 查询指定环境实例
        
        @param request: GetPrometheusInstanceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPrometheusInstanceResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPrometheusInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(prometheus_instance_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetPrometheusInstanceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetPrometheusInstanceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_prometheus_instance(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.GetPrometheusInstanceRequest,
    ) -> cms_20240330_models.GetPrometheusInstanceResponse:
        """
        @summary 查询指定环境实例
        
        @param request: GetPrometheusInstanceRequest
        @return: GetPrometheusInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_prometheus_instance_with_options(prometheus_instance_id, request, headers, runtime)

    async def get_prometheus_instance_async(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.GetPrometheusInstanceRequest,
    ) -> cms_20240330_models.GetPrometheusInstanceResponse:
        """
        @summary 查询指定环境实例
        
        @param request: GetPrometheusInstanceRequest
        @return: GetPrometheusInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_prometheus_instance_with_options_async(prometheus_instance_id, request, headers, runtime)

    def get_prometheus_user_setting_with_options(
        self,
        request: cms_20240330_models.GetPrometheusUserSettingRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetPrometheusUserSettingResponse:
        """
        @summary 查询指定环境实例
        
        @param request: GetPrometheusUserSettingRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPrometheusUserSettingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPrometheusUserSetting',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-user-setting',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetPrometheusUserSettingResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetPrometheusUserSettingResponse(),
                self.execute(params, req, runtime)
            )

    async def get_prometheus_user_setting_with_options_async(
        self,
        request: cms_20240330_models.GetPrometheusUserSettingRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetPrometheusUserSettingResponse:
        """
        @summary 查询指定环境实例
        
        @param request: GetPrometheusUserSettingRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPrometheusUserSettingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPrometheusUserSetting',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-user-setting',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetPrometheusUserSettingResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetPrometheusUserSettingResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_prometheus_user_setting(
        self,
        request: cms_20240330_models.GetPrometheusUserSettingRequest,
    ) -> cms_20240330_models.GetPrometheusUserSettingResponse:
        """
        @summary 查询指定环境实例
        
        @param request: GetPrometheusUserSettingRequest
        @return: GetPrometheusUserSettingResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_prometheus_user_setting_with_options(request, headers, runtime)

    async def get_prometheus_user_setting_async(
        self,
        request: cms_20240330_models.GetPrometheusUserSettingRequest,
    ) -> cms_20240330_models.GetPrometheusUserSettingResponse:
        """
        @summary 查询指定环境实例
        
        @param request: GetPrometheusUserSettingRequest
        @return: GetPrometheusUserSettingResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_prometheus_user_setting_with_options_async(request, headers, runtime)

    def get_prometheus_view_with_options(
        self,
        prometheus_view_id: str,
        request: cms_20240330_models.GetPrometheusViewRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetPrometheusViewResponse:
        """
        @summary 查询指定Prometheus视图实例
        
        @param request: GetPrometheusViewRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPrometheusViewResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPrometheusView',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-views/{OpenApiUtilClient.get_encode_param(prometheus_view_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetPrometheusViewResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetPrometheusViewResponse(),
                self.execute(params, req, runtime)
            )

    async def get_prometheus_view_with_options_async(
        self,
        prometheus_view_id: str,
        request: cms_20240330_models.GetPrometheusViewRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetPrometheusViewResponse:
        """
        @summary 查询指定Prometheus视图实例
        
        @param request: GetPrometheusViewRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetPrometheusViewResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetPrometheusView',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-views/{OpenApiUtilClient.get_encode_param(prometheus_view_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetPrometheusViewResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetPrometheusViewResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_prometheus_view(
        self,
        prometheus_view_id: str,
        request: cms_20240330_models.GetPrometheusViewRequest,
    ) -> cms_20240330_models.GetPrometheusViewResponse:
        """
        @summary 查询指定Prometheus视图实例
        
        @param request: GetPrometheusViewRequest
        @return: GetPrometheusViewResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_prometheus_view_with_options(prometheus_view_id, request, headers, runtime)

    async def get_prometheus_view_async(
        self,
        prometheus_view_id: str,
        request: cms_20240330_models.GetPrometheusViewRequest,
    ) -> cms_20240330_models.GetPrometheusViewResponse:
        """
        @summary 查询指定Prometheus视图实例
        
        @param request: GetPrometheusViewRequest
        @return: GetPrometheusViewResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_prometheus_view_with_options_async(prometheus_view_id, request, headers, runtime)

    def get_rum_instance_with_options(
        self,
        rum_instance_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetRumInstanceResponse:
        """
        @summary 查询RUM实例
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetRumInstanceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetRumInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/rum-instances/{OpenApiUtilClient.get_encode_param(rum_instance_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetRumInstanceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetRumInstanceResponse(),
                self.execute(params, req, runtime)
            )

    async def get_rum_instance_with_options_async(
        self,
        rum_instance_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetRumInstanceResponse:
        """
        @summary 查询RUM实例
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetRumInstanceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetRumInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/rum-instances/{OpenApiUtilClient.get_encode_param(rum_instance_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetRumInstanceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetRumInstanceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_rum_instance(
        self,
        rum_instance_id: str,
    ) -> cms_20240330_models.GetRumInstanceResponse:
        """
        @summary 查询RUM实例
        
        @return: GetRumInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_rum_instance_with_options(rum_instance_id, headers, runtime)

    async def get_rum_instance_async(
        self,
        rum_instance_id: str,
    ) -> cms_20240330_models.GetRumInstanceResponse:
        """
        @summary 查询RUM实例
        
        @return: GetRumInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_rum_instance_with_options_async(rum_instance_id, headers, runtime)

    def get_site_monitor_with_options(
        self,
        request: cms_20240330_models.GetSiteMonitorRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetSiteMonitorResponse:
        """
        @summary 查询 SiteMonitor
        
        @param request: GetSiteMonitorRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetSiteMonitorResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.site_monitor_id):
            query['siteMonitorId'] = request.site_monitor_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetSiteMonitor',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/sitemonitor',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetSiteMonitorResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetSiteMonitorResponse(),
                self.execute(params, req, runtime)
            )

    async def get_site_monitor_with_options_async(
        self,
        request: cms_20240330_models.GetSiteMonitorRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetSiteMonitorResponse:
        """
        @summary 查询 SiteMonitor
        
        @param request: GetSiteMonitorRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetSiteMonitorResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.site_monitor_id):
            query['siteMonitorId'] = request.site_monitor_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetSiteMonitor',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/sitemonitor',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetSiteMonitorResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetSiteMonitorResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_site_monitor(
        self,
        request: cms_20240330_models.GetSiteMonitorRequest,
    ) -> cms_20240330_models.GetSiteMonitorResponse:
        """
        @summary 查询 SiteMonitor
        
        @param request: GetSiteMonitorRequest
        @return: GetSiteMonitorResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_site_monitor_with_options(request, headers, runtime)

    async def get_site_monitor_async(
        self,
        request: cms_20240330_models.GetSiteMonitorRequest,
    ) -> cms_20240330_models.GetSiteMonitorResponse:
        """
        @summary 查询 SiteMonitor
        
        @param request: GetSiteMonitorRequest
        @return: GetSiteMonitorResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_site_monitor_with_options_async(request, headers, runtime)

    def get_subscription_with_options(
        self,
        subscription_id: str,
        request: cms_20240330_models.GetSubscriptionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetSubscriptionResponse:
        """
        @summary 获取订阅
        
        @param request: GetSubscriptionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetSubscriptionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetSubscription',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/subscriptions/{OpenApiUtilClient.get_encode_param(subscription_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetSubscriptionResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetSubscriptionResponse(),
                self.execute(params, req, runtime)
            )

    async def get_subscription_with_options_async(
        self,
        subscription_id: str,
        request: cms_20240330_models.GetSubscriptionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetSubscriptionResponse:
        """
        @summary 获取订阅
        
        @param request: GetSubscriptionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetSubscriptionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetSubscription',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/subscriptions/{OpenApiUtilClient.get_encode_param(subscription_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetSubscriptionResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetSubscriptionResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_subscription(
        self,
        subscription_id: str,
        request: cms_20240330_models.GetSubscriptionRequest,
    ) -> cms_20240330_models.GetSubscriptionResponse:
        """
        @summary 获取订阅
        
        @param request: GetSubscriptionRequest
        @return: GetSubscriptionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_subscription_with_options(subscription_id, request, headers, runtime)

    async def get_subscription_async(
        self,
        subscription_id: str,
        request: cms_20240330_models.GetSubscriptionRequest,
    ) -> cms_20240330_models.GetSubscriptionResponse:
        """
        @summary 获取订阅
        
        @param request: GetSubscriptionRequest
        @return: GetSubscriptionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_subscription_with_options_async(subscription_id, request, headers, runtime)

    def get_transformer_with_options(
        self,
        transformer_id: str,
        request: cms_20240330_models.GetTransformerRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetTransformerResponse:
        """
        @summary 获取订阅
        
        @param request: GetTransformerRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTransformerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTransformer',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/transformers/{OpenApiUtilClient.get_encode_param(transformer_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetTransformerResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetTransformerResponse(),
                self.execute(params, req, runtime)
            )

    async def get_transformer_with_options_async(
        self,
        transformer_id: str,
        request: cms_20240330_models.GetTransformerRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetTransformerResponse:
        """
        @summary 获取订阅
        
        @param request: GetTransformerRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetTransformerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='GetTransformer',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/transformers/{OpenApiUtilClient.get_encode_param(transformer_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetTransformerResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetTransformerResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_transformer(
        self,
        transformer_id: str,
        request: cms_20240330_models.GetTransformerRequest,
    ) -> cms_20240330_models.GetTransformerResponse:
        """
        @summary 获取订阅
        
        @param request: GetTransformerRequest
        @return: GetTransformerResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_transformer_with_options(transformer_id, request, headers, runtime)

    async def get_transformer_async(
        self,
        transformer_id: str,
        request: cms_20240330_models.GetTransformerRequest,
    ) -> cms_20240330_models.GetTransformerResponse:
        """
        @summary 获取订阅
        
        @param request: GetTransformerRequest
        @return: GetTransformerResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_transformer_with_options_async(transformer_id, request, headers, runtime)

    def get_umodel_with_options(
        self,
        workspace: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetUmodelResponse:
        """
        @summary 获取Umodel配置信息
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetUmodelResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetUmodel',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetUmodelResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetUmodelResponse(),
                self.execute(params, req, runtime)
            )

    async def get_umodel_with_options_async(
        self,
        workspace: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetUmodelResponse:
        """
        @summary 获取Umodel配置信息
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetUmodelResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetUmodel',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetUmodelResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetUmodelResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_umodel(
        self,
        workspace: str,
    ) -> cms_20240330_models.GetUmodelResponse:
        """
        @summary 获取Umodel配置信息
        
        @return: GetUmodelResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_umodel_with_options(workspace, headers, runtime)

    async def get_umodel_async(
        self,
        workspace: str,
    ) -> cms_20240330_models.GetUmodelResponse:
        """
        @summary 获取Umodel配置信息
        
        @return: GetUmodelResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_umodel_with_options_async(workspace, headers, runtime)

    def get_umodel_data_with_options(
        self,
        workspace: str,
        request: cms_20240330_models.GetUmodelDataRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetUmodelDataResponse:
        """
        @summary 获取相关联的 Umodel 图数据
        
        @param request: GetUmodelDataRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetUmodelDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.method):
            query['method'] = request.method
        body = {}
        if not UtilClient.is_unset(request.content):
            body['content'] = request.content
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetUmodelData',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel/graph',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetUmodelDataResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetUmodelDataResponse(),
                self.execute(params, req, runtime)
            )

    async def get_umodel_data_with_options_async(
        self,
        workspace: str,
        request: cms_20240330_models.GetUmodelDataRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetUmodelDataResponse:
        """
        @summary 获取相关联的 Umodel 图数据
        
        @param request: GetUmodelDataRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetUmodelDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.method):
            query['method'] = request.method
        body = {}
        if not UtilClient.is_unset(request.content):
            body['content'] = request.content
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='GetUmodelData',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel/graph',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetUmodelDataResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetUmodelDataResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_umodel_data(
        self,
        workspace: str,
        request: cms_20240330_models.GetUmodelDataRequest,
    ) -> cms_20240330_models.GetUmodelDataResponse:
        """
        @summary 获取相关联的 Umodel 图数据
        
        @param request: GetUmodelDataRequest
        @return: GetUmodelDataResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_umodel_data_with_options(workspace, request, headers, runtime)

    async def get_umodel_data_async(
        self,
        workspace: str,
        request: cms_20240330_models.GetUmodelDataRequest,
    ) -> cms_20240330_models.GetUmodelDataResponse:
        """
        @summary 获取相关联的 Umodel 图数据
        
        @param request: GetUmodelDataRequest
        @return: GetUmodelDataResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_umodel_data_with_options_async(workspace, request, headers, runtime)

    def get_workspace_with_options(
        self,
        workspace_name: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetWorkspaceResponse:
        """
        @summary 获取工作空间
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetWorkspaceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetWorkspace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace_name)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetWorkspaceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetWorkspaceResponse(),
                self.execute(params, req, runtime)
            )

    async def get_workspace_with_options_async(
        self,
        workspace_name: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.GetWorkspaceResponse:
        """
        @summary 获取工作空间
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: GetWorkspaceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='GetWorkspace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace_name)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.GetWorkspaceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.GetWorkspaceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def get_workspace(
        self,
        workspace_name: str,
    ) -> cms_20240330_models.GetWorkspaceResponse:
        """
        @summary 获取工作空间
        
        @return: GetWorkspaceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.get_workspace_with_options(workspace_name, headers, runtime)

    async def get_workspace_async(
        self,
        workspace_name: str,
    ) -> cms_20240330_models.GetWorkspaceResponse:
        """
        @summary 获取工作空间
        
        @return: GetWorkspaceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.get_workspace_with_options_async(workspace_name, headers, runtime)

    def henghai_test_with_options(
        self,
        webhook_id: str,
        request: cms_20240330_models.HenghaiTestRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.HenghaiTestResponse:
        """
        @summary 更新Webhook
        
        @param request: HenghaiTestRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: HenghaiTestResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.content_type):
            body['contentType'] = request.content_type
        if not UtilClient.is_unset(request.headers):
            body['headers'] = request.headers
        if not UtilClient.is_unset(request.lang):
            body['lang'] = request.lang
        if not UtilClient.is_unset(request.method):
            body['method'] = request.method
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        if not UtilClient.is_unset(request.type):
            body['type'] = request.type
        if not UtilClient.is_unset(request.url):
            body['url'] = request.url
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='HenghaiTest',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/test/{OpenApiUtilClient.get_encode_param(webhook_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.HenghaiTestResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.HenghaiTestResponse(),
                self.execute(params, req, runtime)
            )

    async def henghai_test_with_options_async(
        self,
        webhook_id: str,
        request: cms_20240330_models.HenghaiTestRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.HenghaiTestResponse:
        """
        @summary 更新Webhook
        
        @param request: HenghaiTestRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: HenghaiTestResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.content_type):
            body['contentType'] = request.content_type
        if not UtilClient.is_unset(request.headers):
            body['headers'] = request.headers
        if not UtilClient.is_unset(request.lang):
            body['lang'] = request.lang
        if not UtilClient.is_unset(request.method):
            body['method'] = request.method
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        if not UtilClient.is_unset(request.type):
            body['type'] = request.type
        if not UtilClient.is_unset(request.url):
            body['url'] = request.url
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='HenghaiTest',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/test/{OpenApiUtilClient.get_encode_param(webhook_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.HenghaiTestResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.HenghaiTestResponse(),
                await self.execute_async(params, req, runtime)
            )

    def henghai_test(
        self,
        webhook_id: str,
        request: cms_20240330_models.HenghaiTestRequest,
    ) -> cms_20240330_models.HenghaiTestResponse:
        """
        @summary 更新Webhook
        
        @param request: HenghaiTestRequest
        @return: HenghaiTestResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.henghai_test_with_options(webhook_id, request, headers, runtime)

    async def henghai_test_async(
        self,
        webhook_id: str,
        request: cms_20240330_models.HenghaiTestRequest,
    ) -> cms_20240330_models.HenghaiTestResponse:
        """
        @summary 更新Webhook
        
        @param request: HenghaiTestRequest
        @return: HenghaiTestResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.henghai_test_with_options_async(webhook_id, request, headers, runtime)

    def init_environment_with_options(
        self,
        request: cms_20240330_models.InitEnvironmentRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.InitEnvironmentResponse:
        """
        @summary 初始化环境实例
        
        @param request: InitEnvironmentRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: InitEnvironmentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['AliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.create_auth_token):
            query['CreateAuthToken'] = request.create_auth_token
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.managed_type):
            query['ManagedType'] = request.managed_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='InitEnvironment',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/InitEnvironment',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.InitEnvironmentResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.InitEnvironmentResponse(),
                self.execute(params, req, runtime)
            )

    async def init_environment_with_options_async(
        self,
        request: cms_20240330_models.InitEnvironmentRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.InitEnvironmentResponse:
        """
        @summary 初始化环境实例
        
        @param request: InitEnvironmentRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: InitEnvironmentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['AliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.create_auth_token):
            query['CreateAuthToken'] = request.create_auth_token
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.managed_type):
            query['ManagedType'] = request.managed_type
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='InitEnvironment',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/InitEnvironment',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.InitEnvironmentResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.InitEnvironmentResponse(),
                await self.execute_async(params, req, runtime)
            )

    def init_environment(
        self,
        request: cms_20240330_models.InitEnvironmentRequest,
    ) -> cms_20240330_models.InitEnvironmentResponse:
        """
        @summary 初始化环境实例
        
        @param request: InitEnvironmentRequest
        @return: InitEnvironmentResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.init_environment_with_options(request, headers, runtime)

    async def init_environment_async(
        self,
        request: cms_20240330_models.InitEnvironmentRequest,
    ) -> cms_20240330_models.InitEnvironmentResponse:
        """
        @summary 初始化环境实例
        
        @param request: InitEnvironmentRequest
        @return: InitEnvironmentResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.init_environment_with_options_async(request, headers, runtime)

    def install_addon_with_options(
        self,
        request: cms_20240330_models.InstallAddonRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.InstallAddonResponse:
        """
        @summary 安装接入组件，代表进行一次接入
        
        @param request: InstallAddonRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: InstallAddonResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.addon_name):
            body['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.aliyun_lang):
            body['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.dry_run):
            body['dryRun'] = request.dry_run
        if not UtilClient.is_unset(request.policy):
            body['policy'] = request.policy
        if not UtilClient.is_unset(request.policy_id):
            body['policyId'] = request.policy_id
        if not UtilClient.is_unset(request.region_id):
            body['regionId'] = request.region_id
        if not UtilClient.is_unset(request.release_name):
            body['releaseName'] = request.release_name
        if not UtilClient.is_unset(request.values):
            body['values'] = request.values
        if not UtilClient.is_unset(request.version):
            body['version'] = request.version
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='InstallAddon',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addonrelease',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.InstallAddonResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.InstallAddonResponse(),
                self.execute(params, req, runtime)
            )

    async def install_addon_with_options_async(
        self,
        request: cms_20240330_models.InstallAddonRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.InstallAddonResponse:
        """
        @summary 安装接入组件，代表进行一次接入
        
        @param request: InstallAddonRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: InstallAddonResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.addon_name):
            body['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.aliyun_lang):
            body['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.dry_run):
            body['dryRun'] = request.dry_run
        if not UtilClient.is_unset(request.policy):
            body['policy'] = request.policy
        if not UtilClient.is_unset(request.policy_id):
            body['policyId'] = request.policy_id
        if not UtilClient.is_unset(request.region_id):
            body['regionId'] = request.region_id
        if not UtilClient.is_unset(request.release_name):
            body['releaseName'] = request.release_name
        if not UtilClient.is_unset(request.values):
            body['values'] = request.values
        if not UtilClient.is_unset(request.version):
            body['version'] = request.version
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='InstallAddon',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addonrelease',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.InstallAddonResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.InstallAddonResponse(),
                await self.execute_async(params, req, runtime)
            )

    def install_addon(
        self,
        request: cms_20240330_models.InstallAddonRequest,
    ) -> cms_20240330_models.InstallAddonResponse:
        """
        @summary 安装接入组件，代表进行一次接入
        
        @param request: InstallAddonRequest
        @return: InstallAddonResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.install_addon_with_options(request, headers, runtime)

    async def install_addon_async(
        self,
        request: cms_20240330_models.InstallAddonRequest,
    ) -> cms_20240330_models.InstallAddonResponse:
        """
        @summary 安装接入组件，代表进行一次接入
        
        @param request: InstallAddonRequest
        @return: InstallAddonResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.install_addon_with_options_async(request, headers, runtime)

    def install_environment_feature_with_options(
        self,
        environment_id: str,
        feature_name: str,
        request: cms_20240330_models.InstallEnvironmentFeatureRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.InstallEnvironmentFeatureResponse:
        """
        @summary 安装 feature
        
        @param request: InstallEnvironmentFeatureRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: InstallEnvironmentFeatureResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['AliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.config):
            query['Config'] = request.config
        if not UtilClient.is_unset(request.feature_version):
            query['FeatureVersion'] = request.feature_version
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='InstallEnvironmentFeature',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/feature/rest/{OpenApiUtilClient.get_encode_param(environment_id)}/{OpenApiUtilClient.get_encode_param(feature_name)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.InstallEnvironmentFeatureResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.InstallEnvironmentFeatureResponse(),
                self.execute(params, req, runtime)
            )

    async def install_environment_feature_with_options_async(
        self,
        environment_id: str,
        feature_name: str,
        request: cms_20240330_models.InstallEnvironmentFeatureRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.InstallEnvironmentFeatureResponse:
        """
        @summary 安装 feature
        
        @param request: InstallEnvironmentFeatureRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: InstallEnvironmentFeatureResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['AliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.config):
            query['Config'] = request.config
        if not UtilClient.is_unset(request.feature_version):
            query['FeatureVersion'] = request.feature_version
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='InstallEnvironmentFeature',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/feature/rest/{OpenApiUtilClient.get_encode_param(environment_id)}/{OpenApiUtilClient.get_encode_param(feature_name)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.InstallEnvironmentFeatureResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.InstallEnvironmentFeatureResponse(),
                await self.execute_async(params, req, runtime)
            )

    def install_environment_feature(
        self,
        environment_id: str,
        feature_name: str,
        request: cms_20240330_models.InstallEnvironmentFeatureRequest,
    ) -> cms_20240330_models.InstallEnvironmentFeatureResponse:
        """
        @summary 安装 feature
        
        @param request: InstallEnvironmentFeatureRequest
        @return: InstallEnvironmentFeatureResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.install_environment_feature_with_options(environment_id, feature_name, request, headers, runtime)

    async def install_environment_feature_async(
        self,
        environment_id: str,
        feature_name: str,
        request: cms_20240330_models.InstallEnvironmentFeatureRequest,
    ) -> cms_20240330_models.InstallEnvironmentFeatureResponse:
        """
        @summary 安装 feature
        
        @param request: InstallEnvironmentFeatureRequest
        @return: InstallEnvironmentFeatureResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.install_environment_feature_with_options_async(environment_id, feature_name, request, headers, runtime)

    def list_addon_release_exporter_pods_with_options(
        self,
        request: cms_20240330_models.ListAddonReleaseExporterPodsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAddonReleaseExporterPodsResponse:
        """
        @summary 查询AddonRelease的Exporter的Pod集合
        
        @param request: ListAddonReleaseExporterPodsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAddonReleaseExporterPodsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.release_name):
            query['ReleaseName'] = request.release_name
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAddonReleaseExporterPods',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/addon/ListAddonReleaseExporterPods',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAddonReleaseExporterPodsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAddonReleaseExporterPodsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_addon_release_exporter_pods_with_options_async(
        self,
        request: cms_20240330_models.ListAddonReleaseExporterPodsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAddonReleaseExporterPodsResponse:
        """
        @summary 查询AddonRelease的Exporter的Pod集合
        
        @param request: ListAddonReleaseExporterPodsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAddonReleaseExporterPodsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.release_name):
            query['ReleaseName'] = request.release_name
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAddonReleaseExporterPods',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/addon/ListAddonReleaseExporterPods',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAddonReleaseExporterPodsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAddonReleaseExporterPodsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_addon_release_exporter_pods(
        self,
        request: cms_20240330_models.ListAddonReleaseExporterPodsRequest,
    ) -> cms_20240330_models.ListAddonReleaseExporterPodsResponse:
        """
        @summary 查询AddonRelease的Exporter的Pod集合
        
        @param request: ListAddonReleaseExporterPodsRequest
        @return: ListAddonReleaseExporterPodsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_addon_release_exporter_pods_with_options(request, headers, runtime)

    async def list_addon_release_exporter_pods_async(
        self,
        request: cms_20240330_models.ListAddonReleaseExporterPodsRequest,
    ) -> cms_20240330_models.ListAddonReleaseExporterPodsResponse:
        """
        @summary 查询AddonRelease的Exporter的Pod集合
        
        @param request: ListAddonReleaseExporterPodsRequest
        @return: ListAddonReleaseExporterPodsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_addon_release_exporter_pods_with_options_async(request, headers, runtime)

    def list_addon_releases_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.ListAddonReleasesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAddonReleasesResponse:
        """
        @summary addon的release列表
        
        @param request: ListAddonReleasesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAddonReleasesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.parent_addon_release_id):
            query['parentAddonReleaseId'] = request.parent_addon_release_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAddonReleases',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/addon-releases',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAddonReleasesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAddonReleasesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_addon_releases_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListAddonReleasesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAddonReleasesResponse:
        """
        @summary addon的release列表
        
        @param request: ListAddonReleasesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAddonReleasesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.parent_addon_release_id):
            query['parentAddonReleaseId'] = request.parent_addon_release_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAddonReleases',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/addon-releases',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAddonReleasesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAddonReleasesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_addon_releases(
        self,
        policy_id: str,
        request: cms_20240330_models.ListAddonReleasesRequest,
    ) -> cms_20240330_models.ListAddonReleasesResponse:
        """
        @summary addon的release列表
        
        @param request: ListAddonReleasesRequest
        @return: ListAddonReleasesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_addon_releases_with_options(policy_id, request, headers, runtime)

    async def list_addon_releases_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListAddonReleasesRequest,
    ) -> cms_20240330_models.ListAddonReleasesResponse:
        """
        @summary addon的release列表
        
        @param request: ListAddonReleasesRequest
        @return: ListAddonReleasesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_addon_releases_with_options_async(policy_id, request, headers, runtime)

    def list_addons_with_options(
        self,
        request: cms_20240330_models.ListAddonsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAddonsResponse:
        """
        @summary 新版接入中心产品列表(分组)-1
        
        @param request: ListAddonsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAddonsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.category):
            query['category'] = request.category
        if not UtilClient.is_unset(request.regexp):
            query['regexp'] = request.regexp
        if not UtilClient.is_unset(request.search):
            query['search'] = request.search
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAddons',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addons',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAddonsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAddonsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_addons_with_options_async(
        self,
        request: cms_20240330_models.ListAddonsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAddonsResponse:
        """
        @summary 新版接入中心产品列表(分组)-1
        
        @param request: ListAddonsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAddonsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.category):
            query['category'] = request.category
        if not UtilClient.is_unset(request.regexp):
            query['regexp'] = request.regexp
        if not UtilClient.is_unset(request.search):
            query['search'] = request.search
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAddons',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/addons',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAddonsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAddonsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_addons(
        self,
        request: cms_20240330_models.ListAddonsRequest,
    ) -> cms_20240330_models.ListAddonsResponse:
        """
        @summary 新版接入中心产品列表(分组)-1
        
        @param request: ListAddonsRequest
        @return: ListAddonsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_addons_with_options(request, headers, runtime)

    async def list_addons_async(
        self,
        request: cms_20240330_models.ListAddonsRequest,
    ) -> cms_20240330_models.ListAddonsResponse:
        """
        @summary 新版接入中心产品列表(分组)-1
        
        @param request: ListAddonsRequest
        @return: ListAddonsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_addons_with_options_async(request, headers, runtime)

    def list_agg_task_groups_with_options(
        self,
        instance_id: str,
        tmp_req: cms_20240330_models.ListAggTaskGroupsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAggTaskGroupsResponse:
        """
        @summary 列举聚合任务组
        
        @param tmp_req: ListAggTaskGroupsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAggTaskGroupsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListAggTaskGroupsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.tags):
            request.tags_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.tags, 'tags', 'json')
        query = {}
        if not UtilClient.is_unset(request.filter_agg_task_group_ids):
            query['filterAggTaskGroupIds'] = request.filter_agg_task_group_ids
        if not UtilClient.is_unset(request.filter_agg_task_group_names):
            query['filterAggTaskGroupNames'] = request.filter_agg_task_group_names
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.query):
            query['query'] = request.query
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.tags_shrink):
            query['tags'] = request.tags_shrink
        if not UtilClient.is_unset(request.target_prometheus_id):
            query['targetPrometheusId'] = request.target_prometheus_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAggTaskGroups',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(instance_id)}/agg-task-groups',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAggTaskGroupsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAggTaskGroupsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_agg_task_groups_with_options_async(
        self,
        instance_id: str,
        tmp_req: cms_20240330_models.ListAggTaskGroupsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAggTaskGroupsResponse:
        """
        @summary 列举聚合任务组
        
        @param tmp_req: ListAggTaskGroupsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAggTaskGroupsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListAggTaskGroupsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.tags):
            request.tags_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.tags, 'tags', 'json')
        query = {}
        if not UtilClient.is_unset(request.filter_agg_task_group_ids):
            query['filterAggTaskGroupIds'] = request.filter_agg_task_group_ids
        if not UtilClient.is_unset(request.filter_agg_task_group_names):
            query['filterAggTaskGroupNames'] = request.filter_agg_task_group_names
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.query):
            query['query'] = request.query
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.tags_shrink):
            query['tags'] = request.tags_shrink
        if not UtilClient.is_unset(request.target_prometheus_id):
            query['targetPrometheusId'] = request.target_prometheus_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAggTaskGroups',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(instance_id)}/agg-task-groups',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAggTaskGroupsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAggTaskGroupsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_agg_task_groups(
        self,
        instance_id: str,
        request: cms_20240330_models.ListAggTaskGroupsRequest,
    ) -> cms_20240330_models.ListAggTaskGroupsResponse:
        """
        @summary 列举聚合任务组
        
        @param request: ListAggTaskGroupsRequest
        @return: ListAggTaskGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_agg_task_groups_with_options(instance_id, request, headers, runtime)

    async def list_agg_task_groups_async(
        self,
        instance_id: str,
        request: cms_20240330_models.ListAggTaskGroupsRequest,
    ) -> cms_20240330_models.ListAggTaskGroupsResponse:
        """
        @summary 列举聚合任务组
        
        @param request: ListAggTaskGroupsRequest
        @return: ListAggTaskGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_agg_task_groups_with_options_async(instance_id, request, headers, runtime)

    def list_alert_actions_with_options(
        self,
        tmp_req: cms_20240330_models.ListAlertActionsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertActionsResponse:
        """
        @summary 查询告警动作
        
        @param tmp_req: ListAlertActionsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertActionsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListAlertActionsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.alert_action_ids):
            request.alert_action_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.alert_action_ids, 'alertActionIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_action_ids_shrink):
            query['alertActionIds'] = request.alert_action_ids_shrink
        if not UtilClient.is_unset(request.alert_action_name):
            query['alertActionName'] = request.alert_action_name
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.type):
            query['type'] = request.type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertActions',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertActions',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertActionsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertActionsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_alert_actions_with_options_async(
        self,
        tmp_req: cms_20240330_models.ListAlertActionsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertActionsResponse:
        """
        @summary 查询告警动作
        
        @param tmp_req: ListAlertActionsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertActionsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListAlertActionsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.alert_action_ids):
            request.alert_action_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.alert_action_ids, 'alertActionIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_action_ids_shrink):
            query['alertActionIds'] = request.alert_action_ids_shrink
        if not UtilClient.is_unset(request.alert_action_name):
            query['alertActionName'] = request.alert_action_name
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.type):
            query['type'] = request.type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertActions',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertActions',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertActionsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertActionsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_alert_actions(
        self,
        request: cms_20240330_models.ListAlertActionsRequest,
    ) -> cms_20240330_models.ListAlertActionsResponse:
        """
        @summary 查询告警动作
        
        @param request: ListAlertActionsRequest
        @return: ListAlertActionsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_alert_actions_with_options(request, headers, runtime)

    async def list_alert_actions_async(
        self,
        request: cms_20240330_models.ListAlertActionsRequest,
    ) -> cms_20240330_models.ListAlertActionsResponse:
        """
        @summary 查询告警动作
        
        @param request: ListAlertActionsRequest
        @return: ListAlertActionsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_alert_actions_with_options_async(request, headers, runtime)

    def list_alert_event_integration_policies_with_options(
        self,
        request: cms_20240330_models.ListAlertEventIntegrationPoliciesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertEventIntegrationPoliciesResponse:
        """
        @summary List AlertEventIntegrationPolicy
        
        @param request: ListAlertEventIntegrationPoliciesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertEventIntegrationPoliciesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.alert_event_integration_policy_id):
            query['alertEventIntegrationPolicyId'] = request.alert_event_integration_policy_id
        if not UtilClient.is_unset(request.alert_event_integration_policy_name):
            query['alertEventIntegrationPolicyName'] = request.alert_event_integration_policy_name
        if not UtilClient.is_unset(request.enable):
            query['enable'] = request.enable
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertEventIntegrationPolicies',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertEventIntegrationPolicies',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertEventIntegrationPoliciesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertEventIntegrationPoliciesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_alert_event_integration_policies_with_options_async(
        self,
        request: cms_20240330_models.ListAlertEventIntegrationPoliciesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertEventIntegrationPoliciesResponse:
        """
        @summary List AlertEventIntegrationPolicy
        
        @param request: ListAlertEventIntegrationPoliciesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertEventIntegrationPoliciesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.alert_event_integration_policy_id):
            query['alertEventIntegrationPolicyId'] = request.alert_event_integration_policy_id
        if not UtilClient.is_unset(request.alert_event_integration_policy_name):
            query['alertEventIntegrationPolicyName'] = request.alert_event_integration_policy_name
        if not UtilClient.is_unset(request.enable):
            query['enable'] = request.enable
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertEventIntegrationPolicies',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertEventIntegrationPolicies',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertEventIntegrationPoliciesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertEventIntegrationPoliciesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_alert_event_integration_policies(
        self,
        request: cms_20240330_models.ListAlertEventIntegrationPoliciesRequest,
    ) -> cms_20240330_models.ListAlertEventIntegrationPoliciesResponse:
        """
        @summary List AlertEventIntegrationPolicy
        
        @param request: ListAlertEventIntegrationPoliciesRequest
        @return: ListAlertEventIntegrationPoliciesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_alert_event_integration_policies_with_options(request, headers, runtime)

    async def list_alert_event_integration_policies_async(
        self,
        request: cms_20240330_models.ListAlertEventIntegrationPoliciesRequest,
    ) -> cms_20240330_models.ListAlertEventIntegrationPoliciesResponse:
        """
        @summary List AlertEventIntegrationPolicy
        
        @param request: ListAlertEventIntegrationPoliciesRequest
        @return: ListAlertEventIntegrationPoliciesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_alert_event_integration_policies_with_options_async(request, headers, runtime)

    def list_alert_histories_with_options(
        self,
        tmp_req: cms_20240330_models.ListAlertHistoriesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertHistoriesResponse:
        """
        @summary 查询云监控2.0告警历史
        
        @param tmp_req: ListAlertHistoriesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertHistoriesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListAlertHistoriesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.label_filter):
            request.label_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.label_filter, 'labelFilter', 'json')
        if not UtilClient.is_unset(tmp_req.notification_filter):
            request.notification_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.notification_filter, 'notificationFilter', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_history_id):
            query['alertHistoryId'] = request.alert_history_id
        if not UtilClient.is_unset(request.alert_rule_id):
            query['alertRuleId'] = request.alert_rule_id
        if not UtilClient.is_unset(request.biz_source):
            query['bizSource'] = request.biz_source
        if not UtilClient.is_unset(request.display_name_key_word):
            query['displayNameKeyWord'] = request.display_name_key_word
        if not UtilClient.is_unset(request.instance_key):
            query['instanceKey'] = request.instance_key
        if not UtilClient.is_unset(request.label_filter_shrink):
            query['labelFilter'] = request.label_filter_shrink
        if not UtilClient.is_unset(request.latest_level):
            query['latestLevel'] = request.latest_level
        if not UtilClient.is_unset(request.max_level):
            query['maxLevel'] = request.max_level
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.notification_filter_shrink):
            query['notificationFilter'] = request.notification_filter_shrink
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time_from):
            query['startTimeFrom'] = request.start_time_from
        if not UtilClient.is_unset(request.start_time_to):
            query['startTimeTo'] = request.start_time_to
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertHistories',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertHistories',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertHistoriesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertHistoriesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_alert_histories_with_options_async(
        self,
        tmp_req: cms_20240330_models.ListAlertHistoriesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertHistoriesResponse:
        """
        @summary 查询云监控2.0告警历史
        
        @param tmp_req: ListAlertHistoriesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertHistoriesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListAlertHistoriesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.label_filter):
            request.label_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.label_filter, 'labelFilter', 'json')
        if not UtilClient.is_unset(tmp_req.notification_filter):
            request.notification_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.notification_filter, 'notificationFilter', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_history_id):
            query['alertHistoryId'] = request.alert_history_id
        if not UtilClient.is_unset(request.alert_rule_id):
            query['alertRuleId'] = request.alert_rule_id
        if not UtilClient.is_unset(request.biz_source):
            query['bizSource'] = request.biz_source
        if not UtilClient.is_unset(request.display_name_key_word):
            query['displayNameKeyWord'] = request.display_name_key_word
        if not UtilClient.is_unset(request.instance_key):
            query['instanceKey'] = request.instance_key
        if not UtilClient.is_unset(request.label_filter_shrink):
            query['labelFilter'] = request.label_filter_shrink
        if not UtilClient.is_unset(request.latest_level):
            query['latestLevel'] = request.latest_level
        if not UtilClient.is_unset(request.max_level):
            query['maxLevel'] = request.max_level
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.notification_filter_shrink):
            query['notificationFilter'] = request.notification_filter_shrink
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.start_time_from):
            query['startTimeFrom'] = request.start_time_from
        if not UtilClient.is_unset(request.start_time_to):
            query['startTimeTo'] = request.start_time_to
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertHistories',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertHistories',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertHistoriesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertHistoriesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_alert_histories(
        self,
        request: cms_20240330_models.ListAlertHistoriesRequest,
    ) -> cms_20240330_models.ListAlertHistoriesResponse:
        """
        @summary 查询云监控2.0告警历史
        
        @param request: ListAlertHistoriesRequest
        @return: ListAlertHistoriesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_alert_histories_with_options(request, headers, runtime)

    async def list_alert_histories_async(
        self,
        request: cms_20240330_models.ListAlertHistoriesRequest,
    ) -> cms_20240330_models.ListAlertHistoriesResponse:
        """
        @summary 查询云监控2.0告警历史
        
        @param request: ListAlertHistoriesRequest
        @return: ListAlertHistoriesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_alert_histories_with_options_async(request, headers, runtime)

    def list_alert_metric_groups_with_options(
        self,
        request: cms_20240330_models.ListAlertMetricGroupsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertMetricGroupsResponse:
        """
        @summary 查询云监控2.0告警指标分组
        
        @param request: ListAlertMetricGroupsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertMetricGroupsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.alert_metric_group_id):
            query['alertMetricGroupId'] = request.alert_metric_group_id
        if not UtilClient.is_unset(request.datasource_type):
            query['datasourceType'] = request.datasource_type
        if not UtilClient.is_unset(request.include_details):
            query['includeDetails'] = request.include_details
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertMetricGroups',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertMetricGroups',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertMetricGroupsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertMetricGroupsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_alert_metric_groups_with_options_async(
        self,
        request: cms_20240330_models.ListAlertMetricGroupsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertMetricGroupsResponse:
        """
        @summary 查询云监控2.0告警指标分组
        
        @param request: ListAlertMetricGroupsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertMetricGroupsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.alert_metric_group_id):
            query['alertMetricGroupId'] = request.alert_metric_group_id
        if not UtilClient.is_unset(request.datasource_type):
            query['datasourceType'] = request.datasource_type
        if not UtilClient.is_unset(request.include_details):
            query['includeDetails'] = request.include_details
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertMetricGroups',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertMetricGroups',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertMetricGroupsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertMetricGroupsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_alert_metric_groups(
        self,
        request: cms_20240330_models.ListAlertMetricGroupsRequest,
    ) -> cms_20240330_models.ListAlertMetricGroupsResponse:
        """
        @summary 查询云监控2.0告警指标分组
        
        @param request: ListAlertMetricGroupsRequest
        @return: ListAlertMetricGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_alert_metric_groups_with_options(request, headers, runtime)

    async def list_alert_metric_groups_async(
        self,
        request: cms_20240330_models.ListAlertMetricGroupsRequest,
    ) -> cms_20240330_models.ListAlertMetricGroupsResponse:
        """
        @summary 查询云监控2.0告警指标分组
        
        @param request: ListAlertMetricGroupsRequest
        @return: ListAlertMetricGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_alert_metric_groups_with_options_async(request, headers, runtime)

    def list_alert_metrics_with_options(
        self,
        request: cms_20240330_models.ListAlertMetricsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertMetricsResponse:
        """
        @summary 查询云监控2.0告警指标列表
        
        @param request: ListAlertMetricsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertMetricsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.alert_metric_id):
            query['alertMetricId'] = request.alert_metric_id
        if not UtilClient.is_unset(request.group):
            query['group'] = request.group
        if not UtilClient.is_unset(request.include_details):
            query['includeDetails'] = request.include_details
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertMetrics',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertMetrics',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertMetricsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertMetricsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_alert_metrics_with_options_async(
        self,
        request: cms_20240330_models.ListAlertMetricsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertMetricsResponse:
        """
        @summary 查询云监控2.0告警指标列表
        
        @param request: ListAlertMetricsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertMetricsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.alert_metric_id):
            query['alertMetricId'] = request.alert_metric_id
        if not UtilClient.is_unset(request.group):
            query['group'] = request.group
        if not UtilClient.is_unset(request.include_details):
            query['includeDetails'] = request.include_details
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertMetrics',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertMetrics',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertMetricsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertMetricsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_alert_metrics(
        self,
        request: cms_20240330_models.ListAlertMetricsRequest,
    ) -> cms_20240330_models.ListAlertMetricsResponse:
        """
        @summary 查询云监控2.0告警指标列表
        
        @param request: ListAlertMetricsRequest
        @return: ListAlertMetricsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_alert_metrics_with_options(request, headers, runtime)

    async def list_alert_metrics_async(
        self,
        request: cms_20240330_models.ListAlertMetricsRequest,
    ) -> cms_20240330_models.ListAlertMetricsResponse:
        """
        @summary 查询云监控2.0告警指标列表
        
        @param request: ListAlertMetricsRequest
        @return: ListAlertMetricsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_alert_metrics_with_options_async(request, headers, runtime)

    def list_alert_notify_templates_with_options(
        self,
        tmp_req: cms_20240330_models.ListAlertNotifyTemplatesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertNotifyTemplatesResponse:
        """
        @summary 查询通知模板
        
        @param tmp_req: ListAlertNotifyTemplatesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertNotifyTemplatesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListAlertNotifyTemplatesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.alert_notify_template_ids):
            request.alert_notify_template_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.alert_notify_template_ids, 'alertNotifyTemplateIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_notify_template_ids_shrink):
            query['alertNotifyTemplateIds'] = request.alert_notify_template_ids_shrink
        if not UtilClient.is_unset(request.alert_notify_template_name):
            query['alertNotifyTemplateName'] = request.alert_notify_template_name
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.program_lang):
            query['programLang'] = request.program_lang
        if not UtilClient.is_unset(request.type):
            query['type'] = request.type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertNotifyTemplates',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertNotifyTemplate',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertNotifyTemplatesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertNotifyTemplatesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_alert_notify_templates_with_options_async(
        self,
        tmp_req: cms_20240330_models.ListAlertNotifyTemplatesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertNotifyTemplatesResponse:
        """
        @summary 查询通知模板
        
        @param tmp_req: ListAlertNotifyTemplatesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertNotifyTemplatesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListAlertNotifyTemplatesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.alert_notify_template_ids):
            request.alert_notify_template_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.alert_notify_template_ids, 'alertNotifyTemplateIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_notify_template_ids_shrink):
            query['alertNotifyTemplateIds'] = request.alert_notify_template_ids_shrink
        if not UtilClient.is_unset(request.alert_notify_template_name):
            query['alertNotifyTemplateName'] = request.alert_notify_template_name
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.program_lang):
            query['programLang'] = request.program_lang
        if not UtilClient.is_unset(request.type):
            query['type'] = request.type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertNotifyTemplates',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertNotifyTemplate',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertNotifyTemplatesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertNotifyTemplatesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_alert_notify_templates(
        self,
        request: cms_20240330_models.ListAlertNotifyTemplatesRequest,
    ) -> cms_20240330_models.ListAlertNotifyTemplatesResponse:
        """
        @summary 查询通知模板
        
        @param request: ListAlertNotifyTemplatesRequest
        @return: ListAlertNotifyTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_alert_notify_templates_with_options(request, headers, runtime)

    async def list_alert_notify_templates_async(
        self,
        request: cms_20240330_models.ListAlertNotifyTemplatesRequest,
    ) -> cms_20240330_models.ListAlertNotifyTemplatesResponse:
        """
        @summary 查询通知模板
        
        @param request: ListAlertNotifyTemplatesRequest
        @return: ListAlertNotifyTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_alert_notify_templates_with_options_async(request, headers, runtime)

    def list_alert_robots_with_options(
        self,
        tmp_req: cms_20240330_models.ListAlertRobotsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertRobotsResponse:
        """
        @summary 查询机器人
        
        @param tmp_req: ListAlertRobotsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertRobotsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListAlertRobotsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.robot_ids):
            request.robot_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.robot_ids, 'robotIds', 'json')
        if not UtilClient.is_unset(tmp_req.types):
            request.types_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.types, 'types', 'json')
        query = {}
        if not UtilClient.is_unset(request.is_custom):
            query['isCustom'] = request.is_custom
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.robot_ids_shrink):
            query['robotIds'] = request.robot_ids_shrink
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.types_shrink):
            query['types'] = request.types_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertRobots',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/robots',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertRobotsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertRobotsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_alert_robots_with_options_async(
        self,
        tmp_req: cms_20240330_models.ListAlertRobotsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertRobotsResponse:
        """
        @summary 查询机器人
        
        @param tmp_req: ListAlertRobotsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertRobotsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListAlertRobotsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.robot_ids):
            request.robot_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.robot_ids, 'robotIds', 'json')
        if not UtilClient.is_unset(tmp_req.types):
            request.types_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.types, 'types', 'json')
        query = {}
        if not UtilClient.is_unset(request.is_custom):
            query['isCustom'] = request.is_custom
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.robot_ids_shrink):
            query['robotIds'] = request.robot_ids_shrink
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.types_shrink):
            query['types'] = request.types_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertRobots',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/robots',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertRobotsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertRobotsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_alert_robots(
        self,
        request: cms_20240330_models.ListAlertRobotsRequest,
    ) -> cms_20240330_models.ListAlertRobotsResponse:
        """
        @summary 查询机器人
        
        @param request: ListAlertRobotsRequest
        @return: ListAlertRobotsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_alert_robots_with_options(request, headers, runtime)

    async def list_alert_robots_async(
        self,
        request: cms_20240330_models.ListAlertRobotsRequest,
    ) -> cms_20240330_models.ListAlertRobotsResponse:
        """
        @summary 查询机器人
        
        @param request: ListAlertRobotsRequest
        @return: ListAlertRobotsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_alert_robots_with_options_async(request, headers, runtime)

    def list_alert_rule_templates_with_options(
        self,
        request: cms_20240330_models.ListAlertRuleTemplatesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertRuleTemplatesResponse:
        """
        @summary 查询告警规则模板
        
        @param request: ListAlertRuleTemplatesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertRuleTemplatesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.alert_rule_template_id):
            query['alertRuleTemplateId'] = request.alert_rule_template_id
        if not UtilClient.is_unset(request.biz_source):
            query['bizSource'] = request.biz_source
        if not UtilClient.is_unset(request.include_details):
            query['includeDetails'] = request.include_details
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertRuleTemplates',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRuleTemplates',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertRuleTemplatesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertRuleTemplatesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_alert_rule_templates_with_options_async(
        self,
        request: cms_20240330_models.ListAlertRuleTemplatesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertRuleTemplatesResponse:
        """
        @summary 查询告警规则模板
        
        @param request: ListAlertRuleTemplatesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertRuleTemplatesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.alert_rule_template_id):
            query['alertRuleTemplateId'] = request.alert_rule_template_id
        if not UtilClient.is_unset(request.biz_source):
            query['bizSource'] = request.biz_source
        if not UtilClient.is_unset(request.include_details):
            query['includeDetails'] = request.include_details
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertRuleTemplates',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRuleTemplates',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertRuleTemplatesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertRuleTemplatesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_alert_rule_templates(
        self,
        request: cms_20240330_models.ListAlertRuleTemplatesRequest,
    ) -> cms_20240330_models.ListAlertRuleTemplatesResponse:
        """
        @summary 查询告警规则模板
        
        @param request: ListAlertRuleTemplatesRequest
        @return: ListAlertRuleTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_alert_rule_templates_with_options(request, headers, runtime)

    async def list_alert_rule_templates_async(
        self,
        request: cms_20240330_models.ListAlertRuleTemplatesRequest,
    ) -> cms_20240330_models.ListAlertRuleTemplatesResponse:
        """
        @summary 查询告警规则模板
        
        @param request: ListAlertRuleTemplatesRequest
        @return: ListAlertRuleTemplatesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_alert_rule_templates_with_options_async(request, headers, runtime)

    def list_alert_rules_with_options(
        self,
        tmp_req: cms_20240330_models.ListAlertRulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertRulesResponse:
        """
        @summary 查询云监控2.0告警规则
        
        @param tmp_req: ListAlertRulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertRulesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListAlertRulesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.label_filter):
            request.label_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.label_filter, 'labelFilter', 'json')
        if not UtilClient.is_unset(tmp_req.notification_filter):
            request.notification_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.notification_filter, 'notificationFilter', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_rule_id):
            query['alertRuleId'] = request.alert_rule_id
        if not UtilClient.is_unset(request.biz_source):
            query['bizSource'] = request.biz_source
        if not UtilClient.is_unset(request.display_name_key_word):
            query['displayNameKeyWord'] = request.display_name_key_word
        if not UtilClient.is_unset(request.enabled):
            query['enabled'] = request.enabled
        if not UtilClient.is_unset(request.label_filter_shrink):
            query['labelFilter'] = request.label_filter_shrink
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.notification_filter_shrink):
            query['notificationFilter'] = request.notification_filter_shrink
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertRules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertRulesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertRulesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_alert_rules_with_options_async(
        self,
        tmp_req: cms_20240330_models.ListAlertRulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertRulesResponse:
        """
        @summary 查询云监控2.0告警规则
        
        @param tmp_req: ListAlertRulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertRulesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListAlertRulesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.label_filter):
            request.label_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.label_filter, 'labelFilter', 'json')
        if not UtilClient.is_unset(tmp_req.notification_filter):
            request.notification_filter_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.notification_filter, 'notificationFilter', 'json')
        query = {}
        if not UtilClient.is_unset(request.alert_rule_id):
            query['alertRuleId'] = request.alert_rule_id
        if not UtilClient.is_unset(request.biz_source):
            query['bizSource'] = request.biz_source
        if not UtilClient.is_unset(request.display_name_key_word):
            query['displayNameKeyWord'] = request.display_name_key_word
        if not UtilClient.is_unset(request.enabled):
            query['enabled'] = request.enabled
        if not UtilClient.is_unset(request.label_filter_shrink):
            query['labelFilter'] = request.label_filter_shrink
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.notification_filter_shrink):
            query['notificationFilter'] = request.notification_filter_shrink
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertRules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertRulesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertRulesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_alert_rules(
        self,
        request: cms_20240330_models.ListAlertRulesRequest,
    ) -> cms_20240330_models.ListAlertRulesResponse:
        """
        @summary 查询云监控2.0告警规则
        
        @param request: ListAlertRulesRequest
        @return: ListAlertRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_alert_rules_with_options(request, headers, runtime)

    async def list_alert_rules_async(
        self,
        request: cms_20240330_models.ListAlertRulesRequest,
    ) -> cms_20240330_models.ListAlertRulesResponse:
        """
        @summary 查询云监控2.0告警规则
        
        @param request: ListAlertRulesRequest
        @return: ListAlertRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_alert_rules_with_options_async(request, headers, runtime)

    def list_alert_webhook_with_options(
        self,
        tmp_req: cms_20240330_models.ListAlertWebhookRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertWebhookResponse:
        """
        @summary 查询Webhook
        
        @param tmp_req: ListAlertWebhookRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertWebhookResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListAlertWebhookShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.types):
            request.types_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.types, 'types', 'json')
        if not UtilClient.is_unset(tmp_req.webhook_ids):
            request.webhook_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.webhook_ids, 'webhookIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.types_shrink):
            query['types'] = request.types_shrink
        if not UtilClient.is_unset(request.webhook_ids_shrink):
            query['webhookIds'] = request.webhook_ids_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertWebhook',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/webhook',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertWebhookResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertWebhookResponse(),
                self.execute(params, req, runtime)
            )

    async def list_alert_webhook_with_options_async(
        self,
        tmp_req: cms_20240330_models.ListAlertWebhookRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertWebhookResponse:
        """
        @summary 查询Webhook
        
        @param tmp_req: ListAlertWebhookRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertWebhookResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListAlertWebhookShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.types):
            request.types_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.types, 'types', 'json')
        if not UtilClient.is_unset(tmp_req.webhook_ids):
            request.webhook_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.webhook_ids, 'webhookIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.types_shrink):
            query['types'] = request.types_shrink
        if not UtilClient.is_unset(request.webhook_ids_shrink):
            query['webhookIds'] = request.webhook_ids_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertWebhook',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/webhook',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertWebhookResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertWebhookResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_alert_webhook(
        self,
        request: cms_20240330_models.ListAlertWebhookRequest,
    ) -> cms_20240330_models.ListAlertWebhookResponse:
        """
        @summary 查询Webhook
        
        @param request: ListAlertWebhookRequest
        @return: ListAlertWebhookResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_alert_webhook_with_options(request, headers, runtime)

    async def list_alert_webhook_async(
        self,
        request: cms_20240330_models.ListAlertWebhookRequest,
    ) -> cms_20240330_models.ListAlertWebhookResponse:
        """
        @summary 查询Webhook
        
        @param request: ListAlertWebhookRequest
        @return: ListAlertWebhookResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_alert_webhook_with_options_async(request, headers, runtime)

    def list_alert_webhooks_with_options(
        self,
        tmp_req: cms_20240330_models.ListAlertWebhooksRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertWebhooksResponse:
        """
        @summary 查询Webhook
        
        @param tmp_req: ListAlertWebhooksRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertWebhooksResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListAlertWebhooksShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.webhook_ids):
            request.webhook_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.webhook_ids, 'webhookIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.is_custom):
            query['isCustom'] = request.is_custom
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.webhook_ids_shrink):
            query['webhookIds'] = request.webhook_ids_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertWebhooks',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/webhooks',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertWebhooksResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertWebhooksResponse(),
                self.execute(params, req, runtime)
            )

    async def list_alert_webhooks_with_options_async(
        self,
        tmp_req: cms_20240330_models.ListAlertWebhooksRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAlertWebhooksResponse:
        """
        @summary 查询Webhook
        
        @param tmp_req: ListAlertWebhooksRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAlertWebhooksResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListAlertWebhooksShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.webhook_ids):
            request.webhook_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.webhook_ids, 'webhookIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.is_custom):
            query['isCustom'] = request.is_custom
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.webhook_ids_shrink):
            query['webhookIds'] = request.webhook_ids_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAlertWebhooks',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/webhooks',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAlertWebhooksResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAlertWebhooksResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_alert_webhooks(
        self,
        request: cms_20240330_models.ListAlertWebhooksRequest,
    ) -> cms_20240330_models.ListAlertWebhooksResponse:
        """
        @summary 查询Webhook
        
        @param request: ListAlertWebhooksRequest
        @return: ListAlertWebhooksResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_alert_webhooks_with_options(request, headers, runtime)

    async def list_alert_webhooks_async(
        self,
        request: cms_20240330_models.ListAlertWebhooksRequest,
    ) -> cms_20240330_models.ListAlertWebhooksResponse:
        """
        @summary 查询Webhook
        
        @param request: ListAlertWebhooksRequest
        @return: ListAlertWebhooksResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_alert_webhooks_with_options_async(request, headers, runtime)

    def list_available_regions_for_cloud_with_options(
        self,
        request: cms_20240330_models.ListAvailableRegionsForCloudRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAvailableRegionsForCloudResponse:
        """
        @summary 展示云服务支持的大区
        
        @param request: ListAvailableRegionsForCloudRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAvailableRegionsForCloudResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['AddonName'] = request.addon_name
        if not UtilClient.is_unset(request.addon_version):
            query['AddonVersion'] = request.addon_version
        if not UtilClient.is_unset(request.aliyun_lang):
            query['AliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAvailableRegionsForCloud',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/ListAvailableRegionsForCloud',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAvailableRegionsForCloudResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAvailableRegionsForCloudResponse(),
                self.execute(params, req, runtime)
            )

    async def list_available_regions_for_cloud_with_options_async(
        self,
        request: cms_20240330_models.ListAvailableRegionsForCloudRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListAvailableRegionsForCloudResponse:
        """
        @summary 展示云服务支持的大区
        
        @param request: ListAvailableRegionsForCloudRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListAvailableRegionsForCloudResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['AddonName'] = request.addon_name
        if not UtilClient.is_unset(request.addon_version):
            query['AddonVersion'] = request.addon_version
        if not UtilClient.is_unset(request.aliyun_lang):
            query['AliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListAvailableRegionsForCloud',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/ListAvailableRegionsForCloud',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListAvailableRegionsForCloudResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListAvailableRegionsForCloudResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_available_regions_for_cloud(
        self,
        request: cms_20240330_models.ListAvailableRegionsForCloudRequest,
    ) -> cms_20240330_models.ListAvailableRegionsForCloudResponse:
        """
        @summary 展示云服务支持的大区
        
        @param request: ListAvailableRegionsForCloudRequest
        @return: ListAvailableRegionsForCloudResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_available_regions_for_cloud_with_options(request, headers, runtime)

    async def list_available_regions_for_cloud_async(
        self,
        request: cms_20240330_models.ListAvailableRegionsForCloudRequest,
    ) -> cms_20240330_models.ListAvailableRegionsForCloudResponse:
        """
        @summary 展示云服务支持的大区
        
        @param request: ListAvailableRegionsForCloudRequest
        @return: ListAvailableRegionsForCloudResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_available_regions_for_cloud_with_options_async(request, headers, runtime)

    def list_biz_traces_with_options(
        self,
        request: cms_20240330_models.ListBizTracesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListBizTracesResponse:
        """
        @summary 业务链路列表
        
        @param request: ListBizTracesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListBizTracesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListBizTraces',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/bizTraces',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListBizTracesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListBizTracesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_biz_traces_with_options_async(
        self,
        request: cms_20240330_models.ListBizTracesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListBizTracesResponse:
        """
        @summary 业务链路列表
        
        @param request: ListBizTracesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListBizTracesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListBizTraces',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/bizTraces',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListBizTracesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListBizTracesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_biz_traces(
        self,
        request: cms_20240330_models.ListBizTracesRequest,
    ) -> cms_20240330_models.ListBizTracesResponse:
        """
        @summary 业务链路列表
        
        @param request: ListBizTracesRequest
        @return: ListBizTracesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_biz_traces_with_options(request, headers, runtime)

    async def list_biz_traces_async(
        self,
        request: cms_20240330_models.ListBizTracesRequest,
    ) -> cms_20240330_models.ListBizTracesResponse:
        """
        @summary 业务链路列表
        
        @param request: ListBizTracesRequest
        @return: ListBizTracesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_biz_traces_with_options_async(request, headers, runtime)

    def list_cluster_apm_workload_with_options(
        self,
        request: cms_20240330_models.ListClusterApmWorkloadRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListClusterApmWorkloadResponse:
        """
        @summary Kubernetes环境下，查询APM集群工作负载
        
        @param request: ListClusterApmWorkloadRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListClusterApmWorkloadResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['clusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.cluster_namespace):
            query['clusterNamespace'] = request.cluster_namespace
        if not UtilClient.is_unset(request.policy_id):
            query['policyId'] = request.policy_id
        if not UtilClient.is_unset(request.workload_name):
            query['workloadName'] = request.workload_name
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListClusterApmWorkload',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/cluster_apm/workload',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListClusterApmWorkloadResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListClusterApmWorkloadResponse(),
                self.execute(params, req, runtime)
            )

    async def list_cluster_apm_workload_with_options_async(
        self,
        request: cms_20240330_models.ListClusterApmWorkloadRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListClusterApmWorkloadResponse:
        """
        @summary Kubernetes环境下，查询APM集群工作负载
        
        @param request: ListClusterApmWorkloadRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListClusterApmWorkloadResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.cluster_id):
            query['clusterId'] = request.cluster_id
        if not UtilClient.is_unset(request.cluster_namespace):
            query['clusterNamespace'] = request.cluster_namespace
        if not UtilClient.is_unset(request.policy_id):
            query['policyId'] = request.policy_id
        if not UtilClient.is_unset(request.workload_name):
            query['workloadName'] = request.workload_name
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListClusterApmWorkload',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/cluster_apm/workload',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListClusterApmWorkloadResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListClusterApmWorkloadResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_cluster_apm_workload(
        self,
        request: cms_20240330_models.ListClusterApmWorkloadRequest,
    ) -> cms_20240330_models.ListClusterApmWorkloadResponse:
        """
        @summary Kubernetes环境下，查询APM集群工作负载
        
        @param request: ListClusterApmWorkloadRequest
        @return: ListClusterApmWorkloadResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_cluster_apm_workload_with_options(request, headers, runtime)

    async def list_cluster_apm_workload_async(
        self,
        request: cms_20240330_models.ListClusterApmWorkloadRequest,
    ) -> cms_20240330_models.ListClusterApmWorkloadResponse:
        """
        @summary Kubernetes环境下，查询APM集群工作负载
        
        @param request: ListClusterApmWorkloadRequest
        @return: ListClusterApmWorkloadResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_cluster_apm_workload_with_options_async(request, headers, runtime)

    def list_contact_with_options(
        self,
        tmp_req: cms_20240330_models.ListContactRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListContactResponse:
        """
        @summary 查询联系人
        
        @param tmp_req: ListContactRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListContactResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListContactShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.contact_ids):
            request.contact_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.contact_ids, 'contactIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.contact_ids_shrink):
            query['contactIds'] = request.contact_ids_shrink
        if not UtilClient.is_unset(request.email):
            query['email'] = request.email
        if not UtilClient.is_unset(request.group_identifier):
            query['groupIdentifier'] = request.group_identifier
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.phone):
            query['phone'] = request.phone
        if not UtilClient.is_unset(request.query_ungrouped_contacts):
            query['queryUngroupedContacts'] = request.query_ungrouped_contacts
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListContact',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contact',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListContactResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListContactResponse(),
                self.execute(params, req, runtime)
            )

    async def list_contact_with_options_async(
        self,
        tmp_req: cms_20240330_models.ListContactRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListContactResponse:
        """
        @summary 查询联系人
        
        @param tmp_req: ListContactRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListContactResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListContactShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.contact_ids):
            request.contact_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.contact_ids, 'contactIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.contact_ids_shrink):
            query['contactIds'] = request.contact_ids_shrink
        if not UtilClient.is_unset(request.email):
            query['email'] = request.email
        if not UtilClient.is_unset(request.group_identifier):
            query['groupIdentifier'] = request.group_identifier
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.phone):
            query['phone'] = request.phone
        if not UtilClient.is_unset(request.query_ungrouped_contacts):
            query['queryUngroupedContacts'] = request.query_ungrouped_contacts
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListContact',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contact',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListContactResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListContactResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_contact(
        self,
        request: cms_20240330_models.ListContactRequest,
    ) -> cms_20240330_models.ListContactResponse:
        """
        @summary 查询联系人
        
        @param request: ListContactRequest
        @return: ListContactResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_contact_with_options(request, headers, runtime)

    async def list_contact_async(
        self,
        request: cms_20240330_models.ListContactRequest,
    ) -> cms_20240330_models.ListContactResponse:
        """
        @summary 查询联系人
        
        @param request: ListContactRequest
        @return: ListContactResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_contact_with_options_async(request, headers, runtime)

    def list_contact_group_with_options(
        self,
        tmp_req: cms_20240330_models.ListContactGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListContactGroupResponse:
        """
        @summary 查询联系人组
        
        @param tmp_req: ListContactGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListContactGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListContactGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.contact_group_ids):
            request.contact_group_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.contact_group_ids, 'contactGroupIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.contact_group_ids_shrink):
            query['contactGroupIds'] = request.contact_group_ids_shrink
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListContactGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contactGroup',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListContactGroupResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListContactGroupResponse(),
                self.execute(params, req, runtime)
            )

    async def list_contact_group_with_options_async(
        self,
        tmp_req: cms_20240330_models.ListContactGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListContactGroupResponse:
        """
        @summary 查询联系人组
        
        @param tmp_req: ListContactGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListContactGroupResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListContactGroupShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.contact_group_ids):
            request.contact_group_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.contact_group_ids, 'contactGroupIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.contact_group_ids_shrink):
            query['contactGroupIds'] = request.contact_group_ids_shrink
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListContactGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contactGroup',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListContactGroupResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListContactGroupResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_contact_group(
        self,
        request: cms_20240330_models.ListContactGroupRequest,
    ) -> cms_20240330_models.ListContactGroupResponse:
        """
        @summary 查询联系人组
        
        @param request: ListContactGroupRequest
        @return: ListContactGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_contact_group_with_options(request, headers, runtime)

    async def list_contact_group_async(
        self,
        request: cms_20240330_models.ListContactGroupRequest,
    ) -> cms_20240330_models.ListContactGroupResponse:
        """
        @summary 查询联系人组
        
        @param request: ListContactGroupRequest
        @return: ListContactGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_contact_group_with_options_async(request, headers, runtime)

    def list_contact_groups_with_options(
        self,
        tmp_req: cms_20240330_models.ListContactGroupsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListContactGroupsResponse:
        """
        @summary 查询联系人组
        
        @param tmp_req: ListContactGroupsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListContactGroupsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListContactGroupsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.contact_group_ids):
            request.contact_group_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.contact_group_ids, 'contactGroupIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.contact_group_ids_shrink):
            query['contactGroupIds'] = request.contact_group_ids_shrink
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListContactGroups',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contactGroups',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListContactGroupsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListContactGroupsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_contact_groups_with_options_async(
        self,
        tmp_req: cms_20240330_models.ListContactGroupsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListContactGroupsResponse:
        """
        @summary 查询联系人组
        
        @param tmp_req: ListContactGroupsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListContactGroupsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListContactGroupsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.contact_group_ids):
            request.contact_group_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.contact_group_ids, 'contactGroupIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.contact_group_ids_shrink):
            query['contactGroupIds'] = request.contact_group_ids_shrink
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListContactGroups',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contactGroups',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListContactGroupsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListContactGroupsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_contact_groups(
        self,
        request: cms_20240330_models.ListContactGroupsRequest,
    ) -> cms_20240330_models.ListContactGroupsResponse:
        """
        @summary 查询联系人组
        
        @param request: ListContactGroupsRequest
        @return: ListContactGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_contact_groups_with_options(request, headers, runtime)

    async def list_contact_groups_async(
        self,
        request: cms_20240330_models.ListContactGroupsRequest,
    ) -> cms_20240330_models.ListContactGroupsResponse:
        """
        @summary 查询联系人组
        
        @param request: ListContactGroupsRequest
        @return: ListContactGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_contact_groups_with_options_async(request, headers, runtime)

    def list_contacts_with_options(
        self,
        tmp_req: cms_20240330_models.ListContactsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListContactsResponse:
        """
        @summary 查询联系人
        
        @param tmp_req: ListContactsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListContactsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListContactsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.contact_ids):
            request.contact_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.contact_ids, 'contactIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.contact_ids_shrink):
            query['contactIds'] = request.contact_ids_shrink
        if not UtilClient.is_unset(request.email):
            query['email'] = request.email
        if not UtilClient.is_unset(request.group_id):
            query['groupId'] = request.group_id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.phone):
            query['phone'] = request.phone
        if not UtilClient.is_unset(request.query_ungrouped_contacts):
            query['queryUngroupedContacts'] = request.query_ungrouped_contacts
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListContacts',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contact',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListContactsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListContactsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_contacts_with_options_async(
        self,
        tmp_req: cms_20240330_models.ListContactsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListContactsResponse:
        """
        @summary 查询联系人
        
        @param tmp_req: ListContactsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListContactsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListContactsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.contact_ids):
            request.contact_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.contact_ids, 'contactIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.contact_ids_shrink):
            query['contactIds'] = request.contact_ids_shrink
        if not UtilClient.is_unset(request.email):
            query['email'] = request.email
        if not UtilClient.is_unset(request.group_id):
            query['groupId'] = request.group_id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.phone):
            query['phone'] = request.phone
        if not UtilClient.is_unset(request.query_ungrouped_contacts):
            query['queryUngroupedContacts'] = request.query_ungrouped_contacts
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListContacts',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contact',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListContactsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListContactsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_contacts(
        self,
        request: cms_20240330_models.ListContactsRequest,
    ) -> cms_20240330_models.ListContactsResponse:
        """
        @summary 查询联系人
        
        @param request: ListContactsRequest
        @return: ListContactsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_contacts_with_options(request, headers, runtime)

    async def list_contacts_async(
        self,
        request: cms_20240330_models.ListContactsRequest,
    ) -> cms_20240330_models.ListContactsResponse:
        """
        @summary 查询联系人
        
        @param request: ListContactsRequest
        @return: ListContactsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_contacts_with_options_async(request, headers, runtime)

    def list_entity_groups_with_options(
        self,
        request: cms_20240330_models.ListEntityGroupsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEntityGroupsResponse:
        """
        @summary 实体组列表
        
        @param request: ListEntityGroupsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEntityGroupsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEntityGroups',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/entity-groups',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEntityGroupsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEntityGroupsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_entity_groups_with_options_async(
        self,
        request: cms_20240330_models.ListEntityGroupsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEntityGroupsResponse:
        """
        @summary 实体组列表
        
        @param request: ListEntityGroupsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEntityGroupsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEntityGroups',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/entity-groups',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEntityGroupsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEntityGroupsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_entity_groups(
        self,
        request: cms_20240330_models.ListEntityGroupsRequest,
    ) -> cms_20240330_models.ListEntityGroupsResponse:
        """
        @summary 实体组列表
        
        @param request: ListEntityGroupsRequest
        @return: ListEntityGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_entity_groups_with_options(request, headers, runtime)

    async def list_entity_groups_async(
        self,
        request: cms_20240330_models.ListEntityGroupsRequest,
    ) -> cms_20240330_models.ListEntityGroupsResponse:
        """
        @summary 实体组列表
        
        @param request: ListEntityGroupsRequest
        @return: ListEntityGroupsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_entity_groups_with_options_async(request, headers, runtime)

    def list_env_kubernetes_namespaces_with_options(
        self,
        request: cms_20240330_models.ListEnvKubernetesNamespacesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEnvKubernetesNamespacesResponse:
        """
        @summary 查询指定容器实例的namespace列表
        
        @param request: ListEnvKubernetesNamespacesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEnvKubernetesNamespacesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEnvKubernetesNamespaces',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/ListEnvKubernetesNamespaces',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEnvKubernetesNamespacesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEnvKubernetesNamespacesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_env_kubernetes_namespaces_with_options_async(
        self,
        request: cms_20240330_models.ListEnvKubernetesNamespacesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEnvKubernetesNamespacesResponse:
        """
        @summary 查询指定容器实例的namespace列表
        
        @param request: ListEnvKubernetesNamespacesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEnvKubernetesNamespacesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEnvKubernetesNamespaces',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/ListEnvKubernetesNamespaces',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEnvKubernetesNamespacesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEnvKubernetesNamespacesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_env_kubernetes_namespaces(
        self,
        request: cms_20240330_models.ListEnvKubernetesNamespacesRequest,
    ) -> cms_20240330_models.ListEnvKubernetesNamespacesResponse:
        """
        @summary 查询指定容器实例的namespace列表
        
        @param request: ListEnvKubernetesNamespacesRequest
        @return: ListEnvKubernetesNamespacesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_env_kubernetes_namespaces_with_options(request, headers, runtime)

    async def list_env_kubernetes_namespaces_async(
        self,
        request: cms_20240330_models.ListEnvKubernetesNamespacesRequest,
    ) -> cms_20240330_models.ListEnvKubernetesNamespacesResponse:
        """
        @summary 查询指定容器实例的namespace列表
        
        @param request: ListEnvKubernetesNamespacesRequest
        @return: ListEnvKubernetesNamespacesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_env_kubernetes_namespaces_with_options_async(request, headers, runtime)

    def list_env_kubernetes_services_with_options(
        self,
        request: cms_20240330_models.ListEnvKubernetesServicesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEnvKubernetesServicesResponse:
        """
        @summary 查询指定容器实例的servcie列表
        
        @param request: ListEnvKubernetesServicesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEnvKubernetesServicesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.namespace):
            query['Namespace'] = request.namespace
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEnvKubernetesServices',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/ListEnvKubernetesServices',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEnvKubernetesServicesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEnvKubernetesServicesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_env_kubernetes_services_with_options_async(
        self,
        request: cms_20240330_models.ListEnvKubernetesServicesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEnvKubernetesServicesResponse:
        """
        @summary 查询指定容器实例的servcie列表
        
        @param request: ListEnvKubernetesServicesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEnvKubernetesServicesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.namespace):
            query['Namespace'] = request.namespace
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEnvKubernetesServices',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/ListEnvKubernetesServices',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEnvKubernetesServicesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEnvKubernetesServicesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_env_kubernetes_services(
        self,
        request: cms_20240330_models.ListEnvKubernetesServicesRequest,
    ) -> cms_20240330_models.ListEnvKubernetesServicesResponse:
        """
        @summary 查询指定容器实例的servcie列表
        
        @param request: ListEnvKubernetesServicesRequest
        @return: ListEnvKubernetesServicesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_env_kubernetes_services_with_options(request, headers, runtime)

    async def list_env_kubernetes_services_async(
        self,
        request: cms_20240330_models.ListEnvKubernetesServicesRequest,
    ) -> cms_20240330_models.ListEnvKubernetesServicesResponse:
        """
        @summary 查询指定容器实例的servcie列表
        
        @param request: ListEnvKubernetesServicesRequest
        @return: ListEnvKubernetesServicesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_env_kubernetes_services_with_options_async(request, headers, runtime)

    def list_env_pods_by_pod_annotation_with_options(
        self,
        request: cms_20240330_models.ListEnvPodsByPodAnnotationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEnvPodsByPodAnnotationResponse:
        """
        @summary 查询环境实例的podAnnotation的结果列表
        
        @param request: ListEnvPodsByPodAnnotationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEnvPodsByPodAnnotationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEnvPodsByPodAnnotation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/ListEnvPodsByPodAnnotation',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEnvPodsByPodAnnotationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEnvPodsByPodAnnotationResponse(),
                self.execute(params, req, runtime)
            )

    async def list_env_pods_by_pod_annotation_with_options_async(
        self,
        request: cms_20240330_models.ListEnvPodsByPodAnnotationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEnvPodsByPodAnnotationResponse:
        """
        @summary 查询环境实例的podAnnotation的结果列表
        
        @param request: ListEnvPodsByPodAnnotationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEnvPodsByPodAnnotationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEnvPodsByPodAnnotation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/ListEnvPodsByPodAnnotation',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEnvPodsByPodAnnotationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEnvPodsByPodAnnotationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_env_pods_by_pod_annotation(
        self,
        request: cms_20240330_models.ListEnvPodsByPodAnnotationRequest,
    ) -> cms_20240330_models.ListEnvPodsByPodAnnotationResponse:
        """
        @summary 查询环境实例的podAnnotation的结果列表
        
        @param request: ListEnvPodsByPodAnnotationRequest
        @return: ListEnvPodsByPodAnnotationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_env_pods_by_pod_annotation_with_options(request, headers, runtime)

    async def list_env_pods_by_pod_annotation_async(
        self,
        request: cms_20240330_models.ListEnvPodsByPodAnnotationRequest,
    ) -> cms_20240330_models.ListEnvPodsByPodAnnotationResponse:
        """
        @summary 查询环境实例的podAnnotation的结果列表
        
        @param request: ListEnvPodsByPodAnnotationRequest
        @return: ListEnvPodsByPodAnnotationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_env_pods_by_pod_annotation_with_options_async(request, headers, runtime)

    def list_environment_alert_rules_with_options(
        self,
        request: cms_20240330_models.ListEnvironmentAlertRulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEnvironmentAlertRulesResponse:
        """
        @summary 环境的告警组列表
        
        @param request: ListEnvironmentAlertRulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEnvironmentAlertRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['AddonName'] = request.addon_name
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene):
            query['Scene'] = request.scene
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEnvironmentAlertRules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/ListEnvironmentAlertRules',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEnvironmentAlertRulesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEnvironmentAlertRulesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_environment_alert_rules_with_options_async(
        self,
        request: cms_20240330_models.ListEnvironmentAlertRulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEnvironmentAlertRulesResponse:
        """
        @summary 环境的告警组列表
        
        @param request: ListEnvironmentAlertRulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEnvironmentAlertRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['AddonName'] = request.addon_name
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.scene):
            query['Scene'] = request.scene
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEnvironmentAlertRules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/ListEnvironmentAlertRules',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEnvironmentAlertRulesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEnvironmentAlertRulesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_environment_alert_rules(
        self,
        request: cms_20240330_models.ListEnvironmentAlertRulesRequest,
    ) -> cms_20240330_models.ListEnvironmentAlertRulesResponse:
        """
        @summary 环境的告警组列表
        
        @param request: ListEnvironmentAlertRulesRequest
        @return: ListEnvironmentAlertRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_environment_alert_rules_with_options(request, headers, runtime)

    async def list_environment_alert_rules_async(
        self,
        request: cms_20240330_models.ListEnvironmentAlertRulesRequest,
    ) -> cms_20240330_models.ListEnvironmentAlertRulesResponse:
        """
        @summary 环境的告警组列表
        
        @param request: ListEnvironmentAlertRulesRequest
        @return: ListEnvironmentAlertRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_environment_alert_rules_with_options_async(request, headers, runtime)

    def list_environment_features_with_options(
        self,
        environment_id: str,
        request: cms_20240330_models.ListEnvironmentFeaturesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEnvironmentFeaturesResponse:
        """
        @summary 环境的feature列表
        
        @param request: ListEnvironmentFeaturesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEnvironmentFeaturesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['AliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEnvironmentFeatures',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/feature/rest/{OpenApiUtilClient.get_encode_param(environment_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEnvironmentFeaturesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEnvironmentFeaturesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_environment_features_with_options_async(
        self,
        environment_id: str,
        request: cms_20240330_models.ListEnvironmentFeaturesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEnvironmentFeaturesResponse:
        """
        @summary 环境的feature列表
        
        @param request: ListEnvironmentFeaturesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEnvironmentFeaturesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['AliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEnvironmentFeatures',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/feature/rest/{OpenApiUtilClient.get_encode_param(environment_id)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEnvironmentFeaturesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEnvironmentFeaturesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_environment_features(
        self,
        environment_id: str,
        request: cms_20240330_models.ListEnvironmentFeaturesRequest,
    ) -> cms_20240330_models.ListEnvironmentFeaturesResponse:
        """
        @summary 环境的feature列表
        
        @param request: ListEnvironmentFeaturesRequest
        @return: ListEnvironmentFeaturesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_environment_features_with_options(environment_id, request, headers, runtime)

    async def list_environment_features_async(
        self,
        environment_id: str,
        request: cms_20240330_models.ListEnvironmentFeaturesRequest,
    ) -> cms_20240330_models.ListEnvironmentFeaturesResponse:
        """
        @summary 环境的feature列表
        
        @param request: ListEnvironmentFeaturesRequest
        @return: ListEnvironmentFeaturesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_environment_features_with_options_async(environment_id, request, headers, runtime)

    def list_environment_resources_with_options(
        self,
        request: cms_20240330_models.ListEnvironmentResourcesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEnvironmentResourcesResponse:
        """
        @summary 查询环境资源列表
        
        @param request: ListEnvironmentResourcesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEnvironmentResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bind_resource_id):
            query['BindResourceId'] = request.bind_resource_id
        if not UtilClient.is_unset(request.bind_resource_name):
            query['BindResourceName'] = request.bind_resource_name
        if not UtilClient.is_unset(request.environment_sub_type):
            query['EnvironmentSubType'] = request.environment_sub_type
        if not UtilClient.is_unset(request.environment_type):
            query['EnvironmentType'] = request.environment_type
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEnvironmentResources',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/ListEnvironmentResources',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEnvironmentResourcesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEnvironmentResourcesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_environment_resources_with_options_async(
        self,
        request: cms_20240330_models.ListEnvironmentResourcesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEnvironmentResourcesResponse:
        """
        @summary 查询环境资源列表
        
        @param request: ListEnvironmentResourcesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEnvironmentResourcesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.bind_resource_id):
            query['BindResourceId'] = request.bind_resource_id
        if not UtilClient.is_unset(request.bind_resource_name):
            query['BindResourceName'] = request.bind_resource_name
        if not UtilClient.is_unset(request.environment_sub_type):
            query['EnvironmentSubType'] = request.environment_sub_type
        if not UtilClient.is_unset(request.environment_type):
            query['EnvironmentType'] = request.environment_type
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEnvironmentResources',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/ListEnvironmentResources',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEnvironmentResourcesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEnvironmentResourcesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_environment_resources(
        self,
        request: cms_20240330_models.ListEnvironmentResourcesRequest,
    ) -> cms_20240330_models.ListEnvironmentResourcesResponse:
        """
        @summary 查询环境资源列表
        
        @param request: ListEnvironmentResourcesRequest
        @return: ListEnvironmentResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_environment_resources_with_options(request, headers, runtime)

    async def list_environment_resources_async(
        self,
        request: cms_20240330_models.ListEnvironmentResourcesRequest,
    ) -> cms_20240330_models.ListEnvironmentResourcesResponse:
        """
        @summary 查询环境资源列表
        
        @param request: ListEnvironmentResourcesRequest
        @return: ListEnvironmentResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_environment_resources_with_options_async(request, headers, runtime)

    def list_environments_with_options(
        self,
        tmp_req: cms_20240330_models.ListEnvironmentsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEnvironmentsResponse:
        """
        @summary 查询环境实例的列表
        
        @param tmp_req: ListEnvironmentsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEnvironmentsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListEnvironmentsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.tag):
            request.tag_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.tag, 'Tag', 'json')
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['AddonName'] = request.addon_name
        if not UtilClient.is_unset(request.bind_resource_id):
            query['BindResourceId'] = request.bind_resource_id
        if not UtilClient.is_unset(request.environment_type):
            query['EnvironmentType'] = request.environment_type
        if not UtilClient.is_unset(request.fee_package):
            query['FeePackage'] = request.fee_package
        if not UtilClient.is_unset(request.filter_region_ids):
            query['FilterRegionIds'] = request.filter_region_ids
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.tag_shrink):
            query['Tag'] = request.tag_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEnvironments',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/environment/rest',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEnvironmentsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEnvironmentsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_environments_with_options_async(
        self,
        tmp_req: cms_20240330_models.ListEnvironmentsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEnvironmentsResponse:
        """
        @summary 查询环境实例的列表
        
        @param tmp_req: ListEnvironmentsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEnvironmentsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListEnvironmentsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.tag):
            request.tag_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.tag, 'Tag', 'json')
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['AddonName'] = request.addon_name
        if not UtilClient.is_unset(request.bind_resource_id):
            query['BindResourceId'] = request.bind_resource_id
        if not UtilClient.is_unset(request.environment_type):
            query['EnvironmentType'] = request.environment_type
        if not UtilClient.is_unset(request.fee_package):
            query['FeePackage'] = request.fee_package
        if not UtilClient.is_unset(request.filter_region_ids):
            query['FilterRegionIds'] = request.filter_region_ids
        if not UtilClient.is_unset(request.page_number):
            query['PageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['PageSize'] = request.page_size
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        if not UtilClient.is_unset(request.resource_group_id):
            query['ResourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.tag_shrink):
            query['Tag'] = request.tag_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEnvironments',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/environment/rest',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEnvironmentsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEnvironmentsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_environments(
        self,
        request: cms_20240330_models.ListEnvironmentsRequest,
    ) -> cms_20240330_models.ListEnvironmentsResponse:
        """
        @summary 查询环境实例的列表
        
        @param request: ListEnvironmentsRequest
        @return: ListEnvironmentsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_environments_with_options(request, headers, runtime)

    async def list_environments_async(
        self,
        request: cms_20240330_models.ListEnvironmentsRequest,
    ) -> cms_20240330_models.ListEnvironmentsResponse:
        """
        @summary 查询环境实例的列表
        
        @param request: ListEnvironmentsRequest
        @return: ListEnvironmentsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_environments_with_options_async(request, headers, runtime)

    def list_escalation_with_options(
        self,
        request: cms_20240330_models.ListEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEscalationResponse:
        """
        @summary List Escalation name
        
        @param request: ListEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.enable):
            query['enable'] = request.enable
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.owner_product):
            query['ownerProduct'] = request.owner_product
        if not UtilClient.is_unset(request.page):
            query['page'] = request.page
        if not UtilClient.is_unset(request.size):
            query['size'] = request.size
        if not UtilClient.is_unset(request.uuid):
            query['uuid'] = request.uuid
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/escalations',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEscalationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEscalationResponse(),
                self.execute(params, req, runtime)
            )

    async def list_escalation_with_options_async(
        self,
        request: cms_20240330_models.ListEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEscalationResponse:
        """
        @summary List Escalation name
        
        @param request: ListEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.enable):
            query['enable'] = request.enable
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.owner_product):
            query['ownerProduct'] = request.owner_product
        if not UtilClient.is_unset(request.page):
            query['page'] = request.page
        if not UtilClient.is_unset(request.size):
            query['size'] = request.size
        if not UtilClient.is_unset(request.uuid):
            query['uuid'] = request.uuid
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/escalations',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEscalationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEscalationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_escalation(
        self,
        request: cms_20240330_models.ListEscalationRequest,
    ) -> cms_20240330_models.ListEscalationResponse:
        """
        @summary List Escalation name
        
        @param request: ListEscalationRequest
        @return: ListEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_escalation_with_options(request, headers, runtime)

    async def list_escalation_async(
        self,
        request: cms_20240330_models.ListEscalationRequest,
    ) -> cms_20240330_models.ListEscalationResponse:
        """
        @summary List Escalation name
        
        @param request: ListEscalationRequest
        @return: ListEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_escalation_with_options_async(request, headers, runtime)

    def list_event_label_cache_keys_with_options(
        self,
        request: cms_20240330_models.ListEventLabelCacheKeysRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEventLabelCacheKeysResponse:
        """
        @summary 从缓存中获取最近60天内所有获取到的事件标签Key
        
        @param request: ListEventLabelCacheKeysRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEventLabelCacheKeysResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.key):
            query['key'] = request.key
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEventLabelCacheKeys',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/label/keys',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEventLabelCacheKeysResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEventLabelCacheKeysResponse(),
                self.execute(params, req, runtime)
            )

    async def list_event_label_cache_keys_with_options_async(
        self,
        request: cms_20240330_models.ListEventLabelCacheKeysRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEventLabelCacheKeysResponse:
        """
        @summary 从缓存中获取最近60天内所有获取到的事件标签Key
        
        @param request: ListEventLabelCacheKeysRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEventLabelCacheKeysResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.key):
            query['key'] = request.key
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEventLabelCacheKeys',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/label/keys',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEventLabelCacheKeysResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEventLabelCacheKeysResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_event_label_cache_keys(
        self,
        request: cms_20240330_models.ListEventLabelCacheKeysRequest,
    ) -> cms_20240330_models.ListEventLabelCacheKeysResponse:
        """
        @summary 从缓存中获取最近60天内所有获取到的事件标签Key
        
        @param request: ListEventLabelCacheKeysRequest
        @return: ListEventLabelCacheKeysResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_event_label_cache_keys_with_options(request, headers, runtime)

    async def list_event_label_cache_keys_async(
        self,
        request: cms_20240330_models.ListEventLabelCacheKeysRequest,
    ) -> cms_20240330_models.ListEventLabelCacheKeysResponse:
        """
        @summary 从缓存中获取最近60天内所有获取到的事件标签Key
        
        @param request: ListEventLabelCacheKeysRequest
        @return: ListEventLabelCacheKeysResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_event_label_cache_keys_with_options_async(request, headers, runtime)

    def list_event_label_cache_values_with_options(
        self,
        request: cms_20240330_models.ListEventLabelCacheValuesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEventLabelCacheValuesResponse:
        """
        @summary 获取近60天一个key TOP N 可能value
        
        @param request: ListEventLabelCacheValuesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEventLabelCacheValuesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.key):
            query['key'] = request.key
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.value):
            query['value'] = request.value
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEventLabelCacheValues',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/label/values',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEventLabelCacheValuesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEventLabelCacheValuesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_event_label_cache_values_with_options_async(
        self,
        request: cms_20240330_models.ListEventLabelCacheValuesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListEventLabelCacheValuesResponse:
        """
        @summary 获取近60天一个key TOP N 可能value
        
        @param request: ListEventLabelCacheValuesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListEventLabelCacheValuesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.key):
            query['key'] = request.key
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.value):
            query['value'] = request.value
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListEventLabelCacheValues',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/label/values',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListEventLabelCacheValuesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListEventLabelCacheValuesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_event_label_cache_values(
        self,
        request: cms_20240330_models.ListEventLabelCacheValuesRequest,
    ) -> cms_20240330_models.ListEventLabelCacheValuesResponse:
        """
        @summary 获取近60天一个key TOP N 可能value
        
        @param request: ListEventLabelCacheValuesRequest
        @return: ListEventLabelCacheValuesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_event_label_cache_values_with_options(request, headers, runtime)

    async def list_event_label_cache_values_async(
        self,
        request: cms_20240330_models.ListEventLabelCacheValuesRequest,
    ) -> cms_20240330_models.ListEventLabelCacheValuesResponse:
        """
        @summary 获取近60天一个key TOP N 可能value
        
        @param request: ListEventLabelCacheValuesRequest
        @return: ListEventLabelCacheValuesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_event_label_cache_values_with_options_async(request, headers, runtime)

    def list_histograms_with_options(
        self,
        request: cms_20240330_models.ListHistogramsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListHistogramsResponse:
        """
        @summary 报警历史列表
        
        @param request: ListHistogramsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListHistogramsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.batch_id):
            query['batchId'] = request.batch_id
        if not UtilClient.is_unset(request.contact):
            query['contact'] = request.contact
        if not UtilClient.is_unset(request.contact_group):
            query['contactGroup'] = request.contact_group
        if not UtilClient.is_unset(request.enable):
            query['enable'] = request.enable
        if not UtilClient.is_unset(request.from_):
            query['from'] = request.from_
        if not UtilClient.is_unset(request.grouping_id):
            query['groupingId'] = request.grouping_id
        if not UtilClient.is_unset(request.grouping_string):
            query['groupingString'] = request.grouping_string
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.owner_product):
            query['ownerProduct'] = request.owner_product
        if not UtilClient.is_unset(request.page):
            query['page'] = request.page
        if not UtilClient.is_unset(request.receiver):
            query['receiver'] = request.receiver
        if not UtilClient.is_unset(request.severity):
            query['severity'] = request.severity
        if not UtilClient.is_unset(request.size):
            query['size'] = request.size
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.strategy_name):
            query['strategyName'] = request.strategy_name
        if not UtilClient.is_unset(request.strategy_uuid):
            query['strategyUuid'] = request.strategy_uuid
        if not UtilClient.is_unset(request.to):
            query['to'] = request.to
        if not UtilClient.is_unset(request.uuid):
            query['uuid'] = request.uuid
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListHistograms',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/histograms',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListHistogramsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListHistogramsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_histograms_with_options_async(
        self,
        request: cms_20240330_models.ListHistogramsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListHistogramsResponse:
        """
        @summary 报警历史列表
        
        @param request: ListHistogramsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListHistogramsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.batch_id):
            query['batchId'] = request.batch_id
        if not UtilClient.is_unset(request.contact):
            query['contact'] = request.contact
        if not UtilClient.is_unset(request.contact_group):
            query['contactGroup'] = request.contact_group
        if not UtilClient.is_unset(request.enable):
            query['enable'] = request.enable
        if not UtilClient.is_unset(request.from_):
            query['from'] = request.from_
        if not UtilClient.is_unset(request.grouping_id):
            query['groupingId'] = request.grouping_id
        if not UtilClient.is_unset(request.grouping_string):
            query['groupingString'] = request.grouping_string
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.owner_product):
            query['ownerProduct'] = request.owner_product
        if not UtilClient.is_unset(request.page):
            query['page'] = request.page
        if not UtilClient.is_unset(request.receiver):
            query['receiver'] = request.receiver
        if not UtilClient.is_unset(request.severity):
            query['severity'] = request.severity
        if not UtilClient.is_unset(request.size):
            query['size'] = request.size
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.strategy_name):
            query['strategyName'] = request.strategy_name
        if not UtilClient.is_unset(request.strategy_uuid):
            query['strategyUuid'] = request.strategy_uuid
        if not UtilClient.is_unset(request.to):
            query['to'] = request.to
        if not UtilClient.is_unset(request.uuid):
            query['uuid'] = request.uuid
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListHistograms',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/histograms',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListHistogramsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListHistogramsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_histograms(
        self,
        request: cms_20240330_models.ListHistogramsRequest,
    ) -> cms_20240330_models.ListHistogramsResponse:
        """
        @summary 报警历史列表
        
        @param request: ListHistogramsRequest
        @return: ListHistogramsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_histograms_with_options(request, headers, runtime)

    async def list_histograms_async(
        self,
        request: cms_20240330_models.ListHistogramsRequest,
    ) -> cms_20240330_models.ListHistogramsResponse:
        """
        @summary 报警历史列表
        
        @param request: ListHistogramsRequest
        @return: ListHistogramsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_histograms_with_options_async(request, headers, runtime)

    def list_histories_with_options(
        self,
        request: cms_20240330_models.ListHistoriesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListHistoriesResponse:
        """
        @summary List History name
        
        @param request: ListHistoriesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListHistoriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.batch_id):
            query['batchId'] = request.batch_id
        if not UtilClient.is_unset(request.contact):
            query['contact'] = request.contact
        if not UtilClient.is_unset(request.contact_group):
            query['contactGroup'] = request.contact_group
        if not UtilClient.is_unset(request.from_):
            query['from'] = request.from_
        if not UtilClient.is_unset(request.grouping_id):
            query['groupingId'] = request.grouping_id
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.receiver):
            query['receiver'] = request.receiver
        if not UtilClient.is_unset(request.severity):
            query['severity'] = request.severity
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.strategy_name):
            query['strategyName'] = request.strategy_name
        if not UtilClient.is_unset(request.strategy_uuid):
            query['strategyUuid'] = request.strategy_uuid
        if not UtilClient.is_unset(request.to):
            query['to'] = request.to
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListHistories',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/histories',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListHistoriesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListHistoriesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_histories_with_options_async(
        self,
        request: cms_20240330_models.ListHistoriesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListHistoriesResponse:
        """
        @summary List History name
        
        @param request: ListHistoriesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListHistoriesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.batch_id):
            query['batchId'] = request.batch_id
        if not UtilClient.is_unset(request.contact):
            query['contact'] = request.contact
        if not UtilClient.is_unset(request.contact_group):
            query['contactGroup'] = request.contact_group
        if not UtilClient.is_unset(request.from_):
            query['from'] = request.from_
        if not UtilClient.is_unset(request.grouping_id):
            query['groupingId'] = request.grouping_id
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.receiver):
            query['receiver'] = request.receiver
        if not UtilClient.is_unset(request.severity):
            query['severity'] = request.severity
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.strategy_name):
            query['strategyName'] = request.strategy_name
        if not UtilClient.is_unset(request.strategy_uuid):
            query['strategyUuid'] = request.strategy_uuid
        if not UtilClient.is_unset(request.to):
            query['to'] = request.to
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListHistories',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/histories',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListHistoriesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListHistoriesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_histories(
        self,
        request: cms_20240330_models.ListHistoriesRequest,
    ) -> cms_20240330_models.ListHistoriesResponse:
        """
        @summary List History name
        
        @param request: ListHistoriesRequest
        @return: ListHistoriesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_histories_with_options(request, headers, runtime)

    async def list_histories_async(
        self,
        request: cms_20240330_models.ListHistoriesRequest,
    ) -> cms_20240330_models.ListHistoriesResponse:
        """
        @summary List History name
        
        @param request: ListHistoriesRequest
        @return: ListHistoriesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_histories_with_options_async(request, headers, runtime)

    def list_history_histograms_with_options(
        self,
        request: cms_20240330_models.ListHistoryHistogramsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListHistoryHistogramsResponse:
        """
        @summary 列表历史直方图
        
        @param request: ListHistoryHistogramsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListHistoryHistogramsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.batch_id):
            query['batchId'] = request.batch_id
        if not UtilClient.is_unset(request.contact):
            query['contact'] = request.contact
        if not UtilClient.is_unset(request.contact_group):
            query['contactGroup'] = request.contact_group
        if not UtilClient.is_unset(request.from_):
            query['from'] = request.from_
        if not UtilClient.is_unset(request.grouping_id):
            query['groupingId'] = request.grouping_id
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.receiver):
            query['receiver'] = request.receiver
        if not UtilClient.is_unset(request.severity):
            query['severity'] = request.severity
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.strategy_name):
            query['strategyName'] = request.strategy_name
        if not UtilClient.is_unset(request.strategy_uuid):
            query['strategyUuid'] = request.strategy_uuid
        if not UtilClient.is_unset(request.to):
            query['to'] = request.to
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListHistoryHistograms',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/historyHistograms',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListHistoryHistogramsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListHistoryHistogramsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_history_histograms_with_options_async(
        self,
        request: cms_20240330_models.ListHistoryHistogramsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListHistoryHistogramsResponse:
        """
        @summary 列表历史直方图
        
        @param request: ListHistoryHistogramsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListHistoryHistogramsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.batch_id):
            query['batchId'] = request.batch_id
        if not UtilClient.is_unset(request.contact):
            query['contact'] = request.contact
        if not UtilClient.is_unset(request.contact_group):
            query['contactGroup'] = request.contact_group
        if not UtilClient.is_unset(request.from_):
            query['from'] = request.from_
        if not UtilClient.is_unset(request.grouping_id):
            query['groupingId'] = request.grouping_id
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.receiver):
            query['receiver'] = request.receiver
        if not UtilClient.is_unset(request.severity):
            query['severity'] = request.severity
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.strategy_name):
            query['strategyName'] = request.strategy_name
        if not UtilClient.is_unset(request.strategy_uuid):
            query['strategyUuid'] = request.strategy_uuid
        if not UtilClient.is_unset(request.to):
            query['to'] = request.to
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListHistoryHistograms',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/historyHistograms',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListHistoryHistogramsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListHistoryHistogramsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_history_histograms(
        self,
        request: cms_20240330_models.ListHistoryHistogramsRequest,
    ) -> cms_20240330_models.ListHistoryHistogramsResponse:
        """
        @summary 列表历史直方图
        
        @param request: ListHistoryHistogramsRequest
        @return: ListHistoryHistogramsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_history_histograms_with_options(request, headers, runtime)

    async def list_history_histograms_async(
        self,
        request: cms_20240330_models.ListHistoryHistogramsRequest,
    ) -> cms_20240330_models.ListHistoryHistogramsResponse:
        """
        @summary 列表历史直方图
        
        @param request: ListHistoryHistogramsRequest
        @return: ListHistoryHistogramsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_history_histograms_with_options_async(request, headers, runtime)

    def list_installed_addons_with_options(
        self,
        request: cms_20240330_models.ListInstalledAddonsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListInstalledAddonsResponse:
        """
        @summary 已安装的addon信息列表
        
        @param request: ListInstalledAddonsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListInstalledAddonsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListInstalledAddons',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/ListInstalledAddons',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListInstalledAddonsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListInstalledAddonsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_installed_addons_with_options_async(
        self,
        request: cms_20240330_models.ListInstalledAddonsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListInstalledAddonsResponse:
        """
        @summary 已安装的addon信息列表
        
        @param request: ListInstalledAddonsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListInstalledAddonsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region):
            query['Region'] = request.region
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListInstalledAddons',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/ListInstalledAddons',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListInstalledAddonsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListInstalledAddonsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_installed_addons(
        self,
        request: cms_20240330_models.ListInstalledAddonsRequest,
    ) -> cms_20240330_models.ListInstalledAddonsResponse:
        """
        @summary 已安装的addon信息列表
        
        @param request: ListInstalledAddonsRequest
        @return: ListInstalledAddonsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_installed_addons_with_options(request, headers, runtime)

    async def list_installed_addons_async(
        self,
        request: cms_20240330_models.ListInstalledAddonsRequest,
    ) -> cms_20240330_models.ListInstalledAddonsResponse:
        """
        @summary 已安装的addon信息列表
        
        @param request: ListInstalledAddonsRequest
        @return: ListInstalledAddonsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_installed_addons_with_options_async(request, headers, runtime)

    def list_installing_addon_releases_with_options(
        self,
        request: cms_20240330_models.ListInstallingAddonReleasesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListInstallingAddonReleasesResponse:
        """
        @summary 显示未完成接入的记录信息
        
        @param request: ListInstallingAddonReleasesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListInstallingAddonReleasesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListInstallingAddonReleases',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/addon/ListInstallingAddonReleases',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListInstallingAddonReleasesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListInstallingAddonReleasesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_installing_addon_releases_with_options_async(
        self,
        request: cms_20240330_models.ListInstallingAddonReleasesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListInstallingAddonReleasesResponse:
        """
        @summary 显示未完成接入的记录信息
        
        @param request: ListInstallingAddonReleasesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListInstallingAddonReleasesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListInstallingAddonReleases',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/addon/ListInstallingAddonReleases',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListInstallingAddonReleasesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListInstallingAddonReleasesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_installing_addon_releases(
        self,
        request: cms_20240330_models.ListInstallingAddonReleasesRequest,
    ) -> cms_20240330_models.ListInstallingAddonReleasesResponse:
        """
        @summary 显示未完成接入的记录信息
        
        @param request: ListInstallingAddonReleasesRequest
        @return: ListInstallingAddonReleasesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_installing_addon_releases_with_options(request, headers, runtime)

    async def list_installing_addon_releases_async(
        self,
        request: cms_20240330_models.ListInstallingAddonReleasesRequest,
    ) -> cms_20240330_models.ListInstallingAddonReleasesResponse:
        """
        @summary 显示未完成接入的记录信息
        
        @param request: ListInstallingAddonReleasesRequest
        @return: ListInstallingAddonReleasesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_installing_addon_releases_with_options_async(request, headers, runtime)

    def list_integration_policies_with_options(
        self,
        tmp_req: cms_20240330_models.ListIntegrationPoliciesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPoliciesResponse:
        """
        @summary 查询接入中心策略列表信息
        
        @param tmp_req: ListIntegrationPoliciesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPoliciesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListIntegrationPoliciesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.tag):
            request.tag_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.tag, 'tag', 'json')
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.entity_group_ids):
            query['entityGroupIds'] = request.entity_group_ids
        if not UtilClient.is_unset(request.filter_region_ids):
            query['filterRegionIds'] = request.filter_region_ids
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.policy_id):
            query['policyId'] = request.policy_id
        if not UtilClient.is_unset(request.policy_name):
            query['policyName'] = request.policy_name
        if not UtilClient.is_unset(request.policy_type):
            query['policyType'] = request.policy_type
        if not UtilClient.is_unset(request.query):
            query['query'] = request.query
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.tag_shrink):
            query['tag'] = request.tag_shrink
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicies',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPoliciesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPoliciesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_integration_policies_with_options_async(
        self,
        tmp_req: cms_20240330_models.ListIntegrationPoliciesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPoliciesResponse:
        """
        @summary 查询接入中心策略列表信息
        
        @param tmp_req: ListIntegrationPoliciesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPoliciesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListIntegrationPoliciesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.tag):
            request.tag_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.tag, 'tag', 'json')
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.entity_group_ids):
            query['entityGroupIds'] = request.entity_group_ids
        if not UtilClient.is_unset(request.filter_region_ids):
            query['filterRegionIds'] = request.filter_region_ids
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.policy_id):
            query['policyId'] = request.policy_id
        if not UtilClient.is_unset(request.policy_name):
            query['policyName'] = request.policy_name
        if not UtilClient.is_unset(request.policy_type):
            query['policyType'] = request.policy_type
        if not UtilClient.is_unset(request.query):
            query['query'] = request.query
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.tag_shrink):
            query['tag'] = request.tag_shrink
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicies',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPoliciesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPoliciesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_integration_policies(
        self,
        request: cms_20240330_models.ListIntegrationPoliciesRequest,
    ) -> cms_20240330_models.ListIntegrationPoliciesResponse:
        """
        @summary 查询接入中心策略列表信息
        
        @param request: ListIntegrationPoliciesRequest
        @return: ListIntegrationPoliciesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_integration_policies_with_options(request, headers, runtime)

    async def list_integration_policies_async(
        self,
        request: cms_20240330_models.ListIntegrationPoliciesRequest,
    ) -> cms_20240330_models.ListIntegrationPoliciesResponse:
        """
        @summary 查询接入中心策略列表信息
        
        @param request: ListIntegrationPoliciesRequest
        @return: ListIntegrationPoliciesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_integration_policies_with_options_async(request, headers, runtime)

    def list_integration_policy_addons_with_options(
        self,
        policy_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyAddonsResponse:
        """
        @summary 策略addon列表
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyAddonsResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyAddons',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/addons',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyAddonsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyAddonsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_integration_policy_addons_with_options_async(
        self,
        policy_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyAddonsResponse:
        """
        @summary 策略addon列表
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyAddonsResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyAddons',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/addons',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyAddonsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyAddonsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_integration_policy_addons(
        self,
        policy_id: str,
    ) -> cms_20240330_models.ListIntegrationPolicyAddonsResponse:
        """
        @summary 策略addon列表
        
        @return: ListIntegrationPolicyAddonsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_integration_policy_addons_with_options(policy_id, headers, runtime)

    async def list_integration_policy_addons_async(
        self,
        policy_id: str,
    ) -> cms_20240330_models.ListIntegrationPolicyAddonsResponse:
        """
        @summary 策略addon列表
        
        @return: ListIntegrationPolicyAddonsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_integration_policy_addons_with_options_async(policy_id, headers, runtime)

    def list_integration_policy_alert_rules_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyAlertRulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyAlertRulesResponse:
        """
        @summary 环境的告警组列表
        
        @param request: ListIntegrationPolicyAlertRulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyAlertRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.scene):
            query['scene'] = request.scene
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyAlertRules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/alert-rules',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyAlertRulesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyAlertRulesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_integration_policy_alert_rules_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyAlertRulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyAlertRulesResponse:
        """
        @summary 环境的告警组列表
        
        @param request: ListIntegrationPolicyAlertRulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyAlertRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.scene):
            query['scene'] = request.scene
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyAlertRules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/alert-rules',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyAlertRulesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyAlertRulesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_integration_policy_alert_rules(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyAlertRulesRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyAlertRulesResponse:
        """
        @summary 环境的告警组列表
        
        @param request: ListIntegrationPolicyAlertRulesRequest
        @return: ListIntegrationPolicyAlertRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_integration_policy_alert_rules_with_options(policy_id, request, headers, runtime)

    async def list_integration_policy_alert_rules_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyAlertRulesRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyAlertRulesResponse:
        """
        @summary 环境的告警组列表
        
        @param request: ListIntegrationPolicyAlertRulesRequest
        @return: ListIntegrationPolicyAlertRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_integration_policy_alert_rules_with_options_async(policy_id, request, headers, runtime)

    def list_integration_policy_collectors_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyCollectorsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyCollectorsResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyCollectorsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyCollectorsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_release_name):
            query['addonReleaseName'] = request.addon_release_name
        if not UtilClient.is_unset(request.collector_type):
            query['collectorType'] = request.collector_type
        if not UtilClient.is_unset(request.language):
            query['language'] = request.language
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyCollectors',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/collectors',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyCollectorsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyCollectorsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_integration_policy_collectors_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyCollectorsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyCollectorsResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyCollectorsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyCollectorsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_release_name):
            query['addonReleaseName'] = request.addon_release_name
        if not UtilClient.is_unset(request.collector_type):
            query['collectorType'] = request.collector_type
        if not UtilClient.is_unset(request.language):
            query['language'] = request.language
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyCollectors',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/collectors',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyCollectorsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyCollectorsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_integration_policy_collectors(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyCollectorsRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyCollectorsResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyCollectorsRequest
        @return: ListIntegrationPolicyCollectorsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_integration_policy_collectors_with_options(policy_id, request, headers, runtime)

    async def list_integration_policy_collectors_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyCollectorsRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyCollectorsResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyCollectorsRequest
        @return: ListIntegrationPolicyCollectorsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_integration_policy_collectors_with_options_async(policy_id, request, headers, runtime)

    def list_integration_policy_custom_scrape_job_rules_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyCustomScrapeJobRulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyCustomScrapeJobRulesResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyCustomScrapeJobRulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyCustomScrapeJobRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_release_name):
            query['addonReleaseName'] = request.addon_release_name
        if not UtilClient.is_unset(request.encrypt_yaml):
            query['encryptYaml'] = request.encrypt_yaml
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyCustomScrapeJobRules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/custom-scrape-job-rules',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyCustomScrapeJobRulesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyCustomScrapeJobRulesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_integration_policy_custom_scrape_job_rules_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyCustomScrapeJobRulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyCustomScrapeJobRulesResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyCustomScrapeJobRulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyCustomScrapeJobRulesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_release_name):
            query['addonReleaseName'] = request.addon_release_name
        if not UtilClient.is_unset(request.encrypt_yaml):
            query['encryptYaml'] = request.encrypt_yaml
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyCustomScrapeJobRules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/custom-scrape-job-rules',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyCustomScrapeJobRulesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyCustomScrapeJobRulesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_integration_policy_custom_scrape_job_rules(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyCustomScrapeJobRulesRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyCustomScrapeJobRulesResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyCustomScrapeJobRulesRequest
        @return: ListIntegrationPolicyCustomScrapeJobRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_integration_policy_custom_scrape_job_rules_with_options(policy_id, request, headers, runtime)

    async def list_integration_policy_custom_scrape_job_rules_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyCustomScrapeJobRulesRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyCustomScrapeJobRulesResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyCustomScrapeJobRulesRequest
        @return: ListIntegrationPolicyCustomScrapeJobRulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_integration_policy_custom_scrape_job_rules_with_options_async(policy_id, request, headers, runtime)

    def list_integration_policy_dashboards_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyDashboardsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyDashboardsResponse:
        """
        @summary 策略大盘列表
        
        @param request: ListIntegrationPolicyDashboardsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyDashboardsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.scene):
            query['scene'] = request.scene
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyDashboards',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/dashboards',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyDashboardsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyDashboardsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_integration_policy_dashboards_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyDashboardsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyDashboardsResponse:
        """
        @summary 策略大盘列表
        
        @param request: ListIntegrationPolicyDashboardsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyDashboardsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.scene):
            query['scene'] = request.scene
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyDashboards',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/dashboards',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyDashboardsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyDashboardsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_integration_policy_dashboards(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyDashboardsRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyDashboardsResponse:
        """
        @summary 策略大盘列表
        
        @param request: ListIntegrationPolicyDashboardsRequest
        @return: ListIntegrationPolicyDashboardsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_integration_policy_dashboards_with_options(policy_id, request, headers, runtime)

    async def list_integration_policy_dashboards_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyDashboardsRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyDashboardsResponse:
        """
        @summary 策略大盘列表
        
        @param request: ListIntegrationPolicyDashboardsRequest
        @return: ListIntegrationPolicyDashboardsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_integration_policy_dashboards_with_options_async(policy_id, request, headers, runtime)

    def list_integration_policy_pipeline_configs_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyPipelineConfigsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyPipelineConfigsResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyPipelineConfigsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyPipelineConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_release_name):
            query['addonReleaseName'] = request.addon_release_name
        if not UtilClient.is_unset(request.encrypt_yaml):
            query['encryptYaml'] = request.encrypt_yaml
        if not UtilClient.is_unset(request.namespace):
            query['namespace'] = request.namespace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyPipelineConfigs',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/pipeline-configs',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyPipelineConfigsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyPipelineConfigsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_integration_policy_pipeline_configs_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyPipelineConfigsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyPipelineConfigsResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyPipelineConfigsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyPipelineConfigsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_release_name):
            query['addonReleaseName'] = request.addon_release_name
        if not UtilClient.is_unset(request.encrypt_yaml):
            query['encryptYaml'] = request.encrypt_yaml
        if not UtilClient.is_unset(request.namespace):
            query['namespace'] = request.namespace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyPipelineConfigs',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/pipeline-configs',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyPipelineConfigsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyPipelineConfigsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_integration_policy_pipeline_configs(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyPipelineConfigsRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyPipelineConfigsResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyPipelineConfigsRequest
        @return: ListIntegrationPolicyPipelineConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_integration_policy_pipeline_configs_with_options(policy_id, request, headers, runtime)

    async def list_integration_policy_pipeline_configs_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyPipelineConfigsRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyPipelineConfigsResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyPipelineConfigsRequest
        @return: ListIntegrationPolicyPipelineConfigsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_integration_policy_pipeline_configs_with_options_async(policy_id, request, headers, runtime)

    def list_integration_policy_pod_monitors_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyPodMonitorsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyPodMonitorsResponse:
        """
        @summary 获取接入中心策略的PodMonitor资源
        
        @param request: ListIntegrationPolicyPodMonitorsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyPodMonitorsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_release_name):
            query['addonReleaseName'] = request.addon_release_name
        if not UtilClient.is_unset(request.encrypt_yaml):
            query['encryptYaml'] = request.encrypt_yaml
        if not UtilClient.is_unset(request.namespace):
            query['namespace'] = request.namespace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyPodMonitors',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/pod-monitors',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyPodMonitorsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyPodMonitorsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_integration_policy_pod_monitors_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyPodMonitorsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyPodMonitorsResponse:
        """
        @summary 获取接入中心策略的PodMonitor资源
        
        @param request: ListIntegrationPolicyPodMonitorsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyPodMonitorsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_release_name):
            query['addonReleaseName'] = request.addon_release_name
        if not UtilClient.is_unset(request.encrypt_yaml):
            query['encryptYaml'] = request.encrypt_yaml
        if not UtilClient.is_unset(request.namespace):
            query['namespace'] = request.namespace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyPodMonitors',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/pod-monitors',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyPodMonitorsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyPodMonitorsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_integration_policy_pod_monitors(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyPodMonitorsRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyPodMonitorsResponse:
        """
        @summary 获取接入中心策略的PodMonitor资源
        
        @param request: ListIntegrationPolicyPodMonitorsRequest
        @return: ListIntegrationPolicyPodMonitorsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_integration_policy_pod_monitors_with_options(policy_id, request, headers, runtime)

    async def list_integration_policy_pod_monitors_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyPodMonitorsRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyPodMonitorsResponse:
        """
        @summary 获取接入中心策略的PodMonitor资源
        
        @param request: ListIntegrationPolicyPodMonitorsRequest
        @return: ListIntegrationPolicyPodMonitorsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_integration_policy_pod_monitors_with_options_async(policy_id, request, headers, runtime)

    def list_integration_policy_resources_with_options(
        self,
        policy_id: str,
        tmp_req: cms_20240330_models.ListIntegrationPolicyResourcesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyResourcesResponse:
        """
        @summary 获取接入中心策略的资源信息
        
        @param tmp_req: ListIntegrationPolicyResourcesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyResourcesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListIntegrationPolicyResourcesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.label_selectors):
            request.label_selectors_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.label_selectors, 'labelSelectors', 'json')
        query = {}
        if not UtilClient.is_unset(request.kind):
            query['kind'] = request.kind
        if not UtilClient.is_unset(request.label_selectors_shrink):
            query['labelSelectors'] = request.label_selectors_shrink
        if not UtilClient.is_unset(request.namespace):
            query['namespace'] = request.namespace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyResources',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/resources',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyResourcesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyResourcesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_integration_policy_resources_with_options_async(
        self,
        policy_id: str,
        tmp_req: cms_20240330_models.ListIntegrationPolicyResourcesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyResourcesResponse:
        """
        @summary 获取接入中心策略的资源信息
        
        @param tmp_req: ListIntegrationPolicyResourcesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyResourcesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListIntegrationPolicyResourcesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.label_selectors):
            request.label_selectors_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.label_selectors, 'labelSelectors', 'json')
        query = {}
        if not UtilClient.is_unset(request.kind):
            query['kind'] = request.kind
        if not UtilClient.is_unset(request.label_selectors_shrink):
            query['labelSelectors'] = request.label_selectors_shrink
        if not UtilClient.is_unset(request.namespace):
            query['namespace'] = request.namespace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyResources',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/resources',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyResourcesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyResourcesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_integration_policy_resources(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyResourcesRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyResourcesResponse:
        """
        @summary 获取接入中心策略的资源信息
        
        @param request: ListIntegrationPolicyResourcesRequest
        @return: ListIntegrationPolicyResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_integration_policy_resources_with_options(policy_id, request, headers, runtime)

    async def list_integration_policy_resources_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyResourcesRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyResourcesResponse:
        """
        @summary 获取接入中心策略的资源信息
        
        @param request: ListIntegrationPolicyResourcesRequest
        @return: ListIntegrationPolicyResourcesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_integration_policy_resources_with_options_async(policy_id, request, headers, runtime)

    def list_integration_policy_service_monitors_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyServiceMonitorsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyServiceMonitorsResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyServiceMonitorsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyServiceMonitorsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_release_name):
            query['addonReleaseName'] = request.addon_release_name
        if not UtilClient.is_unset(request.encrypt_yaml):
            query['encryptYaml'] = request.encrypt_yaml
        if not UtilClient.is_unset(request.namespace):
            query['namespace'] = request.namespace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyServiceMonitors',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/service-monitors',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyServiceMonitorsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyServiceMonitorsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_integration_policy_service_monitors_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyServiceMonitorsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyServiceMonitorsResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyServiceMonitorsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyServiceMonitorsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_release_name):
            query['addonReleaseName'] = request.addon_release_name
        if not UtilClient.is_unset(request.encrypt_yaml):
            query['encryptYaml'] = request.encrypt_yaml
        if not UtilClient.is_unset(request.namespace):
            query['namespace'] = request.namespace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyServiceMonitors',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/service-monitors',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyServiceMonitorsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyServiceMonitorsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_integration_policy_service_monitors(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyServiceMonitorsRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyServiceMonitorsResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyServiceMonitorsRequest
        @return: ListIntegrationPolicyServiceMonitorsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_integration_policy_service_monitors_with_options(policy_id, request, headers, runtime)

    async def list_integration_policy_service_monitors_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyServiceMonitorsRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyServiceMonitorsResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyServiceMonitorsRequest
        @return: ListIntegrationPolicyServiceMonitorsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_integration_policy_service_monitors_with_options_async(policy_id, request, headers, runtime)

    def list_integration_policy_storage_requirements_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyStorageRequirementsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyStorageRequirementsResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyStorageRequirementsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyStorageRequirementsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.storage_type):
            query['storageType'] = request.storage_type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyStorageRequirements',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/storage-requirements',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyStorageRequirementsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyStorageRequirementsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_integration_policy_storage_requirements_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyStorageRequirementsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyStorageRequirementsResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyStorageRequirementsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyStorageRequirementsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.storage_type):
            query['storageType'] = request.storage_type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyStorageRequirements',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/storage-requirements',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyStorageRequirementsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyStorageRequirementsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_integration_policy_storage_requirements(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyStorageRequirementsRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyStorageRequirementsResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyStorageRequirementsRequest
        @return: ListIntegrationPolicyStorageRequirementsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_integration_policy_storage_requirements_with_options(policy_id, request, headers, runtime)

    async def list_integration_policy_storage_requirements_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyStorageRequirementsRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyStorageRequirementsResponse:
        """
        @summary 获取接入中心策略的存储要求信息
        
        @param request: ListIntegrationPolicyStorageRequirementsRequest
        @return: ListIntegrationPolicyStorageRequirementsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_integration_policy_storage_requirements_with_options_async(policy_id, request, headers, runtime)

    def list_integration_policy_targets_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyTargetsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyTargetsResponse:
        """
        @summary 环境指标target列表
        
        @param request: ListIntegrationPolicyTargetsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyTargetsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_name):
            query['jobName'] = request.job_name
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyTargets',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/targets',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyTargetsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyTargetsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_integration_policy_targets_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyTargetsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationPolicyTargetsResponse:
        """
        @summary 环境指标target列表
        
        @param request: ListIntegrationPolicyTargetsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationPolicyTargetsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_name):
            query['jobName'] = request.job_name
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrationPolicyTargets',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/targets',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyTargetsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationPolicyTargetsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_integration_policy_targets(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyTargetsRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyTargetsResponse:
        """
        @summary 环境指标target列表
        
        @param request: ListIntegrationPolicyTargetsRequest
        @return: ListIntegrationPolicyTargetsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_integration_policy_targets_with_options(policy_id, request, headers, runtime)

    async def list_integration_policy_targets_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListIntegrationPolicyTargetsRequest,
    ) -> cms_20240330_models.ListIntegrationPolicyTargetsResponse:
        """
        @summary 环境指标target列表
        
        @param request: ListIntegrationPolicyTargetsRequest
        @return: ListIntegrationPolicyTargetsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_integration_policy_targets_with_options_async(policy_id, request, headers, runtime)

    def list_integrations_with_options(
        self,
        request: cms_20240330_models.ListIntegrationsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationsResponse:
        """
        @summary List Integration
        
        @param request: ListIntegrationsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.enable):
            query['enable'] = request.enable
        if not UtilClient.is_unset(request.integration_id):
            query['integrationId'] = request.integration_id
        if not UtilClient.is_unset(request.integration_name):
            query['integrationName'] = request.integration_name
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.page):
            query['page'] = request.page
        if not UtilClient.is_unset(request.size):
            query['size'] = request.size
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrations',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integrations',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_integrations_with_options_async(
        self,
        request: cms_20240330_models.ListIntegrationsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListIntegrationsResponse:
        """
        @summary List Integration
        
        @param request: ListIntegrationsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListIntegrationsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.enable):
            query['enable'] = request.enable
        if not UtilClient.is_unset(request.integration_id):
            query['integrationId'] = request.integration_id
        if not UtilClient.is_unset(request.integration_name):
            query['integrationName'] = request.integration_name
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.page):
            query['page'] = request.page
        if not UtilClient.is_unset(request.size):
            query['size'] = request.size
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListIntegrations',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integrations',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListIntegrationsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_integrations(
        self,
        request: cms_20240330_models.ListIntegrationsRequest,
    ) -> cms_20240330_models.ListIntegrationsResponse:
        """
        @summary List Integration
        
        @param request: ListIntegrationsRequest
        @return: ListIntegrationsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_integrations_with_options(request, headers, runtime)

    async def list_integrations_async(
        self,
        request: cms_20240330_models.ListIntegrationsRequest,
    ) -> cms_20240330_models.ListIntegrationsResponse:
        """
        @summary List Integration
        
        @param request: ListIntegrationsRequest
        @return: ListIntegrationsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_integrations_with_options_async(request, headers, runtime)

    def list_maintain_windows_with_options(
        self,
        request: cms_20240330_models.ListMaintainWindowsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListMaintainWindowsResponse:
        """
        @summary List MaintainWindow
        
        @param request: ListMaintainWindowsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMaintainWindowsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.enable):
            query['enable'] = request.enable
        if not UtilClient.is_unset(request.maintain_window_id):
            query['maintainWindowId'] = request.maintain_window_id
        if not UtilClient.is_unset(request.maintain_window_name):
            query['maintainWindowName'] = request.maintain_window_name
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListMaintainWindows',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/maintainWindows',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListMaintainWindowsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListMaintainWindowsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_maintain_windows_with_options_async(
        self,
        request: cms_20240330_models.ListMaintainWindowsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListMaintainWindowsResponse:
        """
        @summary List MaintainWindow
        
        @param request: ListMaintainWindowsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMaintainWindowsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.enable):
            query['enable'] = request.enable
        if not UtilClient.is_unset(request.maintain_window_id):
            query['maintainWindowId'] = request.maintain_window_id
        if not UtilClient.is_unset(request.maintain_window_name):
            query['maintainWindowName'] = request.maintain_window_name
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListMaintainWindows',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/maintainWindows',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListMaintainWindowsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListMaintainWindowsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_maintain_windows(
        self,
        request: cms_20240330_models.ListMaintainWindowsRequest,
    ) -> cms_20240330_models.ListMaintainWindowsResponse:
        """
        @summary List MaintainWindow
        
        @param request: ListMaintainWindowsRequest
        @return: ListMaintainWindowsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_maintain_windows_with_options(request, headers, runtime)

    async def list_maintain_windows_async(
        self,
        request: cms_20240330_models.ListMaintainWindowsRequest,
    ) -> cms_20240330_models.ListMaintainWindowsResponse:
        """
        @summary List MaintainWindow
        
        @param request: ListMaintainWindowsRequest
        @return: ListMaintainWindowsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_maintain_windows_with_options_async(request, headers, runtime)

    def list_metric_targets_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.ListMetricTargetsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListMetricTargetsResponse:
        """
        @summary 环境指标target列表
        
        @param request: ListMetricTargetsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMetricTargetsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_name):
            query['jobName'] = request.job_name
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListMetricTargets',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy/{OpenApiUtilClient.get_encode_param(policy_id)}/targets',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListMetricTargetsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListMetricTargetsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_metric_targets_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListMetricTargetsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListMetricTargetsResponse:
        """
        @summary 环境指标target列表
        
        @param request: ListMetricTargetsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListMetricTargetsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.job_name):
            query['jobName'] = request.job_name
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListMetricTargets',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy/{OpenApiUtilClient.get_encode_param(policy_id)}/targets',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListMetricTargetsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListMetricTargetsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_metric_targets(
        self,
        policy_id: str,
        request: cms_20240330_models.ListMetricTargetsRequest,
    ) -> cms_20240330_models.ListMetricTargetsResponse:
        """
        @summary 环境指标target列表
        
        @param request: ListMetricTargetsRequest
        @return: ListMetricTargetsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_metric_targets_with_options(policy_id, request, headers, runtime)

    async def list_metric_targets_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListMetricTargetsRequest,
    ) -> cms_20240330_models.ListMetricTargetsResponse:
        """
        @summary 环境指标target列表
        
        @param request: ListMetricTargetsRequest
        @return: ListMetricTargetsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_metric_targets_with_options_async(policy_id, request, headers, runtime)

    def list_notify_strategies_with_options(
        self,
        request: cms_20240330_models.ListNotifyStrategiesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListNotifyStrategiesResponse:
        """
        @summary List NotifyStrategy
        
        @param request: ListNotifyStrategiesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListNotifyStrategiesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.enable):
            query['enable'] = request.enable
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.notify_strategy_id):
            query['notifyStrategyId'] = request.notify_strategy_id
        if not UtilClient.is_unset(request.notify_strategy_name):
            query['notifyStrategyName'] = request.notify_strategy_name
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListNotifyStrategies',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/notifyStrategies',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListNotifyStrategiesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListNotifyStrategiesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_notify_strategies_with_options_async(
        self,
        request: cms_20240330_models.ListNotifyStrategiesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListNotifyStrategiesResponse:
        """
        @summary List NotifyStrategy
        
        @param request: ListNotifyStrategiesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListNotifyStrategiesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.enable):
            query['enable'] = request.enable
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.notify_strategy_id):
            query['notifyStrategyId'] = request.notify_strategy_id
        if not UtilClient.is_unset(request.notify_strategy_name):
            query['notifyStrategyName'] = request.notify_strategy_name
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListNotifyStrategies',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/notifyStrategies',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListNotifyStrategiesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListNotifyStrategiesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_notify_strategies(
        self,
        request: cms_20240330_models.ListNotifyStrategiesRequest,
    ) -> cms_20240330_models.ListNotifyStrategiesResponse:
        """
        @summary List NotifyStrategy
        
        @param request: ListNotifyStrategiesRequest
        @return: ListNotifyStrategiesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_notify_strategies_with_options(request, headers, runtime)

    async def list_notify_strategies_async(
        self,
        request: cms_20240330_models.ListNotifyStrategiesRequest,
    ) -> cms_20240330_models.ListNotifyStrategiesResponse:
        """
        @summary List NotifyStrategy
        
        @param request: ListNotifyStrategiesRequest
        @return: ListNotifyStrategiesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_notify_strategies_with_options_async(request, headers, runtime)

    def list_oncall_contacts_with_options(
        self,
        oncall_schedule_id: str,
        request: cms_20240330_models.ListOncallContactsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListOncallContactsResponse:
        """
        @summary 查询值班人
        
        @param request: ListOncallContactsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListOncallContactsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.timestamp):
            query['timestamp'] = request.timestamp
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListOncallContacts',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/oncallSchedule/{OpenApiUtilClient.get_encode_param(oncall_schedule_id)}/contacts',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListOncallContactsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListOncallContactsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_oncall_contacts_with_options_async(
        self,
        oncall_schedule_id: str,
        request: cms_20240330_models.ListOncallContactsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListOncallContactsResponse:
        """
        @summary 查询值班人
        
        @param request: ListOncallContactsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListOncallContactsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.timestamp):
            query['timestamp'] = request.timestamp
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListOncallContacts',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/oncallSchedule/{OpenApiUtilClient.get_encode_param(oncall_schedule_id)}/contacts',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListOncallContactsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListOncallContactsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_oncall_contacts(
        self,
        oncall_schedule_id: str,
        request: cms_20240330_models.ListOncallContactsRequest,
    ) -> cms_20240330_models.ListOncallContactsResponse:
        """
        @summary 查询值班人
        
        @param request: ListOncallContactsRequest
        @return: ListOncallContactsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_oncall_contacts_with_options(oncall_schedule_id, request, headers, runtime)

    async def list_oncall_contacts_async(
        self,
        oncall_schedule_id: str,
        request: cms_20240330_models.ListOncallContactsRequest,
    ) -> cms_20240330_models.ListOncallContactsResponse:
        """
        @summary 查询值班人
        
        @param request: ListOncallContactsRequest
        @return: ListOncallContactsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_oncall_contacts_with_options_async(oncall_schedule_id, request, headers, runtime)

    def list_oncall_schedules_with_options(
        self,
        tmp_req: cms_20240330_models.ListOncallSchedulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListOncallSchedulesResponse:
        """
        @summary 列出资源OncallSchedule
        
        @param tmp_req: ListOncallSchedulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListOncallSchedulesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListOncallSchedulesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.oncall_schedule_ids):
            request.oncall_schedule_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.oncall_schedule_ids, 'oncallScheduleIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.oncall_schedule_ids_shrink):
            query['oncallScheduleIds'] = request.oncall_schedule_ids_shrink
        if not UtilClient.is_unset(request.oncall_schedule_name):
            query['oncallScheduleName'] = request.oncall_schedule_name
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListOncallSchedules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/oncallSchedules',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListOncallSchedulesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListOncallSchedulesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_oncall_schedules_with_options_async(
        self,
        tmp_req: cms_20240330_models.ListOncallSchedulesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListOncallSchedulesResponse:
        """
        @summary 列出资源OncallSchedule
        
        @param tmp_req: ListOncallSchedulesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListOncallSchedulesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListOncallSchedulesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.oncall_schedule_ids):
            request.oncall_schedule_ids_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.oncall_schedule_ids, 'oncallScheduleIds', 'json')
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.oncall_schedule_ids_shrink):
            query['oncallScheduleIds'] = request.oncall_schedule_ids_shrink
        if not UtilClient.is_unset(request.oncall_schedule_name):
            query['oncallScheduleName'] = request.oncall_schedule_name
        if not UtilClient.is_unset(request.page_number):
            query['pageNumber'] = request.page_number
        if not UtilClient.is_unset(request.page_size):
            query['pageSize'] = request.page_size
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListOncallSchedules',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/oncallSchedules',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListOncallSchedulesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListOncallSchedulesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_oncall_schedules(
        self,
        request: cms_20240330_models.ListOncallSchedulesRequest,
    ) -> cms_20240330_models.ListOncallSchedulesResponse:
        """
        @summary 列出资源OncallSchedule
        
        @param request: ListOncallSchedulesRequest
        @return: ListOncallSchedulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_oncall_schedules_with_options(request, headers, runtime)

    async def list_oncall_schedules_async(
        self,
        request: cms_20240330_models.ListOncallSchedulesRequest,
    ) -> cms_20240330_models.ListOncallSchedulesResponse:
        """
        @summary 列出资源OncallSchedule
        
        @param request: ListOncallSchedulesRequest
        @return: ListOncallSchedulesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_oncall_schedules_with_options_async(request, headers, runtime)

    def list_policy_addons_with_options(
        self,
        policy_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListPolicyAddonsResponse:
        """
        @summary 策略addon列表
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPolicyAddonsResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='ListPolicyAddons',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy/{OpenApiUtilClient.get_encode_param(policy_id)}/addons',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListPolicyAddonsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListPolicyAddonsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_policy_addons_with_options_async(
        self,
        policy_id: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListPolicyAddonsResponse:
        """
        @summary 策略addon列表
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPolicyAddonsResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='ListPolicyAddons',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy/{OpenApiUtilClient.get_encode_param(policy_id)}/addons',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListPolicyAddonsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListPolicyAddonsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_policy_addons(
        self,
        policy_id: str,
    ) -> cms_20240330_models.ListPolicyAddonsResponse:
        """
        @summary 策略addon列表
        
        @return: ListPolicyAddonsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_policy_addons_with_options(policy_id, headers, runtime)

    async def list_policy_addons_async(
        self,
        policy_id: str,
    ) -> cms_20240330_models.ListPolicyAddonsResponse:
        """
        @summary 策略addon列表
        
        @return: ListPolicyAddonsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_policy_addons_with_options_async(policy_id, headers, runtime)

    def list_policy_dashboards_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.ListPolicyDashboardsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListPolicyDashboardsResponse:
        """
        @summary 策略大盘列表
        
        @param request: ListPolicyDashboardsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPolicyDashboardsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.scene):
            query['scene'] = request.scene
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPolicyDashboards',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/dashboards',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListPolicyDashboardsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListPolicyDashboardsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_policy_dashboards_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListPolicyDashboardsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListPolicyDashboardsResponse:
        """
        @summary 策略大盘列表
        
        @param request: ListPolicyDashboardsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPolicyDashboardsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.addon_name):
            query['addonName'] = request.addon_name
        if not UtilClient.is_unset(request.scene):
            query['scene'] = request.scene
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPolicyDashboards',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/dashboards',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListPolicyDashboardsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListPolicyDashboardsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_policy_dashboards(
        self,
        policy_id: str,
        request: cms_20240330_models.ListPolicyDashboardsRequest,
    ) -> cms_20240330_models.ListPolicyDashboardsResponse:
        """
        @summary 策略大盘列表
        
        @param request: ListPolicyDashboardsRequest
        @return: ListPolicyDashboardsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_policy_dashboards_with_options(policy_id, request, headers, runtime)

    async def list_policy_dashboards_async(
        self,
        policy_id: str,
        request: cms_20240330_models.ListPolicyDashboardsRequest,
    ) -> cms_20240330_models.ListPolicyDashboardsResponse:
        """
        @summary 策略大盘列表
        
        @param request: ListPolicyDashboardsRequest
        @return: ListPolicyDashboardsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_policy_dashboards_with_options_async(policy_id, request, headers, runtime)

    def list_prom_front_vars_with_options(
        self,
        request: cms_20240330_models.ListPromFrontVarsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListPromFrontVarsResponse:
        """
        @summary 查询Prom相关的VM变量值
        
        @param request: ListPromFrontVarsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPromFrontVarsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.product_id):
            query['productId'] = request.product_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPromFrontVars',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/front/prom-vars',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListPromFrontVarsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListPromFrontVarsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_prom_front_vars_with_options_async(
        self,
        request: cms_20240330_models.ListPromFrontVarsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListPromFrontVarsResponse:
        """
        @summary 查询Prom相关的VM变量值
        
        @param request: ListPromFrontVarsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPromFrontVarsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.product_id):
            query['productId'] = request.product_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPromFrontVars',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/front/prom-vars',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListPromFrontVarsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListPromFrontVarsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_prom_front_vars(
        self,
        request: cms_20240330_models.ListPromFrontVarsRequest,
    ) -> cms_20240330_models.ListPromFrontVarsResponse:
        """
        @summary 查询Prom相关的VM变量值
        
        @param request: ListPromFrontVarsRequest
        @return: ListPromFrontVarsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_prom_front_vars_with_options(request, headers, runtime)

    async def list_prom_front_vars_async(
        self,
        request: cms_20240330_models.ListPromFrontVarsRequest,
    ) -> cms_20240330_models.ListPromFrontVarsResponse:
        """
        @summary 查询Prom相关的VM变量值
        
        @param request: ListPromFrontVarsRequest
        @return: ListPromFrontVarsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_prom_front_vars_with_options_async(request, headers, runtime)

    def list_prometheus_dashboards_with_options(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.ListPrometheusDashboardsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListPrometheusDashboardsResponse:
        """
        @summary 获取Prometheus实例大盘列表
        
        @param request: ListPrometheusDashboardsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPrometheusDashboardsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPrometheusDashboards',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(prometheus_instance_id)}/dashboards',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListPrometheusDashboardsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListPrometheusDashboardsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_prometheus_dashboards_with_options_async(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.ListPrometheusDashboardsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListPrometheusDashboardsResponse:
        """
        @summary 获取Prometheus实例大盘列表
        
        @param request: ListPrometheusDashboardsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPrometheusDashboardsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPrometheusDashboards',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(prometheus_instance_id)}/dashboards',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListPrometheusDashboardsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListPrometheusDashboardsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_prometheus_dashboards(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.ListPrometheusDashboardsRequest,
    ) -> cms_20240330_models.ListPrometheusDashboardsResponse:
        """
        @summary 获取Prometheus实例大盘列表
        
        @param request: ListPrometheusDashboardsRequest
        @return: ListPrometheusDashboardsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_prometheus_dashboards_with_options(prometheus_instance_id, request, headers, runtime)

    async def list_prometheus_dashboards_async(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.ListPrometheusDashboardsRequest,
    ) -> cms_20240330_models.ListPrometheusDashboardsResponse:
        """
        @summary 获取Prometheus实例大盘列表
        
        @param request: ListPrometheusDashboardsRequest
        @return: ListPrometheusDashboardsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_prometheus_dashboards_with_options_async(prometheus_instance_id, request, headers, runtime)

    def list_prometheus_instances_with_options(
        self,
        request: cms_20240330_models.ListPrometheusInstancesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListPrometheusInstancesResponse:
        """
        @summary 获取Prometheus实例信息列表
        
        @param request: ListPrometheusInstancesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPrometheusInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter_region_ids):
            query['filterRegionIds'] = request.filter_region_ids
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.prometheus_instance_ids):
            query['prometheusInstanceIds'] = request.prometheus_instance_ids
        if not UtilClient.is_unset(request.prometheus_instance_name):
            query['prometheusInstanceName'] = request.prometheus_instance_name
        if not UtilClient.is_unset(request.query_scene):
            query['queryScene'] = request.query_scene
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_type):
            query['resourceType'] = request.resource_type
        if not UtilClient.is_unset(request.sls_project):
            query['slsProject'] = request.sls_project
        if not UtilClient.is_unset(request.sls_store):
            query['slsStore'] = request.sls_store
        if not UtilClient.is_unset(request.tag):
            query['tag'] = request.tag
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPrometheusInstances',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListPrometheusInstancesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListPrometheusInstancesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_prometheus_instances_with_options_async(
        self,
        request: cms_20240330_models.ListPrometheusInstancesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListPrometheusInstancesResponse:
        """
        @summary 获取Prometheus实例信息列表
        
        @param request: ListPrometheusInstancesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPrometheusInstancesResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.filter_region_ids):
            query['filterRegionIds'] = request.filter_region_ids
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.prometheus_instance_ids):
            query['prometheusInstanceIds'] = request.prometheus_instance_ids
        if not UtilClient.is_unset(request.prometheus_instance_name):
            query['prometheusInstanceName'] = request.prometheus_instance_name
        if not UtilClient.is_unset(request.query_scene):
            query['queryScene'] = request.query_scene
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_type):
            query['resourceType'] = request.resource_type
        if not UtilClient.is_unset(request.sls_project):
            query['slsProject'] = request.sls_project
        if not UtilClient.is_unset(request.sls_store):
            query['slsStore'] = request.sls_store
        if not UtilClient.is_unset(request.tag):
            query['tag'] = request.tag
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPrometheusInstances',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListPrometheusInstancesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListPrometheusInstancesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_prometheus_instances(
        self,
        request: cms_20240330_models.ListPrometheusInstancesRequest,
    ) -> cms_20240330_models.ListPrometheusInstancesResponse:
        """
        @summary 获取Prometheus实例信息列表
        
        @param request: ListPrometheusInstancesRequest
        @return: ListPrometheusInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_prometheus_instances_with_options(request, headers, runtime)

    async def list_prometheus_instances_async(
        self,
        request: cms_20240330_models.ListPrometheusInstancesRequest,
    ) -> cms_20240330_models.ListPrometheusInstancesResponse:
        """
        @summary 获取Prometheus实例信息列表
        
        @param request: ListPrometheusInstancesRequest
        @return: ListPrometheusInstancesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_prometheus_instances_with_options_async(request, headers, runtime)

    def list_prometheus_metrics_with_options(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.ListPrometheusMetricsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListPrometheusMetricsResponse:
        """
        @summary 获取Prometheus实例topN指标列表
        
        @param request: ListPrometheusMetricsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPrometheusMetricsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.end_time):
            query['endTime'] = request.end_time
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.start_time):
            query['startTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPrometheusMetrics',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(prometheus_instance_id)}/metrics',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListPrometheusMetricsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListPrometheusMetricsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_prometheus_metrics_with_options_async(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.ListPrometheusMetricsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListPrometheusMetricsResponse:
        """
        @summary 获取Prometheus实例topN指标列表
        
        @param request: ListPrometheusMetricsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPrometheusMetricsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.end_time):
            query['endTime'] = request.end_time
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.start_time):
            query['startTime'] = request.start_time
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPrometheusMetrics',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(prometheus_instance_id)}/metrics',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListPrometheusMetricsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListPrometheusMetricsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_prometheus_metrics(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.ListPrometheusMetricsRequest,
    ) -> cms_20240330_models.ListPrometheusMetricsResponse:
        """
        @summary 获取Prometheus实例topN指标列表
        
        @param request: ListPrometheusMetricsRequest
        @return: ListPrometheusMetricsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_prometheus_metrics_with_options(prometheus_instance_id, request, headers, runtime)

    async def list_prometheus_metrics_async(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.ListPrometheusMetricsRequest,
    ) -> cms_20240330_models.ListPrometheusMetricsResponse:
        """
        @summary 获取Prometheus实例topN指标列表
        
        @param request: ListPrometheusMetricsRequest
        @return: ListPrometheusMetricsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_prometheus_metrics_with_options_async(prometheus_instance_id, request, headers, runtime)

    def list_prometheus_views_with_options(
        self,
        tmp_req: cms_20240330_models.ListPrometheusViewsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListPrometheusViewsResponse:
        """
        @summary 获取Prometheus视图实例信息列表
        
        @param tmp_req: ListPrometheusViewsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPrometheusViewsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListPrometheusViewsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.tag):
            request.tag_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.tag, 'tag', 'json')
        query = {}
        if not UtilClient.is_unset(request.filter_region_ids):
            query['filterRegionIds'] = request.filter_region_ids
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.prometheus_view_ids):
            query['prometheusViewIds'] = request.prometheus_view_ids
        if not UtilClient.is_unset(request.prometheus_view_name):
            query['prometheusViewName'] = request.prometheus_view_name
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_type):
            query['resourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag_shrink):
            query['tag'] = request.tag_shrink
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPrometheusViews',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-views',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListPrometheusViewsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListPrometheusViewsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_prometheus_views_with_options_async(
        self,
        tmp_req: cms_20240330_models.ListPrometheusViewsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListPrometheusViewsResponse:
        """
        @summary 获取Prometheus视图实例信息列表
        
        @param tmp_req: ListPrometheusViewsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListPrometheusViewsResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListPrometheusViewsShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.tag):
            request.tag_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.tag, 'tag', 'json')
        query = {}
        if not UtilClient.is_unset(request.filter_region_ids):
            query['filterRegionIds'] = request.filter_region_ids
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.prometheus_view_ids):
            query['prometheusViewIds'] = request.prometheus_view_ids
        if not UtilClient.is_unset(request.prometheus_view_name):
            query['prometheusViewName'] = request.prometheus_view_name
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.resource_type):
            query['resourceType'] = request.resource_type
        if not UtilClient.is_unset(request.tag_shrink):
            query['tag'] = request.tag_shrink
        if not UtilClient.is_unset(request.version):
            query['version'] = request.version
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListPrometheusViews',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-views',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListPrometheusViewsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListPrometheusViewsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_prometheus_views(
        self,
        request: cms_20240330_models.ListPrometheusViewsRequest,
    ) -> cms_20240330_models.ListPrometheusViewsResponse:
        """
        @summary 获取Prometheus视图实例信息列表
        
        @param request: ListPrometheusViewsRequest
        @return: ListPrometheusViewsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_prometheus_views_with_options(request, headers, runtime)

    async def list_prometheus_views_async(
        self,
        request: cms_20240330_models.ListPrometheusViewsRequest,
    ) -> cms_20240330_models.ListPrometheusViewsResponse:
        """
        @summary 获取Prometheus视图实例信息列表
        
        @param request: ListPrometheusViewsRequest
        @return: ListPrometheusViewsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_prometheus_views_with_options_async(request, headers, runtime)

    def list_site_monitors_with_options(
        self,
        request: cms_20240330_models.ListSiteMonitorsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListSiteMonitorsResponse:
        """
        @summary 列出资源SiteMonitor
        
        @param request: ListSiteMonitorsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSiteMonitorsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.create_time):
            query['createTime'] = request.create_time
        if not UtilClient.is_unset(request.filter):
            query['filter'] = request.filter
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.payment_type):
            query['paymentType'] = request.payment_type
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.site_monitor_id):
            query['siteMonitorId'] = request.site_monitor_id
        if not UtilClient.is_unset(request.site_monitor_name):
            query['siteMonitorName'] = request.site_monitor_name
        if not UtilClient.is_unset(request.skip):
            query['skip'] = request.skip
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSiteMonitors',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/SiteMonitors',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListSiteMonitorsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListSiteMonitorsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_site_monitors_with_options_async(
        self,
        request: cms_20240330_models.ListSiteMonitorsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListSiteMonitorsResponse:
        """
        @summary 列出资源SiteMonitor
        
        @param request: ListSiteMonitorsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSiteMonitorsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.create_time):
            query['createTime'] = request.create_time
        if not UtilClient.is_unset(request.filter):
            query['filter'] = request.filter
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.payment_type):
            query['paymentType'] = request.payment_type
        if not UtilClient.is_unset(request.resource_group_id):
            query['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.site_monitor_id):
            query['siteMonitorId'] = request.site_monitor_id
        if not UtilClient.is_unset(request.site_monitor_name):
            query['siteMonitorName'] = request.site_monitor_name
        if not UtilClient.is_unset(request.skip):
            query['skip'] = request.skip
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSiteMonitors',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/SiteMonitors',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListSiteMonitorsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListSiteMonitorsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_site_monitors(
        self,
        request: cms_20240330_models.ListSiteMonitorsRequest,
    ) -> cms_20240330_models.ListSiteMonitorsResponse:
        """
        @summary 列出资源SiteMonitor
        
        @param request: ListSiteMonitorsRequest
        @return: ListSiteMonitorsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_site_monitors_with_options(request, headers, runtime)

    async def list_site_monitors_async(
        self,
        request: cms_20240330_models.ListSiteMonitorsRequest,
    ) -> cms_20240330_models.ListSiteMonitorsResponse:
        """
        @summary 列出资源SiteMonitor
        
        @param request: ListSiteMonitorsRequest
        @return: ListSiteMonitorsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_site_monitors_with_options_async(request, headers, runtime)

    def list_subscriptions_with_options(
        self,
        request: cms_20240330_models.ListSubscriptionsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListSubscriptionsResponse:
        """
        @summary List Subscription
        
        @param request: ListSubscriptionsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSubscriptionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.enable):
            query['enable'] = request.enable
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.subscription_id):
            query['subscriptionId'] = request.subscription_id
        if not UtilClient.is_unset(request.subscription_name):
            query['subscriptionName'] = request.subscription_name
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSubscriptions',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/subscriptions',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListSubscriptionsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListSubscriptionsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_subscriptions_with_options_async(
        self,
        request: cms_20240330_models.ListSubscriptionsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListSubscriptionsResponse:
        """
        @summary List Subscription
        
        @param request: ListSubscriptionsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListSubscriptionsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.enable):
            query['enable'] = request.enable
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.subscription_id):
            query['subscriptionId'] = request.subscription_id
        if not UtilClient.is_unset(request.subscription_name):
            query['subscriptionName'] = request.subscription_name
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListSubscriptions',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/subscriptions',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListSubscriptionsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListSubscriptionsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_subscriptions(
        self,
        request: cms_20240330_models.ListSubscriptionsRequest,
    ) -> cms_20240330_models.ListSubscriptionsResponse:
        """
        @summary List Subscription
        
        @param request: ListSubscriptionsRequest
        @return: ListSubscriptionsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_subscriptions_with_options(request, headers, runtime)

    async def list_subscriptions_async(
        self,
        request: cms_20240330_models.ListSubscriptionsRequest,
    ) -> cms_20240330_models.ListSubscriptionsResponse:
        """
        @summary List Subscription
        
        @param request: ListSubscriptionsRequest
        @return: ListSubscriptionsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_subscriptions_with_options_async(request, headers, runtime)

    def list_transformers_with_options(
        self,
        request: cms_20240330_models.ListTransformersRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListTransformersResponse:
        """
        @summary List Transformer
        
        @param request: ListTransformersRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTransformersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.enable):
            query['enable'] = request.enable
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.transformer_id):
            query['transformerId'] = request.transformer_id
        if not UtilClient.is_unset(request.transformer_name):
            query['transformerName'] = request.transformer_name
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTransformers',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/transformers',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListTransformersResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListTransformersResponse(),
                self.execute(params, req, runtime)
            )

    async def list_transformers_with_options_async(
        self,
        request: cms_20240330_models.ListTransformersRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListTransformersResponse:
        """
        @summary List Transformer
        
        @param request: ListTransformersRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListTransformersResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.enable):
            query['enable'] = request.enable
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.transformer_id):
            query['transformerId'] = request.transformer_id
        if not UtilClient.is_unset(request.transformer_name):
            query['transformerName'] = request.transformer_name
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListTransformers',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/transformers',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListTransformersResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListTransformersResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_transformers(
        self,
        request: cms_20240330_models.ListTransformersRequest,
    ) -> cms_20240330_models.ListTransformersResponse:
        """
        @summary List Transformer
        
        @param request: ListTransformersRequest
        @return: ListTransformersResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_transformers_with_options(request, headers, runtime)

    async def list_transformers_async(
        self,
        request: cms_20240330_models.ListTransformersRequest,
    ) -> cms_20240330_models.ListTransformersResponse:
        """
        @summary List Transformer
        
        @param request: ListTransformersRequest
        @return: ListTransformersResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_transformers_with_options_async(request, headers, runtime)

    def list_user_event_histograms_with_options(
        self,
        request: cms_20240330_models.ListUserEventHistogramsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListUserEventHistogramsResponse:
        """
        @summary 列表用户事件
        
        @param request: ListUserEventHistogramsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListUserEventHistogramsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.from_):
            query['from'] = request.from_
        if not UtilClient.is_unset(request.id):
            query['id'] = request.id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.severity):
            query['severity'] = request.severity
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.source_type):
            query['sourceType'] = request.source_type
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.sub_type):
            query['subType'] = request.sub_type
        if not UtilClient.is_unset(request.subject):
            query['subject'] = request.subject
        if not UtilClient.is_unset(request.to):
            query['to'] = request.to
        if not UtilClient.is_unset(request.type):
            query['type'] = request.type
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListUserEventHistograms',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/userEventHistograms',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListUserEventHistogramsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListUserEventHistogramsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_user_event_histograms_with_options_async(
        self,
        request: cms_20240330_models.ListUserEventHistogramsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListUserEventHistogramsResponse:
        """
        @summary 列表用户事件
        
        @param request: ListUserEventHistogramsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListUserEventHistogramsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.from_):
            query['from'] = request.from_
        if not UtilClient.is_unset(request.id):
            query['id'] = request.id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.severity):
            query['severity'] = request.severity
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.source_type):
            query['sourceType'] = request.source_type
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.sub_type):
            query['subType'] = request.sub_type
        if not UtilClient.is_unset(request.subject):
            query['subject'] = request.subject
        if not UtilClient.is_unset(request.to):
            query['to'] = request.to
        if not UtilClient.is_unset(request.type):
            query['type'] = request.type
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListUserEventHistograms',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/userEventHistograms',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListUserEventHistogramsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListUserEventHistogramsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_user_event_histograms(
        self,
        request: cms_20240330_models.ListUserEventHistogramsRequest,
    ) -> cms_20240330_models.ListUserEventHistogramsResponse:
        """
        @summary 列表用户事件
        
        @param request: ListUserEventHistogramsRequest
        @return: ListUserEventHistogramsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_user_event_histograms_with_options(request, headers, runtime)

    async def list_user_event_histograms_async(
        self,
        request: cms_20240330_models.ListUserEventHistogramsRequest,
    ) -> cms_20240330_models.ListUserEventHistogramsResponse:
        """
        @summary 列表用户事件
        
        @param request: ListUserEventHistogramsRequest
        @return: ListUserEventHistogramsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_user_event_histograms_with_options_async(request, headers, runtime)

    def list_user_events_with_options(
        self,
        request: cms_20240330_models.ListUserEventsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListUserEventsResponse:
        """
        @summary 列表用户事件
        
        @param request: ListUserEventsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListUserEventsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.from_):
            query['from'] = request.from_
        if not UtilClient.is_unset(request.id):
            query['id'] = request.id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.severity):
            query['severity'] = request.severity
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.source_type):
            query['sourceType'] = request.source_type
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.sub_type):
            query['subType'] = request.sub_type
        if not UtilClient.is_unset(request.subject):
            query['subject'] = request.subject
        if not UtilClient.is_unset(request.to):
            query['to'] = request.to
        if not UtilClient.is_unset(request.type):
            query['type'] = request.type
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListUserEvents',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/userEvents',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListUserEventsResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListUserEventsResponse(),
                self.execute(params, req, runtime)
            )

    async def list_user_events_with_options_async(
        self,
        request: cms_20240330_models.ListUserEventsRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListUserEventsResponse:
        """
        @summary 列表用户事件
        
        @param request: ListUserEventsRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListUserEventsResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.from_):
            query['from'] = request.from_
        if not UtilClient.is_unset(request.id):
            query['id'] = request.id
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.severity):
            query['severity'] = request.severity
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.source_type):
            query['sourceType'] = request.source_type
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        if not UtilClient.is_unset(request.sub_type):
            query['subType'] = request.sub_type
        if not UtilClient.is_unset(request.subject):
            query['subject'] = request.subject
        if not UtilClient.is_unset(request.to):
            query['to'] = request.to
        if not UtilClient.is_unset(request.type):
            query['type'] = request.type
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListUserEvents',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/userEvents',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListUserEventsResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListUserEventsResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_user_events(
        self,
        request: cms_20240330_models.ListUserEventsRequest,
    ) -> cms_20240330_models.ListUserEventsResponse:
        """
        @summary 列表用户事件
        
        @param request: ListUserEventsRequest
        @return: ListUserEventsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_user_events_with_options(request, headers, runtime)

    async def list_user_events_async(
        self,
        request: cms_20240330_models.ListUserEventsRequest,
    ) -> cms_20240330_models.ListUserEventsResponse:
        """
        @summary 列表用户事件
        
        @param request: ListUserEventsRequest
        @return: ListUserEventsResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_user_events_with_options_async(request, headers, runtime)

    def list_workspaces_with_options(
        self,
        tmp_req: cms_20240330_models.ListWorkspacesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListWorkspacesResponse:
        """
        @summary 获取工作空间列表
        
        @param tmp_req: ListWorkspacesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListWorkspacesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListWorkspacesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.workspace_name_list):
            request.workspace_name_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.workspace_name_list, 'workspaceNameList', 'simple')
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.region):
            query['region'] = request.region
        if not UtilClient.is_unset(request.workspace_name):
            query['workspaceName'] = request.workspace_name
        if not UtilClient.is_unset(request.workspace_name_list_shrink):
            query['workspaceNameList'] = request.workspace_name_list_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListWorkspaces',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListWorkspacesResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListWorkspacesResponse(),
                self.execute(params, req, runtime)
            )

    async def list_workspaces_with_options_async(
        self,
        tmp_req: cms_20240330_models.ListWorkspacesRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ListWorkspacesResponse:
        """
        @summary 获取工作空间列表
        
        @param tmp_req: ListWorkspacesRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ListWorkspacesResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ListWorkspacesShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.workspace_name_list):
            request.workspace_name_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.workspace_name_list, 'workspaceNameList', 'simple')
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.region):
            query['region'] = request.region
        if not UtilClient.is_unset(request.workspace_name):
            query['workspaceName'] = request.workspace_name
        if not UtilClient.is_unset(request.workspace_name_list_shrink):
            query['workspaceNameList'] = request.workspace_name_list_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ListWorkspaces',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ListWorkspacesResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ListWorkspacesResponse(),
                await self.execute_async(params, req, runtime)
            )

    def list_workspaces(
        self,
        request: cms_20240330_models.ListWorkspacesRequest,
    ) -> cms_20240330_models.ListWorkspacesResponse:
        """
        @summary 获取工作空间列表
        
        @param request: ListWorkspacesRequest
        @return: ListWorkspacesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.list_workspaces_with_options(request, headers, runtime)

    async def list_workspaces_async(
        self,
        request: cms_20240330_models.ListWorkspacesRequest,
    ) -> cms_20240330_models.ListWorkspacesResponse:
        """
        @summary 获取工作空间列表
        
        @param request: ListWorkspacesRequest
        @return: ListWorkspacesResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.list_workspaces_with_options_async(request, headers, runtime)

    def open_cms_service_with_options(
        self,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.OpenCmsServiceResponse:
        """
        @summary 开通云监控
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: OpenCmsServiceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='OpenCmsService',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/cmsservice',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.OpenCmsServiceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.OpenCmsServiceResponse(),
                self.execute(params, req, runtime)
            )

    async def open_cms_service_with_options_async(
        self,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.OpenCmsServiceResponse:
        """
        @summary 开通云监控
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: OpenCmsServiceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='OpenCmsService',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/cmsservice',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.OpenCmsServiceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.OpenCmsServiceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def open_cms_service(self) -> cms_20240330_models.OpenCmsServiceResponse:
        """
        @summary 开通云监控
        
        @return: OpenCmsServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.open_cms_service_with_options(headers, runtime)

    async def open_cms_service_async(self) -> cms_20240330_models.OpenCmsServiceResponse:
        """
        @summary 开通云监控
        
        @return: OpenCmsServiceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.open_cms_service_with_options_async(headers, runtime)

    def patch_alert_rule_with_options(
        self,
        alert_rule_id: str,
        request: cms_20240330_models.PatchAlertRuleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.PatchAlertRuleResponse:
        """
        @summary 增量更新云监控2.0告警规则
        
        @param request: PatchAlertRuleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: PatchAlertRuleResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_metric_input):
            body['alertMetricInput'] = request.alert_metric_input
        if not UtilClient.is_unset(request.annotations):
            body['annotations'] = request.annotations
        if not UtilClient.is_unset(request.condition):
            body['condition'] = request.condition
        if not UtilClient.is_unset(request.display_name):
            body['displayName'] = request.display_name
        if not UtilClient.is_unset(request.effect_time):
            body['effectTime'] = request.effect_time
        if not UtilClient.is_unset(request.interval):
            body['interval'] = request.interval
        if not UtilClient.is_unset(request.labels):
            body['labels'] = request.labels
        if not UtilClient.is_unset(request.level):
            body['level'] = request.level
        if not UtilClient.is_unset(request.message):
            body['message'] = request.message
        if not UtilClient.is_unset(request.query):
            body['query'] = request.query
        if not UtilClient.is_unset(request.send):
            body['send'] = request.send
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='PatchAlertRule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules/{OpenApiUtilClient.get_encode_param(alert_rule_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.PatchAlertRuleResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.PatchAlertRuleResponse(),
                self.execute(params, req, runtime)
            )

    async def patch_alert_rule_with_options_async(
        self,
        alert_rule_id: str,
        request: cms_20240330_models.PatchAlertRuleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.PatchAlertRuleResponse:
        """
        @summary 增量更新云监控2.0告警规则
        
        @param request: PatchAlertRuleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: PatchAlertRuleResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_metric_input):
            body['alertMetricInput'] = request.alert_metric_input
        if not UtilClient.is_unset(request.annotations):
            body['annotations'] = request.annotations
        if not UtilClient.is_unset(request.condition):
            body['condition'] = request.condition
        if not UtilClient.is_unset(request.display_name):
            body['displayName'] = request.display_name
        if not UtilClient.is_unset(request.effect_time):
            body['effectTime'] = request.effect_time
        if not UtilClient.is_unset(request.interval):
            body['interval'] = request.interval
        if not UtilClient.is_unset(request.labels):
            body['labels'] = request.labels
        if not UtilClient.is_unset(request.level):
            body['level'] = request.level
        if not UtilClient.is_unset(request.message):
            body['message'] = request.message
        if not UtilClient.is_unset(request.query):
            body['query'] = request.query
        if not UtilClient.is_unset(request.send):
            body['send'] = request.send
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='PatchAlertRule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules/{OpenApiUtilClient.get_encode_param(alert_rule_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.PatchAlertRuleResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.PatchAlertRuleResponse(),
                await self.execute_async(params, req, runtime)
            )

    def patch_alert_rule(
        self,
        alert_rule_id: str,
        request: cms_20240330_models.PatchAlertRuleRequest,
    ) -> cms_20240330_models.PatchAlertRuleResponse:
        """
        @summary 增量更新云监控2.0告警规则
        
        @param request: PatchAlertRuleRequest
        @return: PatchAlertRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.patch_alert_rule_with_options(alert_rule_id, request, headers, runtime)

    async def patch_alert_rule_async(
        self,
        alert_rule_id: str,
        request: cms_20240330_models.PatchAlertRuleRequest,
    ) -> cms_20240330_models.PatchAlertRuleResponse:
        """
        @summary 增量更新云监控2.0告警规则
        
        @param request: PatchAlertRuleRequest
        @return: PatchAlertRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.patch_alert_rule_with_options_async(alert_rule_id, request, headers, runtime)

    def put_incident_robot_command_with_options(
        self,
        request: cms_20240330_models.PutIncidentRobotCommandRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.PutIncidentRobotCommandResponse:
        """
        @summary 发送机器人指令
        
        @param request: PutIncidentRobotCommandRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: PutIncidentRobotCommandResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command):
            query['command'] = request.command
        if not UtilClient.is_unset(request.content):
            query['content'] = request.content
        if not UtilClient.is_unset(request.id_code):
            query['idCode'] = request.id_code
        if not UtilClient.is_unset(request.session_id):
            query['sessionId'] = request.session_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PutIncidentRobotCommand',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/robot/command',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.PutIncidentRobotCommandResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.PutIncidentRobotCommandResponse(),
                self.execute(params, req, runtime)
            )

    async def put_incident_robot_command_with_options_async(
        self,
        request: cms_20240330_models.PutIncidentRobotCommandRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.PutIncidentRobotCommandResponse:
        """
        @summary 发送机器人指令
        
        @param request: PutIncidentRobotCommandRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: PutIncidentRobotCommandResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.command):
            query['command'] = request.command
        if not UtilClient.is_unset(request.content):
            query['content'] = request.content
        if not UtilClient.is_unset(request.id_code):
            query['idCode'] = request.id_code
        if not UtilClient.is_unset(request.session_id):
            query['sessionId'] = request.session_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='PutIncidentRobotCommand',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/robot/command',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.PutIncidentRobotCommandResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.PutIncidentRobotCommandResponse(),
                await self.execute_async(params, req, runtime)
            )

    def put_incident_robot_command(
        self,
        request: cms_20240330_models.PutIncidentRobotCommandRequest,
    ) -> cms_20240330_models.PutIncidentRobotCommandResponse:
        """
        @summary 发送机器人指令
        
        @param request: PutIncidentRobotCommandRequest
        @return: PutIncidentRobotCommandResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.put_incident_robot_command_with_options(request, headers, runtime)

    async def put_incident_robot_command_async(
        self,
        request: cms_20240330_models.PutIncidentRobotCommandRequest,
    ) -> cms_20240330_models.PutIncidentRobotCommandResponse:
        """
        @summary 发送机器人指令
        
        @param request: PutIncidentRobotCommandRequest
        @return: PutIncidentRobotCommandResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.put_incident_robot_command_with_options_async(request, headers, runtime)

    def put_workspace_with_options(
        self,
        workspace_name: str,
        request: cms_20240330_models.PutWorkspaceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.PutWorkspaceResponse:
        """
        @summary 创建工作空间
        
        @param request: PutWorkspaceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: PutWorkspaceResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.description):
            body['description'] = request.description
        if not UtilClient.is_unset(request.display_name):
            body['displayName'] = request.display_name
        if not UtilClient.is_unset(request.sls_project):
            body['slsProject'] = request.sls_project
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='PutWorkspace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace_name)}',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.PutWorkspaceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.PutWorkspaceResponse(),
                self.execute(params, req, runtime)
            )

    async def put_workspace_with_options_async(
        self,
        workspace_name: str,
        request: cms_20240330_models.PutWorkspaceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.PutWorkspaceResponse:
        """
        @summary 创建工作空间
        
        @param request: PutWorkspaceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: PutWorkspaceResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.description):
            body['description'] = request.description
        if not UtilClient.is_unset(request.display_name):
            body['displayName'] = request.display_name
        if not UtilClient.is_unset(request.sls_project):
            body['slsProject'] = request.sls_project
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='PutWorkspace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace_name)}',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.PutWorkspaceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.PutWorkspaceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def put_workspace(
        self,
        workspace_name: str,
        request: cms_20240330_models.PutWorkspaceRequest,
    ) -> cms_20240330_models.PutWorkspaceResponse:
        """
        @summary 创建工作空间
        
        @param request: PutWorkspaceRequest
        @return: PutWorkspaceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.put_workspace_with_options(workspace_name, request, headers, runtime)

    async def put_workspace_async(
        self,
        workspace_name: str,
        request: cms_20240330_models.PutWorkspaceRequest,
    ) -> cms_20240330_models.PutWorkspaceResponse:
        """
        @summary 创建工作空间
        
        @param request: PutWorkspaceRequest
        @return: PutWorkspaceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.put_workspace_with_options_async(workspace_name, request, headers, runtime)

    def render_alert_metric_with_options(
        self,
        alert_metric_id: str,
        tmp_req: cms_20240330_models.RenderAlertMetricRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.RenderAlertMetricResponse:
        """
        @summary 渲染云监控2.0告警指标
        
        @param tmp_req: RenderAlertMetricRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: RenderAlertMetricResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.RenderAlertMetricShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.filter_values):
            request.filter_values_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.filter_values, 'filterValues', 'json')
        if not UtilClient.is_unset(tmp_req.param_values):
            request.param_values_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param_values, 'paramValues', 'json')
        query = {}
        if not UtilClient.is_unset(request.filter_values_shrink):
            query['filterValues'] = request.filter_values_shrink
        if not UtilClient.is_unset(request.param_values_shrink):
            query['paramValues'] = request.param_values_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RenderAlertMetric',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertMetrics/{OpenApiUtilClient.get_encode_param(alert_metric_id)}/render',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.RenderAlertMetricResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.RenderAlertMetricResponse(),
                self.execute(params, req, runtime)
            )

    async def render_alert_metric_with_options_async(
        self,
        alert_metric_id: str,
        tmp_req: cms_20240330_models.RenderAlertMetricRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.RenderAlertMetricResponse:
        """
        @summary 渲染云监控2.0告警指标
        
        @param tmp_req: RenderAlertMetricRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: RenderAlertMetricResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.RenderAlertMetricShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.filter_values):
            request.filter_values_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.filter_values, 'filterValues', 'json')
        if not UtilClient.is_unset(tmp_req.param_values):
            request.param_values_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.param_values, 'paramValues', 'json')
        query = {}
        if not UtilClient.is_unset(request.filter_values_shrink):
            query['filterValues'] = request.filter_values_shrink
        if not UtilClient.is_unset(request.param_values_shrink):
            query['paramValues'] = request.param_values_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='RenderAlertMetric',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertMetrics/{OpenApiUtilClient.get_encode_param(alert_metric_id)}/render',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.RenderAlertMetricResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.RenderAlertMetricResponse(),
                await self.execute_async(params, req, runtime)
            )

    def render_alert_metric(
        self,
        alert_metric_id: str,
        request: cms_20240330_models.RenderAlertMetricRequest,
    ) -> cms_20240330_models.RenderAlertMetricResponse:
        """
        @summary 渲染云监控2.0告警指标
        
        @param request: RenderAlertMetricRequest
        @return: RenderAlertMetricResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.render_alert_metric_with_options(alert_metric_id, request, headers, runtime)

    async def render_alert_metric_async(
        self,
        alert_metric_id: str,
        request: cms_20240330_models.RenderAlertMetricRequest,
    ) -> cms_20240330_models.RenderAlertMetricResponse:
        """
        @summary 渲染云监控2.0告警指标
        
        @param request: RenderAlertMetricRequest
        @return: RenderAlertMetricResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.render_alert_metric_with_options_async(alert_metric_id, request, headers, runtime)

    def resend_verify_activate_with_options(
        self,
        contact_id: str,
        request: cms_20240330_models.ResendVerifyActivateRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ResendVerifyActivateResponse:
        """
        @summary 重新发送激活链接
        
        @param request: ResendVerifyActivateRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ResendVerifyActivateResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.channel_type):
            body['channelType'] = request.channel_type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ResendVerifyActivate',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contact/{OpenApiUtilClient.get_encode_param(contact_id)}/action/reSendVerifyActivate',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='formData',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ResendVerifyActivateResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ResendVerifyActivateResponse(),
                self.execute(params, req, runtime)
            )

    async def resend_verify_activate_with_options_async(
        self,
        contact_id: str,
        request: cms_20240330_models.ResendVerifyActivateRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ResendVerifyActivateResponse:
        """
        @summary 重新发送激活链接
        
        @param request: ResendVerifyActivateRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ResendVerifyActivateResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.channel_type):
            body['channelType'] = request.channel_type
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='ResendVerifyActivate',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contact/{OpenApiUtilClient.get_encode_param(contact_id)}/action/reSendVerifyActivate',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='formData',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ResendVerifyActivateResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ResendVerifyActivateResponse(),
                await self.execute_async(params, req, runtime)
            )

    def resend_verify_activate(
        self,
        contact_id: str,
        request: cms_20240330_models.ResendVerifyActivateRequest,
    ) -> cms_20240330_models.ResendVerifyActivateResponse:
        """
        @summary 重新发送激活链接
        
        @param request: ResendVerifyActivateRequest
        @return: ResendVerifyActivateResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.resend_verify_activate_with_options(contact_id, request, headers, runtime)

    async def resend_verify_activate_async(
        self,
        contact_id: str,
        request: cms_20240330_models.ResendVerifyActivateRequest,
    ) -> cms_20240330_models.ResendVerifyActivateResponse:
        """
        @summary 重新发送激活链接
        
        @param request: ResendVerifyActivateRequest
        @return: ResendVerifyActivateResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.resend_verify_activate_with_options_async(contact_id, request, headers, runtime)

    def resolve_incident_with_options(
        self,
        request: cms_20240330_models.ResolveIncidentRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ResolveIncidentResponse:
        """
        @summary 事件解决
        
        @param request: ResolveIncidentRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ResolveIncidentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ResolveIncident',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/resolve',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ResolveIncidentResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ResolveIncidentResponse(),
                self.execute(params, req, runtime)
            )

    async def resolve_incident_with_options_async(
        self,
        request: cms_20240330_models.ResolveIncidentRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ResolveIncidentResponse:
        """
        @summary 事件解决
        
        @param request: ResolveIncidentRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ResolveIncidentResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.incident_id):
            query['incidentId'] = request.incident_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ResolveIncident',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/resolve',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ResolveIncidentResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ResolveIncidentResponse(),
                await self.execute_async(params, req, runtime)
            )

    def resolve_incident(
        self,
        request: cms_20240330_models.ResolveIncidentRequest,
    ) -> cms_20240330_models.ResolveIncidentResponse:
        """
        @summary 事件解决
        
        @param request: ResolveIncidentRequest
        @return: ResolveIncidentResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.resolve_incident_with_options(request, headers, runtime)

    async def resolve_incident_async(
        self,
        request: cms_20240330_models.ResolveIncidentRequest,
    ) -> cms_20240330_models.ResolveIncidentResponse:
        """
        @summary 事件解决
        
        @param request: ResolveIncidentRequest
        @return: ResolveIncidentResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.resolve_incident_with_options_async(request, headers, runtime)

    def test_delete_workspace_with_options(
        self,
        workspace_name: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.TestDeleteWorkspaceResponse:
        """
        @summary 删除工作空间
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: TestDeleteWorkspaceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='TestDeleteWorkspace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/test/{OpenApiUtilClient.get_encode_param(workspace_name)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.TestDeleteWorkspaceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.TestDeleteWorkspaceResponse(),
                self.execute(params, req, runtime)
            )

    async def test_delete_workspace_with_options_async(
        self,
        workspace_name: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.TestDeleteWorkspaceResponse:
        """
        @summary 删除工作空间
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: TestDeleteWorkspaceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='TestDeleteWorkspace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/test/{OpenApiUtilClient.get_encode_param(workspace_name)}',
            method='DELETE',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.TestDeleteWorkspaceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.TestDeleteWorkspaceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def test_delete_workspace(
        self,
        workspace_name: str,
    ) -> cms_20240330_models.TestDeleteWorkspaceResponse:
        """
        @summary 删除工作空间
        
        @return: TestDeleteWorkspaceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.test_delete_workspace_with_options(workspace_name, headers, runtime)

    async def test_delete_workspace_async(
        self,
        workspace_name: str,
    ) -> cms_20240330_models.TestDeleteWorkspaceResponse:
        """
        @summary 删除工作空间
        
        @return: TestDeleteWorkspaceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.test_delete_workspace_with_options_async(workspace_name, headers, runtime)

    def test_get_workspace_with_options(
        self,
        workspace_name: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.TestGetWorkspaceResponse:
        """
        @summary 获取工作空间
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: TestGetWorkspaceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='TestGetWorkspace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/test/{OpenApiUtilClient.get_encode_param(workspace_name)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.TestGetWorkspaceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.TestGetWorkspaceResponse(),
                self.execute(params, req, runtime)
            )

    async def test_get_workspace_with_options_async(
        self,
        workspace_name: str,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.TestGetWorkspaceResponse:
        """
        @summary 获取工作空间
        
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: TestGetWorkspaceResponse
        """
        req = open_api_models.OpenApiRequest(
            headers=headers
        )
        params = open_api_models.Params(
            action='TestGetWorkspace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/test/{OpenApiUtilClient.get_encode_param(workspace_name)}',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.TestGetWorkspaceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.TestGetWorkspaceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def test_get_workspace(
        self,
        workspace_name: str,
    ) -> cms_20240330_models.TestGetWorkspaceResponse:
        """
        @summary 获取工作空间
        
        @return: TestGetWorkspaceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.test_get_workspace_with_options(workspace_name, headers, runtime)

    async def test_get_workspace_async(
        self,
        workspace_name: str,
    ) -> cms_20240330_models.TestGetWorkspaceResponse:
        """
        @summary 获取工作空间
        
        @return: TestGetWorkspaceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.test_get_workspace_with_options_async(workspace_name, headers, runtime)

    def test_list_workspace_with_options(
        self,
        tmp_req: cms_20240330_models.TestListWorkspaceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.TestListWorkspaceResponse:
        """
        @summary 获取工作空间列表
        
        @param tmp_req: TestListWorkspaceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: TestListWorkspaceResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.TestListWorkspaceShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.workspace_name_list):
            request.workspace_name_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.workspace_name_list, 'workspaceNameList', 'simple')
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.region):
            query['region'] = request.region
        if not UtilClient.is_unset(request.workspace_name):
            query['workspaceName'] = request.workspace_name
        if not UtilClient.is_unset(request.workspace_name_list_shrink):
            query['workspaceNameList'] = request.workspace_name_list_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TestListWorkspace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/test',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.TestListWorkspaceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.TestListWorkspaceResponse(),
                self.execute(params, req, runtime)
            )

    async def test_list_workspace_with_options_async(
        self,
        tmp_req: cms_20240330_models.TestListWorkspaceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.TestListWorkspaceResponse:
        """
        @summary 获取工作空间列表
        
        @param tmp_req: TestListWorkspaceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: TestListWorkspaceResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.TestListWorkspaceShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.workspace_name_list):
            request.workspace_name_list_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.workspace_name_list, 'workspaceNameList', 'simple')
        query = {}
        if not UtilClient.is_unset(request.max_results):
            query['maxResults'] = request.max_results
        if not UtilClient.is_unset(request.next_token):
            query['nextToken'] = request.next_token
        if not UtilClient.is_unset(request.region):
            query['region'] = request.region
        if not UtilClient.is_unset(request.workspace_name):
            query['workspaceName'] = request.workspace_name
        if not UtilClient.is_unset(request.workspace_name_list_shrink):
            query['workspaceNameList'] = request.workspace_name_list_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='TestListWorkspace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/test',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.TestListWorkspaceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.TestListWorkspaceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def test_list_workspace(
        self,
        request: cms_20240330_models.TestListWorkspaceRequest,
    ) -> cms_20240330_models.TestListWorkspaceResponse:
        """
        @summary 获取工作空间列表
        
        @param request: TestListWorkspaceRequest
        @return: TestListWorkspaceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.test_list_workspace_with_options(request, headers, runtime)

    async def test_list_workspace_async(
        self,
        request: cms_20240330_models.TestListWorkspaceRequest,
    ) -> cms_20240330_models.TestListWorkspaceResponse:
        """
        @summary 获取工作空间列表
        
        @param request: TestListWorkspaceRequest
        @return: TestListWorkspaceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.test_list_workspace_with_options_async(request, headers, runtime)

    def test_put_workspace_with_options(
        self,
        workspace_name: str,
        request: cms_20240330_models.TestPutWorkspaceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.TestPutWorkspaceResponse:
        """
        @summary 创建工作空间
        
        @param request: TestPutWorkspaceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: TestPutWorkspaceResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.description):
            body['description'] = request.description
        if not UtilClient.is_unset(request.display_name):
            body['displayName'] = request.display_name
        if not UtilClient.is_unset(request.resource_group_id):
            body['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.sls_project):
            body['slsProject'] = request.sls_project
        if not UtilClient.is_unset(request.tags):
            body['tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='TestPutWorkspace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/test/{OpenApiUtilClient.get_encode_param(workspace_name)}',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.TestPutWorkspaceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.TestPutWorkspaceResponse(),
                self.execute(params, req, runtime)
            )

    async def test_put_workspace_with_options_async(
        self,
        workspace_name: str,
        request: cms_20240330_models.TestPutWorkspaceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.TestPutWorkspaceResponse:
        """
        @summary 创建工作空间
        
        @param request: TestPutWorkspaceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: TestPutWorkspaceResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.description):
            body['description'] = request.description
        if not UtilClient.is_unset(request.display_name):
            body['displayName'] = request.display_name
        if not UtilClient.is_unset(request.resource_group_id):
            body['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.sls_project):
            body['slsProject'] = request.sls_project
        if not UtilClient.is_unset(request.tags):
            body['tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='TestPutWorkspace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/test/{OpenApiUtilClient.get_encode_param(workspace_name)}',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.TestPutWorkspaceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.TestPutWorkspaceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def test_put_workspace(
        self,
        workspace_name: str,
        request: cms_20240330_models.TestPutWorkspaceRequest,
    ) -> cms_20240330_models.TestPutWorkspaceResponse:
        """
        @summary 创建工作空间
        
        @param request: TestPutWorkspaceRequest
        @return: TestPutWorkspaceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.test_put_workspace_with_options(workspace_name, request, headers, runtime)

    async def test_put_workspace_async(
        self,
        workspace_name: str,
        request: cms_20240330_models.TestPutWorkspaceRequest,
    ) -> cms_20240330_models.TestPutWorkspaceResponse:
        """
        @summary 创建工作空间
        
        @param request: TestPutWorkspaceRequest
        @return: TestPutWorkspaceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.test_put_workspace_with_options_async(workspace_name, request, headers, runtime)

    def update_addon_release_with_options(
        self,
        release_name: str,
        policy_id: str,
        request: cms_20240330_models.UpdateAddonReleaseRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAddonReleaseResponse:
        """
        @summary 升级接入组件
        
        @param request: UpdateAddonReleaseRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAddonReleaseResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.addon_version):
            body['addonVersion'] = request.addon_version
        if not UtilClient.is_unset(request.dry_run):
            body['dryRun'] = request.dry_run
        if not UtilClient.is_unset(request.values):
            body['values'] = request.values
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateAddonRelease',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/addon-releases/{OpenApiUtilClient.get_encode_param(release_name)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAddonReleaseResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAddonReleaseResponse(),
                self.execute(params, req, runtime)
            )

    async def update_addon_release_with_options_async(
        self,
        release_name: str,
        policy_id: str,
        request: cms_20240330_models.UpdateAddonReleaseRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAddonReleaseResponse:
        """
        @summary 升级接入组件
        
        @param request: UpdateAddonReleaseRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAddonReleaseResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.addon_version):
            body['addonVersion'] = request.addon_version
        if not UtilClient.is_unset(request.dry_run):
            body['dryRun'] = request.dry_run
        if not UtilClient.is_unset(request.values):
            body['values'] = request.values
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateAddonRelease',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(policy_id)}/addon-releases/{OpenApiUtilClient.get_encode_param(release_name)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAddonReleaseResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAddonReleaseResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_addon_release(
        self,
        release_name: str,
        policy_id: str,
        request: cms_20240330_models.UpdateAddonReleaseRequest,
    ) -> cms_20240330_models.UpdateAddonReleaseResponse:
        """
        @summary 升级接入组件
        
        @param request: UpdateAddonReleaseRequest
        @return: UpdateAddonReleaseResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_addon_release_with_options(release_name, policy_id, request, headers, runtime)

    async def update_addon_release_async(
        self,
        release_name: str,
        policy_id: str,
        request: cms_20240330_models.UpdateAddonReleaseRequest,
    ) -> cms_20240330_models.UpdateAddonReleaseResponse:
        """
        @summary 升级接入组件
        
        @param request: UpdateAddonReleaseRequest
        @return: UpdateAddonReleaseResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_addon_release_with_options_async(release_name, policy_id, request, headers, runtime)

    def update_agg_task_group_with_options(
        self,
        instance_id: str,
        group_id: str,
        request: cms_20240330_models.UpdateAggTaskGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAggTaskGroupResponse:
        """
        @summary 应用聚合任务组
        
        @param request: UpdateAggTaskGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAggTaskGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.agg_task_group_config):
            body['aggTaskGroupConfig'] = request.agg_task_group_config
        if not UtilClient.is_unset(request.agg_task_group_config_type):
            body['aggTaskGroupConfigType'] = request.agg_task_group_config_type
        if not UtilClient.is_unset(request.agg_task_group_name):
            body['aggTaskGroupName'] = request.agg_task_group_name
        if not UtilClient.is_unset(request.cron_expr):
            body['cronExpr'] = request.cron_expr
        if not UtilClient.is_unset(request.delay):
            body['delay'] = request.delay
        if not UtilClient.is_unset(request.description):
            body['description'] = request.description
        if not UtilClient.is_unset(request.from_time):
            body['fromTime'] = request.from_time
        if not UtilClient.is_unset(request.max_retries):
            body['maxRetries'] = request.max_retries
        if not UtilClient.is_unset(request.max_run_time_in_seconds):
            body['maxRunTimeInSeconds'] = request.max_run_time_in_seconds
        if not UtilClient.is_unset(request.precheck_string):
            body['precheckString'] = request.precheck_string
        if not UtilClient.is_unset(request.schedule_mode):
            body['scheduleMode'] = request.schedule_mode
        if not UtilClient.is_unset(request.schedule_time_expr):
            body['scheduleTimeExpr'] = request.schedule_time_expr
        if not UtilClient.is_unset(request.status):
            body['status'] = request.status
        if not UtilClient.is_unset(request.tags):
            body['tags'] = request.tags
        if not UtilClient.is_unset(request.target_prometheus_id):
            body['targetPrometheusId'] = request.target_prometheus_id
        if not UtilClient.is_unset(request.to_time):
            body['toTime'] = request.to_time
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateAggTaskGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(instance_id)}/agg-task-groups/{OpenApiUtilClient.get_encode_param(group_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAggTaskGroupResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAggTaskGroupResponse(),
                self.execute(params, req, runtime)
            )

    async def update_agg_task_group_with_options_async(
        self,
        instance_id: str,
        group_id: str,
        request: cms_20240330_models.UpdateAggTaskGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAggTaskGroupResponse:
        """
        @summary 应用聚合任务组
        
        @param request: UpdateAggTaskGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAggTaskGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.agg_task_group_config):
            body['aggTaskGroupConfig'] = request.agg_task_group_config
        if not UtilClient.is_unset(request.agg_task_group_config_type):
            body['aggTaskGroupConfigType'] = request.agg_task_group_config_type
        if not UtilClient.is_unset(request.agg_task_group_name):
            body['aggTaskGroupName'] = request.agg_task_group_name
        if not UtilClient.is_unset(request.cron_expr):
            body['cronExpr'] = request.cron_expr
        if not UtilClient.is_unset(request.delay):
            body['delay'] = request.delay
        if not UtilClient.is_unset(request.description):
            body['description'] = request.description
        if not UtilClient.is_unset(request.from_time):
            body['fromTime'] = request.from_time
        if not UtilClient.is_unset(request.max_retries):
            body['maxRetries'] = request.max_retries
        if not UtilClient.is_unset(request.max_run_time_in_seconds):
            body['maxRunTimeInSeconds'] = request.max_run_time_in_seconds
        if not UtilClient.is_unset(request.precheck_string):
            body['precheckString'] = request.precheck_string
        if not UtilClient.is_unset(request.schedule_mode):
            body['scheduleMode'] = request.schedule_mode
        if not UtilClient.is_unset(request.schedule_time_expr):
            body['scheduleTimeExpr'] = request.schedule_time_expr
        if not UtilClient.is_unset(request.status):
            body['status'] = request.status
        if not UtilClient.is_unset(request.tags):
            body['tags'] = request.tags
        if not UtilClient.is_unset(request.target_prometheus_id):
            body['targetPrometheusId'] = request.target_prometheus_id
        if not UtilClient.is_unset(request.to_time):
            body['toTime'] = request.to_time
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateAggTaskGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(instance_id)}/agg-task-groups/{OpenApiUtilClient.get_encode_param(group_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAggTaskGroupResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAggTaskGroupResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_agg_task_group(
        self,
        instance_id: str,
        group_id: str,
        request: cms_20240330_models.UpdateAggTaskGroupRequest,
    ) -> cms_20240330_models.UpdateAggTaskGroupResponse:
        """
        @summary 应用聚合任务组
        
        @param request: UpdateAggTaskGroupRequest
        @return: UpdateAggTaskGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_agg_task_group_with_options(instance_id, group_id, request, headers, runtime)

    async def update_agg_task_group_async(
        self,
        instance_id: str,
        group_id: str,
        request: cms_20240330_models.UpdateAggTaskGroupRequest,
    ) -> cms_20240330_models.UpdateAggTaskGroupResponse:
        """
        @summary 应用聚合任务组
        
        @param request: UpdateAggTaskGroupRequest
        @return: UpdateAggTaskGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_agg_task_group_with_options_async(instance_id, group_id, request, headers, runtime)

    def update_agg_task_group_status_with_options(
        self,
        instance_id: str,
        group_id: str,
        request: cms_20240330_models.UpdateAggTaskGroupStatusRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAggTaskGroupStatusResponse:
        """
        @summary 更新聚合任务组状态
        
        @param request: UpdateAggTaskGroupStatusRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAggTaskGroupStatusResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.status):
            body['status'] = request.status
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateAggTaskGroupStatus',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(instance_id)}/agg-task-groups/{OpenApiUtilClient.get_encode_param(group_id)}/status',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAggTaskGroupStatusResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAggTaskGroupStatusResponse(),
                self.execute(params, req, runtime)
            )

    async def update_agg_task_group_status_with_options_async(
        self,
        instance_id: str,
        group_id: str,
        request: cms_20240330_models.UpdateAggTaskGroupStatusRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAggTaskGroupStatusResponse:
        """
        @summary 更新聚合任务组状态
        
        @param request: UpdateAggTaskGroupStatusRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAggTaskGroupStatusResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.status):
            body['status'] = request.status
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateAggTaskGroupStatus',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(instance_id)}/agg-task-groups/{OpenApiUtilClient.get_encode_param(group_id)}/status',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAggTaskGroupStatusResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAggTaskGroupStatusResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_agg_task_group_status(
        self,
        instance_id: str,
        group_id: str,
        request: cms_20240330_models.UpdateAggTaskGroupStatusRequest,
    ) -> cms_20240330_models.UpdateAggTaskGroupStatusResponse:
        """
        @summary 更新聚合任务组状态
        
        @param request: UpdateAggTaskGroupStatusRequest
        @return: UpdateAggTaskGroupStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_agg_task_group_status_with_options(instance_id, group_id, request, headers, runtime)

    async def update_agg_task_group_status_async(
        self,
        instance_id: str,
        group_id: str,
        request: cms_20240330_models.UpdateAggTaskGroupStatusRequest,
    ) -> cms_20240330_models.UpdateAggTaskGroupStatusResponse:
        """
        @summary 更新聚合任务组状态
        
        @param request: UpdateAggTaskGroupStatusRequest
        @return: UpdateAggTaskGroupStatusResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_agg_task_group_status_with_options_async(instance_id, group_id, request, headers, runtime)

    def update_alert_action_with_options(
        self,
        alert_action_id: str,
        request: cms_20240330_models.UpdateAlertActionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAlertActionResponse:
        """
        @summary 修改告警动作
        
        @param request: UpdateAlertActionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAlertActionResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_action_name):
            body['alertActionName'] = request.alert_action_name
        if not UtilClient.is_unset(request.ess_param):
            body['essParam'] = request.ess_param
        if not UtilClient.is_unset(request.fc_param):
            body['fcParam'] = request.fc_param
        if not UtilClient.is_unset(request.mns_param):
            body['mnsParam'] = request.mns_param
        if not UtilClient.is_unset(request.pager_duty_param):
            body['pagerDutyParam'] = request.pager_duty_param
        if not UtilClient.is_unset(request.sls_param):
            body['slsParam'] = request.sls_param
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        if not UtilClient.is_unset(request.type):
            body['type'] = request.type
        if not UtilClient.is_unset(request.webhook_param):
            body['webhookParam'] = request.webhook_param
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateAlertAction',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertAction/{OpenApiUtilClient.get_encode_param(alert_action_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertActionResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertActionResponse(),
                self.execute(params, req, runtime)
            )

    async def update_alert_action_with_options_async(
        self,
        alert_action_id: str,
        request: cms_20240330_models.UpdateAlertActionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAlertActionResponse:
        """
        @summary 修改告警动作
        
        @param request: UpdateAlertActionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAlertActionResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_action_name):
            body['alertActionName'] = request.alert_action_name
        if not UtilClient.is_unset(request.ess_param):
            body['essParam'] = request.ess_param
        if not UtilClient.is_unset(request.fc_param):
            body['fcParam'] = request.fc_param
        if not UtilClient.is_unset(request.mns_param):
            body['mnsParam'] = request.mns_param
        if not UtilClient.is_unset(request.pager_duty_param):
            body['pagerDutyParam'] = request.pager_duty_param
        if not UtilClient.is_unset(request.sls_param):
            body['slsParam'] = request.sls_param
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        if not UtilClient.is_unset(request.type):
            body['type'] = request.type
        if not UtilClient.is_unset(request.webhook_param):
            body['webhookParam'] = request.webhook_param
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateAlertAction',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertAction/{OpenApiUtilClient.get_encode_param(alert_action_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertActionResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertActionResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_alert_action(
        self,
        alert_action_id: str,
        request: cms_20240330_models.UpdateAlertActionRequest,
    ) -> cms_20240330_models.UpdateAlertActionResponse:
        """
        @summary 修改告警动作
        
        @param request: UpdateAlertActionRequest
        @return: UpdateAlertActionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_alert_action_with_options(alert_action_id, request, headers, runtime)

    async def update_alert_action_async(
        self,
        alert_action_id: str,
        request: cms_20240330_models.UpdateAlertActionRequest,
    ) -> cms_20240330_models.UpdateAlertActionResponse:
        """
        @summary 修改告警动作
        
        @param request: UpdateAlertActionRequest
        @return: UpdateAlertActionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_alert_action_with_options_async(alert_action_id, request, headers, runtime)

    def update_alert_event_integration_policy_with_options(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.UpdateAlertEventIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAlertEventIntegrationPolicyResponse:
        """
        @summary 更新集成
        
        @param request: UpdateAlertEventIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAlertEventIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='UpdateAlertEventIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertEventIntegrationPolicies/{OpenApiUtilClient.get_encode_param(alert_event_integration_policy_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertEventIntegrationPolicyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertEventIntegrationPolicyResponse(),
                self.execute(params, req, runtime)
            )

    async def update_alert_event_integration_policy_with_options_async(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.UpdateAlertEventIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAlertEventIntegrationPolicyResponse:
        """
        @summary 更新集成
        
        @param request: UpdateAlertEventIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAlertEventIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='UpdateAlertEventIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertEventIntegrationPolicies/{OpenApiUtilClient.get_encode_param(alert_event_integration_policy_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertEventIntegrationPolicyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertEventIntegrationPolicyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_alert_event_integration_policy(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.UpdateAlertEventIntegrationPolicyRequest,
    ) -> cms_20240330_models.UpdateAlertEventIntegrationPolicyResponse:
        """
        @summary 更新集成
        
        @param request: UpdateAlertEventIntegrationPolicyRequest
        @return: UpdateAlertEventIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_alert_event_integration_policy_with_options(alert_event_integration_policy_id, request, headers, runtime)

    async def update_alert_event_integration_policy_async(
        self,
        alert_event_integration_policy_id: str,
        request: cms_20240330_models.UpdateAlertEventIntegrationPolicyRequest,
    ) -> cms_20240330_models.UpdateAlertEventIntegrationPolicyResponse:
        """
        @summary 更新集成
        
        @param request: UpdateAlertEventIntegrationPolicyRequest
        @return: UpdateAlertEventIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_alert_event_integration_policy_with_options_async(alert_event_integration_policy_id, request, headers, runtime)

    def update_alert_notify_template_with_options(
        self,
        alert_notify_template_id: str,
        request: cms_20240330_models.UpdateAlertNotifyTemplateRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAlertNotifyTemplateResponse:
        """
        @summary 更新通知模板
        
        @param request: UpdateAlertNotifyTemplateRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAlertNotifyTemplateResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_notify_template_name):
            body['alertNotifyTemplateName'] = request.alert_notify_template_name
        if not UtilClient.is_unset(request.templates):
            body['templates'] = request.templates
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateAlertNotifyTemplate',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertNotifyTemplate/{OpenApiUtilClient.get_encode_param(alert_notify_template_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertNotifyTemplateResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertNotifyTemplateResponse(),
                self.execute(params, req, runtime)
            )

    async def update_alert_notify_template_with_options_async(
        self,
        alert_notify_template_id: str,
        request: cms_20240330_models.UpdateAlertNotifyTemplateRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAlertNotifyTemplateResponse:
        """
        @summary 更新通知模板
        
        @param request: UpdateAlertNotifyTemplateRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAlertNotifyTemplateResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_notify_template_name):
            body['alertNotifyTemplateName'] = request.alert_notify_template_name
        if not UtilClient.is_unset(request.templates):
            body['templates'] = request.templates
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateAlertNotifyTemplate',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertNotifyTemplate/{OpenApiUtilClient.get_encode_param(alert_notify_template_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertNotifyTemplateResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertNotifyTemplateResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_alert_notify_template(
        self,
        alert_notify_template_id: str,
        request: cms_20240330_models.UpdateAlertNotifyTemplateRequest,
    ) -> cms_20240330_models.UpdateAlertNotifyTemplateResponse:
        """
        @summary 更新通知模板
        
        @param request: UpdateAlertNotifyTemplateRequest
        @return: UpdateAlertNotifyTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_alert_notify_template_with_options(alert_notify_template_id, request, headers, runtime)

    async def update_alert_notify_template_async(
        self,
        alert_notify_template_id: str,
        request: cms_20240330_models.UpdateAlertNotifyTemplateRequest,
    ) -> cms_20240330_models.UpdateAlertNotifyTemplateResponse:
        """
        @summary 更新通知模板
        
        @param request: UpdateAlertNotifyTemplateRequest
        @return: UpdateAlertNotifyTemplateResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_alert_notify_template_with_options_async(alert_notify_template_id, request, headers, runtime)

    def update_alert_robot_with_options(
        self,
        robot_id: str,
        request: cms_20240330_models.UpdateAlertRobotRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAlertRobotResponse:
        """
        @summary 更新机器人
        
        @param request: UpdateAlertRobotRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAlertRobotResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.is_custom):
            body['isCustom'] = request.is_custom
        if not UtilClient.is_unset(request.lang):
            body['lang'] = request.lang
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        if not UtilClient.is_unset(request.type):
            body['type'] = request.type
        if not UtilClient.is_unset(request.url):
            body['url'] = request.url
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateAlertRobot',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/robot/{OpenApiUtilClient.get_encode_param(robot_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertRobotResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertRobotResponse(),
                self.execute(params, req, runtime)
            )

    async def update_alert_robot_with_options_async(
        self,
        robot_id: str,
        request: cms_20240330_models.UpdateAlertRobotRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAlertRobotResponse:
        """
        @summary 更新机器人
        
        @param request: UpdateAlertRobotRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAlertRobotResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.is_custom):
            body['isCustom'] = request.is_custom
        if not UtilClient.is_unset(request.lang):
            body['lang'] = request.lang
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        if not UtilClient.is_unset(request.type):
            body['type'] = request.type
        if not UtilClient.is_unset(request.url):
            body['url'] = request.url
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateAlertRobot',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/robot/{OpenApiUtilClient.get_encode_param(robot_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertRobotResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertRobotResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_alert_robot(
        self,
        robot_id: str,
        request: cms_20240330_models.UpdateAlertRobotRequest,
    ) -> cms_20240330_models.UpdateAlertRobotResponse:
        """
        @summary 更新机器人
        
        @param request: UpdateAlertRobotRequest
        @return: UpdateAlertRobotResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_alert_robot_with_options(robot_id, request, headers, runtime)

    async def update_alert_robot_async(
        self,
        robot_id: str,
        request: cms_20240330_models.UpdateAlertRobotRequest,
    ) -> cms_20240330_models.UpdateAlertRobotResponse:
        """
        @summary 更新机器人
        
        @param request: UpdateAlertRobotRequest
        @return: UpdateAlertRobotResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_alert_robot_with_options_async(robot_id, request, headers, runtime)

    def update_alert_rule_with_options(
        self,
        alert_rule_id: str,
        request: cms_20240330_models.UpdateAlertRuleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAlertRuleResponse:
        """
        @summary 完整更新云监控2.0告警规则
        
        @param request: UpdateAlertRuleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAlertRuleResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_metric_input):
            body['alertMetricInput'] = request.alert_metric_input
        if not UtilClient.is_unset(request.annotations):
            body['annotations'] = request.annotations
        if not UtilClient.is_unset(request.condition):
            body['condition'] = request.condition
        if not UtilClient.is_unset(request.display_name):
            body['displayName'] = request.display_name
        if not UtilClient.is_unset(request.effect_time):
            body['effectTime'] = request.effect_time
        if not UtilClient.is_unset(request.interval):
            body['interval'] = request.interval
        if not UtilClient.is_unset(request.labels):
            body['labels'] = request.labels
        if not UtilClient.is_unset(request.level):
            body['level'] = request.level
        if not UtilClient.is_unset(request.message):
            body['message'] = request.message
        if not UtilClient.is_unset(request.query):
            body['query'] = request.query
        if not UtilClient.is_unset(request.send):
            body['send'] = request.send
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateAlertRule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules/{OpenApiUtilClient.get_encode_param(alert_rule_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertRuleResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertRuleResponse(),
                self.execute(params, req, runtime)
            )

    async def update_alert_rule_with_options_async(
        self,
        alert_rule_id: str,
        request: cms_20240330_models.UpdateAlertRuleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAlertRuleResponse:
        """
        @summary 完整更新云监控2.0告警规则
        
        @param request: UpdateAlertRuleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAlertRuleResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.alert_metric_input):
            body['alertMetricInput'] = request.alert_metric_input
        if not UtilClient.is_unset(request.annotations):
            body['annotations'] = request.annotations
        if not UtilClient.is_unset(request.condition):
            body['condition'] = request.condition
        if not UtilClient.is_unset(request.display_name):
            body['displayName'] = request.display_name
        if not UtilClient.is_unset(request.effect_time):
            body['effectTime'] = request.effect_time
        if not UtilClient.is_unset(request.interval):
            body['interval'] = request.interval
        if not UtilClient.is_unset(request.labels):
            body['labels'] = request.labels
        if not UtilClient.is_unset(request.level):
            body['level'] = request.level
        if not UtilClient.is_unset(request.message):
            body['message'] = request.message
        if not UtilClient.is_unset(request.query):
            body['query'] = request.query
        if not UtilClient.is_unset(request.send):
            body['send'] = request.send
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateAlertRule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/alertRules/{OpenApiUtilClient.get_encode_param(alert_rule_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertRuleResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertRuleResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_alert_rule(
        self,
        alert_rule_id: str,
        request: cms_20240330_models.UpdateAlertRuleRequest,
    ) -> cms_20240330_models.UpdateAlertRuleResponse:
        """
        @summary 完整更新云监控2.0告警规则
        
        @param request: UpdateAlertRuleRequest
        @return: UpdateAlertRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_alert_rule_with_options(alert_rule_id, request, headers, runtime)

    async def update_alert_rule_async(
        self,
        alert_rule_id: str,
        request: cms_20240330_models.UpdateAlertRuleRequest,
    ) -> cms_20240330_models.UpdateAlertRuleResponse:
        """
        @summary 完整更新云监控2.0告警规则
        
        @param request: UpdateAlertRuleRequest
        @return: UpdateAlertRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_alert_rule_with_options_async(alert_rule_id, request, headers, runtime)

    def update_alert_webhook_with_options(
        self,
        webhook_id: str,
        request: cms_20240330_models.UpdateAlertWebhookRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAlertWebhookResponse:
        """
        @summary 更新Webhook
        
        @param request: UpdateAlertWebhookRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAlertWebhookResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.content_type):
            body['contentType'] = request.content_type
        if not UtilClient.is_unset(request.headers):
            body['headers'] = request.headers
        if not UtilClient.is_unset(request.is_custom):
            body['isCustom'] = request.is_custom
        if not UtilClient.is_unset(request.lang):
            body['lang'] = request.lang
        if not UtilClient.is_unset(request.method):
            body['method'] = request.method
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        if not UtilClient.is_unset(request.url):
            body['url'] = request.url
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateAlertWebhook',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/webhook/{OpenApiUtilClient.get_encode_param(webhook_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertWebhookResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertWebhookResponse(),
                self.execute(params, req, runtime)
            )

    async def update_alert_webhook_with_options_async(
        self,
        webhook_id: str,
        request: cms_20240330_models.UpdateAlertWebhookRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateAlertWebhookResponse:
        """
        @summary 更新Webhook
        
        @param request: UpdateAlertWebhookRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateAlertWebhookResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.content_type):
            body['contentType'] = request.content_type
        if not UtilClient.is_unset(request.headers):
            body['headers'] = request.headers
        if not UtilClient.is_unset(request.is_custom):
            body['isCustom'] = request.is_custom
        if not UtilClient.is_unset(request.lang):
            body['lang'] = request.lang
        if not UtilClient.is_unset(request.method):
            body['method'] = request.method
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        if not UtilClient.is_unset(request.url):
            body['url'] = request.url
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateAlertWebhook',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/webhook/{OpenApiUtilClient.get_encode_param(webhook_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertWebhookResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateAlertWebhookResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_alert_webhook(
        self,
        webhook_id: str,
        request: cms_20240330_models.UpdateAlertWebhookRequest,
    ) -> cms_20240330_models.UpdateAlertWebhookResponse:
        """
        @summary 更新Webhook
        
        @param request: UpdateAlertWebhookRequest
        @return: UpdateAlertWebhookResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_alert_webhook_with_options(webhook_id, request, headers, runtime)

    async def update_alert_webhook_async(
        self,
        webhook_id: str,
        request: cms_20240330_models.UpdateAlertWebhookRequest,
    ) -> cms_20240330_models.UpdateAlertWebhookResponse:
        """
        @summary 更新Webhook
        
        @param request: UpdateAlertWebhookRequest
        @return: UpdateAlertWebhookResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_alert_webhook_with_options_async(webhook_id, request, headers, runtime)

    def update_biz_trace_with_options(
        self,
        biz_trace_id: str,
        request: cms_20240330_models.UpdateBizTraceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateBizTraceResponse:
        """
        @summary 修改业务链路
        
        @param request: UpdateBizTraceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateBizTraceResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.advanced_config):
            body['advancedConfig'] = request.advanced_config
        if not UtilClient.is_unset(request.biz_trace_name):
            body['bizTraceName'] = request.biz_trace_name
        if not UtilClient.is_unset(request.rule_config):
            body['ruleConfig'] = request.rule_config
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateBizTrace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/bizTrace/{OpenApiUtilClient.get_encode_param(biz_trace_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateBizTraceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateBizTraceResponse(),
                self.execute(params, req, runtime)
            )

    async def update_biz_trace_with_options_async(
        self,
        biz_trace_id: str,
        request: cms_20240330_models.UpdateBizTraceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateBizTraceResponse:
        """
        @summary 修改业务链路
        
        @param request: UpdateBizTraceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateBizTraceResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.advanced_config):
            body['advancedConfig'] = request.advanced_config
        if not UtilClient.is_unset(request.biz_trace_name):
            body['bizTraceName'] = request.biz_trace_name
        if not UtilClient.is_unset(request.rule_config):
            body['ruleConfig'] = request.rule_config
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateBizTrace',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/bizTrace/{OpenApiUtilClient.get_encode_param(biz_trace_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateBizTraceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateBizTraceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_biz_trace(
        self,
        biz_trace_id: str,
        request: cms_20240330_models.UpdateBizTraceRequest,
    ) -> cms_20240330_models.UpdateBizTraceResponse:
        """
        @summary 修改业务链路
        
        @param request: UpdateBizTraceRequest
        @return: UpdateBizTraceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_biz_trace_with_options(biz_trace_id, request, headers, runtime)

    async def update_biz_trace_async(
        self,
        biz_trace_id: str,
        request: cms_20240330_models.UpdateBizTraceRequest,
    ) -> cms_20240330_models.UpdateBizTraceResponse:
        """
        @summary 修改业务链路
        
        @param request: UpdateBizTraceRequest
        @return: UpdateBizTraceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_biz_trace_with_options_async(biz_trace_id, request, headers, runtime)

    def update_contact_with_options(
        self,
        contact_id: str,
        request: cms_20240330_models.UpdateContactRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateContactResponse:
        """
        @summary 更新联系人
        
        @param request: UpdateContactRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateContactResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.email):
            body['email'] = request.email
        if not UtilClient.is_unset(request.im_user_ids):
            body['imUserIds'] = request.im_user_ids
        if not UtilClient.is_unset(request.is_inner_call):
            body['isInnerCall'] = request.is_inner_call
        if not UtilClient.is_unset(request.lang):
            body['lang'] = request.lang
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.phone):
            body['phone'] = request.phone
        if not UtilClient.is_unset(request.phone_code):
            body['phoneCode'] = request.phone_code
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateContact',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contact/{OpenApiUtilClient.get_encode_param(contact_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateContactResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateContactResponse(),
                self.execute(params, req, runtime)
            )

    async def update_contact_with_options_async(
        self,
        contact_id: str,
        request: cms_20240330_models.UpdateContactRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateContactResponse:
        """
        @summary 更新联系人
        
        @param request: UpdateContactRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateContactResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.email):
            body['email'] = request.email
        if not UtilClient.is_unset(request.im_user_ids):
            body['imUserIds'] = request.im_user_ids
        if not UtilClient.is_unset(request.is_inner_call):
            body['isInnerCall'] = request.is_inner_call
        if not UtilClient.is_unset(request.lang):
            body['lang'] = request.lang
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.phone):
            body['phone'] = request.phone
        if not UtilClient.is_unset(request.phone_code):
            body['phoneCode'] = request.phone_code
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateContact',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contact/{OpenApiUtilClient.get_encode_param(contact_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateContactResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateContactResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_contact(
        self,
        contact_id: str,
        request: cms_20240330_models.UpdateContactRequest,
    ) -> cms_20240330_models.UpdateContactResponse:
        """
        @summary 更新联系人
        
        @param request: UpdateContactRequest
        @return: UpdateContactResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_contact_with_options(contact_id, request, headers, runtime)

    async def update_contact_async(
        self,
        contact_id: str,
        request: cms_20240330_models.UpdateContactRequest,
    ) -> cms_20240330_models.UpdateContactResponse:
        """
        @summary 更新联系人
        
        @param request: UpdateContactRequest
        @return: UpdateContactResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_contact_with_options_async(contact_id, request, headers, runtime)

    def update_contact_group_with_options(
        self,
        contact_group_id: str,
        request: cms_20240330_models.UpdateContactGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateContactGroupResponse:
        """
        @summary 更新联系人组
        
        @param request: UpdateContactGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateContactGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.contacts):
            body['contacts'] = request.contacts
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateContactGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contactGroup/{OpenApiUtilClient.get_encode_param(contact_group_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateContactGroupResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateContactGroupResponse(),
                self.execute(params, req, runtime)
            )

    async def update_contact_group_with_options_async(
        self,
        contact_group_id: str,
        request: cms_20240330_models.UpdateContactGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateContactGroupResponse:
        """
        @summary 更新联系人组
        
        @param request: UpdateContactGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateContactGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.contacts):
            body['contacts'] = request.contacts
        if not UtilClient.is_unset(request.name):
            body['name'] = request.name
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateContactGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/contactGroup/{OpenApiUtilClient.get_encode_param(contact_group_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateContactGroupResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateContactGroupResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_contact_group(
        self,
        contact_group_id: str,
        request: cms_20240330_models.UpdateContactGroupRequest,
    ) -> cms_20240330_models.UpdateContactGroupResponse:
        """
        @summary 更新联系人组
        
        @param request: UpdateContactGroupRequest
        @return: UpdateContactGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_contact_group_with_options(contact_group_id, request, headers, runtime)

    async def update_contact_group_async(
        self,
        contact_group_id: str,
        request: cms_20240330_models.UpdateContactGroupRequest,
    ) -> cms_20240330_models.UpdateContactGroupResponse:
        """
        @summary 更新联系人组
        
        @param request: UpdateContactGroupRequest
        @return: UpdateContactGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_contact_group_with_options_async(contact_group_id, request, headers, runtime)

    def update_entity_group_with_options(
        self,
        entity_group_id: str,
        request: cms_20240330_models.UpdateEntityGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateEntityGroupResponse:
        """
        @summary 更新实体组
        
        @param request: UpdateEntityGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateEntityGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.description):
            body['description'] = request.description
        if not UtilClient.is_unset(request.entity_group_name):
            body['entityGroupName'] = request.entity_group_name
        if not UtilClient.is_unset(request.entity_rules):
            body['entityRules'] = request.entity_rules
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateEntityGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/entity-groups/{OpenApiUtilClient.get_encode_param(entity_group_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateEntityGroupResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateEntityGroupResponse(),
                self.execute(params, req, runtime)
            )

    async def update_entity_group_with_options_async(
        self,
        entity_group_id: str,
        request: cms_20240330_models.UpdateEntityGroupRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateEntityGroupResponse:
        """
        @summary 更新实体组
        
        @param request: UpdateEntityGroupRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateEntityGroupResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.description):
            body['description'] = request.description
        if not UtilClient.is_unset(request.entity_group_name):
            body['entityGroupName'] = request.entity_group_name
        if not UtilClient.is_unset(request.entity_rules):
            body['entityRules'] = request.entity_rules
        if not UtilClient.is_unset(request.workspace):
            body['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateEntityGroup',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/entity-groups/{OpenApiUtilClient.get_encode_param(entity_group_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateEntityGroupResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateEntityGroupResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_entity_group(
        self,
        entity_group_id: str,
        request: cms_20240330_models.UpdateEntityGroupRequest,
    ) -> cms_20240330_models.UpdateEntityGroupResponse:
        """
        @summary 更新实体组
        
        @param request: UpdateEntityGroupRequest
        @return: UpdateEntityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_entity_group_with_options(entity_group_id, request, headers, runtime)

    async def update_entity_group_async(
        self,
        entity_group_id: str,
        request: cms_20240330_models.UpdateEntityGroupRequest,
    ) -> cms_20240330_models.UpdateEntityGroupResponse:
        """
        @summary 更新实体组
        
        @param request: UpdateEntityGroupRequest
        @return: UpdateEntityGroupResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_entity_group_with_options_async(entity_group_id, request, headers, runtime)

    def update_env_drop_metrics_rule_with_options(
        self,
        request: cms_20240330_models.UpdateEnvDropMetricsRuleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateEnvDropMetricsRuleResponse:
        """
        @summary 更新环境实例的废弃指标列表
        
        @param request: UpdateEnvDropMetricsRuleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateEnvDropMetricsRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['AliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        body = {}
        if not UtilClient.is_unset(request.drop_metrics):
            body['DropMetrics'] = request.drop_metrics
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateEnvDropMetricsRule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/UpdateEnvDropMetricsRule',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='formData',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateEnvDropMetricsRuleResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateEnvDropMetricsRuleResponse(),
                self.execute(params, req, runtime)
            )

    async def update_env_drop_metrics_rule_with_options_async(
        self,
        request: cms_20240330_models.UpdateEnvDropMetricsRuleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateEnvDropMetricsRuleResponse:
        """
        @summary 更新环境实例的废弃指标列表
        
        @param request: UpdateEnvDropMetricsRuleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateEnvDropMetricsRuleResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            query['AliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.environment_id):
            query['EnvironmentId'] = request.environment_id
        if not UtilClient.is_unset(request.region_id):
            query['RegionId'] = request.region_id
        body = {}
        if not UtilClient.is_unset(request.drop_metrics):
            body['DropMetrics'] = request.drop_metrics
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateEnvDropMetricsRule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus/env/UpdateEnvDropMetricsRule',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='formData',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateEnvDropMetricsRuleResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateEnvDropMetricsRuleResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_env_drop_metrics_rule(
        self,
        request: cms_20240330_models.UpdateEnvDropMetricsRuleRequest,
    ) -> cms_20240330_models.UpdateEnvDropMetricsRuleResponse:
        """
        @summary 更新环境实例的废弃指标列表
        
        @param request: UpdateEnvDropMetricsRuleRequest
        @return: UpdateEnvDropMetricsRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_env_drop_metrics_rule_with_options(request, headers, runtime)

    async def update_env_drop_metrics_rule_async(
        self,
        request: cms_20240330_models.UpdateEnvDropMetricsRuleRequest,
    ) -> cms_20240330_models.UpdateEnvDropMetricsRuleResponse:
        """
        @summary 更新环境实例的废弃指标列表
        
        @param request: UpdateEnvDropMetricsRuleRequest
        @return: UpdateEnvDropMetricsRuleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_env_drop_metrics_rule_with_options_async(request, headers, runtime)

    def update_escalation_with_options(
        self,
        uuid: str,
        request: cms_20240330_models.UpdateEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateEscalationResponse:
        """
        @summary 更新通知配置
        
        @param request: UpdateEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='UpdateEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/escalations/{OpenApiUtilClient.get_encode_param(uuid)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateEscalationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateEscalationResponse(),
                self.execute(params, req, runtime)
            )

    async def update_escalation_with_options_async(
        self,
        uuid: str,
        request: cms_20240330_models.UpdateEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateEscalationResponse:
        """
        @summary 更新通知配置
        
        @param request: UpdateEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='UpdateEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/escalations/{OpenApiUtilClient.get_encode_param(uuid)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateEscalationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateEscalationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_escalation(
        self,
        uuid: str,
        request: cms_20240330_models.UpdateEscalationRequest,
    ) -> cms_20240330_models.UpdateEscalationResponse:
        """
        @summary 更新通知配置
        
        @param request: UpdateEscalationRequest
        @return: UpdateEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_escalation_with_options(uuid, request, headers, runtime)

    async def update_escalation_async(
        self,
        uuid: str,
        request: cms_20240330_models.UpdateEscalationRequest,
    ) -> cms_20240330_models.UpdateEscalationResponse:
        """
        @summary 更新通知配置
        
        @param request: UpdateEscalationRequest
        @return: UpdateEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_escalation_with_options_async(uuid, request, headers, runtime)

    def update_incident_escalation_with_options(
        self,
        request: cms_20240330_models.UpdateIncidentEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateIncidentEscalationResponse:
        """
        @summary 创建Incident升级计划
        
        @param request: UpdateIncidentEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateIncidentEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['description'] = request.description
        if not UtilClient.is_unset(request.incident_escalation_id):
            query['incidentEscalationId'] = request.incident_escalation_id
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.stage):
            query['stage'] = request.stage
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateIncidentEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/escalation/update',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateIncidentEscalationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateIncidentEscalationResponse(),
                self.execute(params, req, runtime)
            )

    async def update_incident_escalation_with_options_async(
        self,
        request: cms_20240330_models.UpdateIncidentEscalationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateIncidentEscalationResponse:
        """
        @summary 创建Incident升级计划
        
        @param request: UpdateIncidentEscalationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateIncidentEscalationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.description):
            query['description'] = request.description
        if not UtilClient.is_unset(request.incident_escalation_id):
            query['incidentEscalationId'] = request.incident_escalation_id
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.stage):
            query['stage'] = request.stage
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateIncidentEscalation',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/escalation/update',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateIncidentEscalationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateIncidentEscalationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_incident_escalation(
        self,
        request: cms_20240330_models.UpdateIncidentEscalationRequest,
    ) -> cms_20240330_models.UpdateIncidentEscalationResponse:
        """
        @summary 创建Incident升级计划
        
        @param request: UpdateIncidentEscalationRequest
        @return: UpdateIncidentEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_incident_escalation_with_options(request, headers, runtime)

    async def update_incident_escalation_async(
        self,
        request: cms_20240330_models.UpdateIncidentEscalationRequest,
    ) -> cms_20240330_models.UpdateIncidentEscalationResponse:
        """
        @summary 创建Incident升级计划
        
        @param request: UpdateIncidentEscalationRequest
        @return: UpdateIncidentEscalationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_incident_escalation_with_options_async(request, headers, runtime)

    def update_incident_plan_with_options(
        self,
        request: cms_20240330_models.UpdateIncidentPlanRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateIncidentPlanResponse:
        """
        @summary 更新Incident计划
        
        @param request: UpdateIncidentPlanRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateIncidentPlanResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_recover_seconds):
            query['autoRecoverSeconds'] = request.auto_recover_seconds
        if not UtilClient.is_unset(request.corporation):
            query['corporation'] = request.corporation
        if not UtilClient.is_unset(request.description):
            query['description'] = request.description
        if not UtilClient.is_unset(request.escalation_id):
            query['escalationId'] = request.escalation_id
        if not UtilClient.is_unset(request.group_by):
            query['groupBy'] = request.group_by
        if not UtilClient.is_unset(request.incident_plan_id):
            query['incidentPlanId'] = request.incident_plan_id
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.pause_expire):
            query['pauseExpire'] = request.pause_expire
        if not UtilClient.is_unset(request.resource_field):
            query['resourceField'] = request.resource_field
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateIncidentPlan',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/plan/update',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateIncidentPlanResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateIncidentPlanResponse(),
                self.execute(params, req, runtime)
            )

    async def update_incident_plan_with_options_async(
        self,
        request: cms_20240330_models.UpdateIncidentPlanRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateIncidentPlanResponse:
        """
        @summary 更新Incident计划
        
        @param request: UpdateIncidentPlanRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateIncidentPlanResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.auto_recover_seconds):
            query['autoRecoverSeconds'] = request.auto_recover_seconds
        if not UtilClient.is_unset(request.corporation):
            query['corporation'] = request.corporation
        if not UtilClient.is_unset(request.description):
            query['description'] = request.description
        if not UtilClient.is_unset(request.escalation_id):
            query['escalationId'] = request.escalation_id
        if not UtilClient.is_unset(request.group_by):
            query['groupBy'] = request.group_by
        if not UtilClient.is_unset(request.incident_plan_id):
            query['incidentPlanId'] = request.incident_plan_id
        if not UtilClient.is_unset(request.name):
            query['name'] = request.name
        if not UtilClient.is_unset(request.pause_expire):
            query['pauseExpire'] = request.pause_expire
        if not UtilClient.is_unset(request.resource_field):
            query['resourceField'] = request.resource_field
        if not UtilClient.is_unset(request.status):
            query['status'] = request.status
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateIncidentPlan',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/incident/plan/update',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateIncidentPlanResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateIncidentPlanResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_incident_plan(
        self,
        request: cms_20240330_models.UpdateIncidentPlanRequest,
    ) -> cms_20240330_models.UpdateIncidentPlanResponse:
        """
        @summary 更新Incident计划
        
        @param request: UpdateIncidentPlanRequest
        @return: UpdateIncidentPlanResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_incident_plan_with_options(request, headers, runtime)

    async def update_incident_plan_async(
        self,
        request: cms_20240330_models.UpdateIncidentPlanRequest,
    ) -> cms_20240330_models.UpdateIncidentPlanResponse:
        """
        @summary 更新Incident计划
        
        @param request: UpdateIncidentPlanRequest
        @return: UpdateIncidentPlanResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_incident_plan_with_options_async(request, headers, runtime)

    def update_integration_with_options(
        self,
        integration_id: str,
        request: cms_20240330_models.UpdateIntegrationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateIntegrationResponse:
        """
        @summary 更新集成
        
        @param request: UpdateIntegrationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateIntegrationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='UpdateIntegration',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integrations/{OpenApiUtilClient.get_encode_param(integration_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateIntegrationResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateIntegrationResponse(),
                self.execute(params, req, runtime)
            )

    async def update_integration_with_options_async(
        self,
        integration_id: str,
        request: cms_20240330_models.UpdateIntegrationRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateIntegrationResponse:
        """
        @summary 更新集成
        
        @param request: UpdateIntegrationRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateIntegrationResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='UpdateIntegration',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integrations/{OpenApiUtilClient.get_encode_param(integration_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateIntegrationResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateIntegrationResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_integration(
        self,
        integration_id: str,
        request: cms_20240330_models.UpdateIntegrationRequest,
    ) -> cms_20240330_models.UpdateIntegrationResponse:
        """
        @summary 更新集成
        
        @param request: UpdateIntegrationRequest
        @return: UpdateIntegrationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_integration_with_options(integration_id, request, headers, runtime)

    async def update_integration_async(
        self,
        integration_id: str,
        request: cms_20240330_models.UpdateIntegrationRequest,
    ) -> cms_20240330_models.UpdateIntegrationResponse:
        """
        @summary 更新集成
        
        @param request: UpdateIntegrationRequest
        @return: UpdateIntegrationResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_integration_with_options_async(integration_id, request, headers, runtime)

    def update_integration_policy_with_options(
        self,
        integration_policy_id: str,
        request: cms_20240330_models.UpdateIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateIntegrationPolicyResponse:
        """
        @summary 更新指定策略
        
        @param request: UpdateIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.fee_package):
            body['feePackage'] = request.fee_package
        if not UtilClient.is_unset(request.policy_name):
            body['policyName'] = request.policy_name
        if not UtilClient.is_unset(request.resource_group_id):
            body['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.tags):
            body['tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(integration_policy_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateIntegrationPolicyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateIntegrationPolicyResponse(),
                self.execute(params, req, runtime)
            )

    async def update_integration_policy_with_options_async(
        self,
        integration_policy_id: str,
        request: cms_20240330_models.UpdateIntegrationPolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateIntegrationPolicyResponse:
        """
        @summary 更新指定策略
        
        @param request: UpdateIntegrationPolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateIntegrationPolicyResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.fee_package):
            body['feePackage'] = request.fee_package
        if not UtilClient.is_unset(request.policy_name):
            body['policyName'] = request.policy_name
        if not UtilClient.is_unset(request.resource_group_id):
            body['resourceGroupId'] = request.resource_group_id
        if not UtilClient.is_unset(request.tags):
            body['tags'] = request.tags
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateIntegrationPolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/integration-policies/{OpenApiUtilClient.get_encode_param(integration_policy_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateIntegrationPolicyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateIntegrationPolicyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_integration_policy(
        self,
        integration_policy_id: str,
        request: cms_20240330_models.UpdateIntegrationPolicyRequest,
    ) -> cms_20240330_models.UpdateIntegrationPolicyResponse:
        """
        @summary 更新指定策略
        
        @param request: UpdateIntegrationPolicyRequest
        @return: UpdateIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_integration_policy_with_options(integration_policy_id, request, headers, runtime)

    async def update_integration_policy_async(
        self,
        integration_policy_id: str,
        request: cms_20240330_models.UpdateIntegrationPolicyRequest,
    ) -> cms_20240330_models.UpdateIntegrationPolicyResponse:
        """
        @summary 更新指定策略
        
        @param request: UpdateIntegrationPolicyRequest
        @return: UpdateIntegrationPolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_integration_policy_with_options_async(integration_policy_id, request, headers, runtime)

    def update_maintain_window_with_options(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.UpdateMaintainWindowRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateMaintainWindowResponse:
        """
        @summary 更新转化器
        
        @param request: UpdateMaintainWindowRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateMaintainWindowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='UpdateMaintainWindow',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/maintainWindows/{OpenApiUtilClient.get_encode_param(maintain_window_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateMaintainWindowResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateMaintainWindowResponse(),
                self.execute(params, req, runtime)
            )

    async def update_maintain_window_with_options_async(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.UpdateMaintainWindowRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateMaintainWindowResponse:
        """
        @summary 更新转化器
        
        @param request: UpdateMaintainWindowRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateMaintainWindowResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='UpdateMaintainWindow',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/maintainWindows/{OpenApiUtilClient.get_encode_param(maintain_window_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateMaintainWindowResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateMaintainWindowResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_maintain_window(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.UpdateMaintainWindowRequest,
    ) -> cms_20240330_models.UpdateMaintainWindowResponse:
        """
        @summary 更新转化器
        
        @param request: UpdateMaintainWindowRequest
        @return: UpdateMaintainWindowResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_maintain_window_with_options(maintain_window_id, request, headers, runtime)

    async def update_maintain_window_async(
        self,
        maintain_window_id: str,
        request: cms_20240330_models.UpdateMaintainWindowRequest,
    ) -> cms_20240330_models.UpdateMaintainWindowResponse:
        """
        @summary 更新转化器
        
        @param request: UpdateMaintainWindowRequest
        @return: UpdateMaintainWindowResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_maintain_window_with_options_async(maintain_window_id, request, headers, runtime)

    def update_notify_strategy_with_options(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.UpdateNotifyStrategyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateNotifyStrategyResponse:
        """
        @summary 更新订阅
        
        @param request: UpdateNotifyStrategyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateNotifyStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='UpdateNotifyStrategy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/notifyStrategies/{OpenApiUtilClient.get_encode_param(notify_strategy_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateNotifyStrategyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateNotifyStrategyResponse(),
                self.execute(params, req, runtime)
            )

    async def update_notify_strategy_with_options_async(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.UpdateNotifyStrategyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateNotifyStrategyResponse:
        """
        @summary 更新订阅
        
        @param request: UpdateNotifyStrategyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateNotifyStrategyResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='UpdateNotifyStrategy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/notifyStrategies/{OpenApiUtilClient.get_encode_param(notify_strategy_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateNotifyStrategyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateNotifyStrategyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_notify_strategy(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.UpdateNotifyStrategyRequest,
    ) -> cms_20240330_models.UpdateNotifyStrategyResponse:
        """
        @summary 更新订阅
        
        @param request: UpdateNotifyStrategyRequest
        @return: UpdateNotifyStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_notify_strategy_with_options(notify_strategy_id, request, headers, runtime)

    async def update_notify_strategy_async(
        self,
        notify_strategy_id: str,
        request: cms_20240330_models.UpdateNotifyStrategyRequest,
    ) -> cms_20240330_models.UpdateNotifyStrategyResponse:
        """
        @summary 更新订阅
        
        @param request: UpdateNotifyStrategyRequest
        @return: UpdateNotifyStrategyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_notify_strategy_with_options_async(notify_strategy_id, request, headers, runtime)

    def update_oncall_schedule_with_options(
        self,
        oncall_schedule_id: str,
        request: cms_20240330_models.UpdateOncallScheduleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateOncallScheduleResponse:
        """
        @summary 更新UpdateOncallSchedule
        
        @param request: UpdateOncallScheduleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateOncallScheduleResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.oncall_schedule_name):
            body['oncallScheduleName'] = request.oncall_schedule_name
        if not UtilClient.is_unset(request.rotations):
            body['rotations'] = request.rotations
        if not UtilClient.is_unset(request.shift_robot_id):
            body['shiftRobotId'] = request.shift_robot_id
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateOncallSchedule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/oncallSchedule/{OpenApiUtilClient.get_encode_param(oncall_schedule_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateOncallScheduleResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateOncallScheduleResponse(),
                self.execute(params, req, runtime)
            )

    async def update_oncall_schedule_with_options_async(
        self,
        oncall_schedule_id: str,
        request: cms_20240330_models.UpdateOncallScheduleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateOncallScheduleResponse:
        """
        @summary 更新UpdateOncallSchedule
        
        @param request: UpdateOncallScheduleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateOncallScheduleResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.oncall_schedule_name):
            body['oncallScheduleName'] = request.oncall_schedule_name
        if not UtilClient.is_unset(request.rotations):
            body['rotations'] = request.rotations
        if not UtilClient.is_unset(request.shift_robot_id):
            body['shiftRobotId'] = request.shift_robot_id
        if not UtilClient.is_unset(request.source):
            body['source'] = request.source
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateOncallSchedule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/oncallSchedule/{OpenApiUtilClient.get_encode_param(oncall_schedule_id)}',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateOncallScheduleResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateOncallScheduleResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_oncall_schedule(
        self,
        oncall_schedule_id: str,
        request: cms_20240330_models.UpdateOncallScheduleRequest,
    ) -> cms_20240330_models.UpdateOncallScheduleResponse:
        """
        @summary 更新UpdateOncallSchedule
        
        @param request: UpdateOncallScheduleRequest
        @return: UpdateOncallScheduleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_oncall_schedule_with_options(oncall_schedule_id, request, headers, runtime)

    async def update_oncall_schedule_async(
        self,
        oncall_schedule_id: str,
        request: cms_20240330_models.UpdateOncallScheduleRequest,
    ) -> cms_20240330_models.UpdateOncallScheduleResponse:
        """
        @summary 更新UpdateOncallSchedule
        
        @param request: UpdateOncallScheduleRequest
        @return: UpdateOncallScheduleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_oncall_schedule_with_options_async(oncall_schedule_id, request, headers, runtime)

    def update_policy_with_options(
        self,
        policy_id: str,
        request: cms_20240330_models.UpdatePolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdatePolicyResponse:
        """
        @summary 更新指定策略
        
        @param request: UpdatePolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdatePolicyResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            body['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.fee_package):
            body['feePackage'] = request.fee_package
        if not UtilClient.is_unset(request.policy_name):
            body['policyName'] = request.policy_name
        if not UtilClient.is_unset(request.region_id):
            body['regionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdatePolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy/{OpenApiUtilClient.get_encode_param(policy_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdatePolicyResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdatePolicyResponse(),
                self.execute(params, req, runtime)
            )

    async def update_policy_with_options_async(
        self,
        policy_id: str,
        request: cms_20240330_models.UpdatePolicyRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdatePolicyResponse:
        """
        @summary 更新指定策略
        
        @param request: UpdatePolicyRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdatePolicyResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.aliyun_lang):
            body['aliyunLang'] = request.aliyun_lang
        if not UtilClient.is_unset(request.fee_package):
            body['feePackage'] = request.fee_package
        if not UtilClient.is_unset(request.policy_name):
            body['policyName'] = request.policy_name
        if not UtilClient.is_unset(request.region_id):
            body['regionId'] = request.region_id
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdatePolicy',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy/{OpenApiUtilClient.get_encode_param(policy_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdatePolicyResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdatePolicyResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_policy(
        self,
        policy_id: str,
        request: cms_20240330_models.UpdatePolicyRequest,
    ) -> cms_20240330_models.UpdatePolicyResponse:
        """
        @summary 更新指定策略
        
        @param request: UpdatePolicyRequest
        @return: UpdatePolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_policy_with_options(policy_id, request, headers, runtime)

    async def update_policy_async(
        self,
        policy_id: str,
        request: cms_20240330_models.UpdatePolicyRequest,
    ) -> cms_20240330_models.UpdatePolicyResponse:
        """
        @summary 更新指定策略
        
        @param request: UpdatePolicyRequest
        @return: UpdatePolicyResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_policy_with_options_async(policy_id, request, headers, runtime)

    def update_prometheus_instance_with_options(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.UpdatePrometheusInstanceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdatePrometheusInstanceResponse:
        """
        @summary 更新Prom实例信息
        
        @param request: UpdatePrometheusInstanceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdatePrometheusInstanceResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.archive_duration):
            body['archiveDuration'] = request.archive_duration
        if not UtilClient.is_unset(request.auth_free_read_policy):
            body['authFreeReadPolicy'] = request.auth_free_read_policy
        if not UtilClient.is_unset(request.auth_free_write_policy):
            body['authFreeWritePolicy'] = request.auth_free_write_policy
        if not UtilClient.is_unset(request.enable_auth_free_read):
            body['enableAuthFreeRead'] = request.enable_auth_free_read
        if not UtilClient.is_unset(request.enable_auth_free_write):
            body['enableAuthFreeWrite'] = request.enable_auth_free_write
        if not UtilClient.is_unset(request.enable_auth_token):
            body['enableAuthToken'] = request.enable_auth_token
        if not UtilClient.is_unset(request.payment_type):
            body['paymentType'] = request.payment_type
        if not UtilClient.is_unset(request.prometheus_instance_name):
            body['prometheusInstanceName'] = request.prometheus_instance_name
        if not UtilClient.is_unset(request.status):
            body['status'] = request.status
        if not UtilClient.is_unset(request.storage_duration):
            body['storageDuration'] = request.storage_duration
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdatePrometheusInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(prometheus_instance_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdatePrometheusInstanceResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdatePrometheusInstanceResponse(),
                self.execute(params, req, runtime)
            )

    async def update_prometheus_instance_with_options_async(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.UpdatePrometheusInstanceRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdatePrometheusInstanceResponse:
        """
        @summary 更新Prom实例信息
        
        @param request: UpdatePrometheusInstanceRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdatePrometheusInstanceResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.archive_duration):
            body['archiveDuration'] = request.archive_duration
        if not UtilClient.is_unset(request.auth_free_read_policy):
            body['authFreeReadPolicy'] = request.auth_free_read_policy
        if not UtilClient.is_unset(request.auth_free_write_policy):
            body['authFreeWritePolicy'] = request.auth_free_write_policy
        if not UtilClient.is_unset(request.enable_auth_free_read):
            body['enableAuthFreeRead'] = request.enable_auth_free_read
        if not UtilClient.is_unset(request.enable_auth_free_write):
            body['enableAuthFreeWrite'] = request.enable_auth_free_write
        if not UtilClient.is_unset(request.enable_auth_token):
            body['enableAuthToken'] = request.enable_auth_token
        if not UtilClient.is_unset(request.payment_type):
            body['paymentType'] = request.payment_type
        if not UtilClient.is_unset(request.prometheus_instance_name):
            body['prometheusInstanceName'] = request.prometheus_instance_name
        if not UtilClient.is_unset(request.status):
            body['status'] = request.status
        if not UtilClient.is_unset(request.storage_duration):
            body['storageDuration'] = request.storage_duration
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdatePrometheusInstance',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-instances/{OpenApiUtilClient.get_encode_param(prometheus_instance_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdatePrometheusInstanceResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdatePrometheusInstanceResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_prometheus_instance(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.UpdatePrometheusInstanceRequest,
    ) -> cms_20240330_models.UpdatePrometheusInstanceResponse:
        """
        @summary 更新Prom实例信息
        
        @param request: UpdatePrometheusInstanceRequest
        @return: UpdatePrometheusInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_prometheus_instance_with_options(prometheus_instance_id, request, headers, runtime)

    async def update_prometheus_instance_async(
        self,
        prometheus_instance_id: str,
        request: cms_20240330_models.UpdatePrometheusInstanceRequest,
    ) -> cms_20240330_models.UpdatePrometheusInstanceResponse:
        """
        @summary 更新Prom实例信息
        
        @param request: UpdatePrometheusInstanceRequest
        @return: UpdatePrometheusInstanceResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_prometheus_instance_with_options_async(prometheus_instance_id, request, headers, runtime)

    def update_prometheus_user_setting_with_options(
        self,
        setting_key: str,
        request: cms_20240330_models.UpdatePrometheusUserSettingRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdatePrometheusUserSettingResponse:
        """
        @summary 更新Prom实例信息
        
        @param request: UpdatePrometheusUserSettingRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdatePrometheusUserSettingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.setting_value):
            query['settingValue'] = request.setting_value
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdatePrometheusUserSetting',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-user-setting/{OpenApiUtilClient.get_encode_param(setting_key)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdatePrometheusUserSettingResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdatePrometheusUserSettingResponse(),
                self.execute(params, req, runtime)
            )

    async def update_prometheus_user_setting_with_options_async(
        self,
        setting_key: str,
        request: cms_20240330_models.UpdatePrometheusUserSettingRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdatePrometheusUserSettingResponse:
        """
        @summary 更新Prom实例信息
        
        @param request: UpdatePrometheusUserSettingRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdatePrometheusUserSettingResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.setting_value):
            query['settingValue'] = request.setting_value
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdatePrometheusUserSetting',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-user-setting/{OpenApiUtilClient.get_encode_param(setting_key)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdatePrometheusUserSettingResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdatePrometheusUserSettingResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_prometheus_user_setting(
        self,
        setting_key: str,
        request: cms_20240330_models.UpdatePrometheusUserSettingRequest,
    ) -> cms_20240330_models.UpdatePrometheusUserSettingResponse:
        """
        @summary 更新Prom实例信息
        
        @param request: UpdatePrometheusUserSettingRequest
        @return: UpdatePrometheusUserSettingResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_prometheus_user_setting_with_options(setting_key, request, headers, runtime)

    async def update_prometheus_user_setting_async(
        self,
        setting_key: str,
        request: cms_20240330_models.UpdatePrometheusUserSettingRequest,
    ) -> cms_20240330_models.UpdatePrometheusUserSettingResponse:
        """
        @summary 更新Prom实例信息
        
        @param request: UpdatePrometheusUserSettingRequest
        @return: UpdatePrometheusUserSettingResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_prometheus_user_setting_with_options_async(setting_key, request, headers, runtime)

    def update_prometheus_view_with_options(
        self,
        prometheus_view_id: str,
        request: cms_20240330_models.UpdatePrometheusViewRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdatePrometheusViewResponse:
        """
        @summary 更新Prom视图实例信息
        
        @param request: UpdatePrometheusViewRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdatePrometheusViewResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.auth_free_read_policy):
            body['authFreeReadPolicy'] = request.auth_free_read_policy
        if not UtilClient.is_unset(request.enable_auth_free_read):
            body['enableAuthFreeRead'] = request.enable_auth_free_read
        if not UtilClient.is_unset(request.enable_auth_token):
            body['enableAuthToken'] = request.enable_auth_token
        if not UtilClient.is_unset(request.prometheus_instances):
            body['prometheusInstances'] = request.prometheus_instances
        if not UtilClient.is_unset(request.prometheus_view_name):
            body['prometheusViewName'] = request.prometheus_view_name
        if not UtilClient.is_unset(request.status):
            body['status'] = request.status
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdatePrometheusView',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-views/{OpenApiUtilClient.get_encode_param(prometheus_view_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdatePrometheusViewResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdatePrometheusViewResponse(),
                self.execute(params, req, runtime)
            )

    async def update_prometheus_view_with_options_async(
        self,
        prometheus_view_id: str,
        request: cms_20240330_models.UpdatePrometheusViewRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdatePrometheusViewResponse:
        """
        @summary 更新Prom视图实例信息
        
        @param request: UpdatePrometheusViewRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdatePrometheusViewResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.auth_free_read_policy):
            body['authFreeReadPolicy'] = request.auth_free_read_policy
        if not UtilClient.is_unset(request.enable_auth_free_read):
            body['enableAuthFreeRead'] = request.enable_auth_free_read
        if not UtilClient.is_unset(request.enable_auth_token):
            body['enableAuthToken'] = request.enable_auth_token
        if not UtilClient.is_unset(request.prometheus_instances):
            body['prometheusInstances'] = request.prometheus_instances
        if not UtilClient.is_unset(request.prometheus_view_name):
            body['prometheusViewName'] = request.prometheus_view_name
        if not UtilClient.is_unset(request.status):
            body['status'] = request.status
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdatePrometheusView',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/prometheus-views/{OpenApiUtilClient.get_encode_param(prometheus_view_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdatePrometheusViewResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdatePrometheusViewResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_prometheus_view(
        self,
        prometheus_view_id: str,
        request: cms_20240330_models.UpdatePrometheusViewRequest,
    ) -> cms_20240330_models.UpdatePrometheusViewResponse:
        """
        @summary 更新Prom视图实例信息
        
        @param request: UpdatePrometheusViewRequest
        @return: UpdatePrometheusViewResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_prometheus_view_with_options(prometheus_view_id, request, headers, runtime)

    async def update_prometheus_view_async(
        self,
        prometheus_view_id: str,
        request: cms_20240330_models.UpdatePrometheusViewRequest,
    ) -> cms_20240330_models.UpdatePrometheusViewResponse:
        """
        @summary 更新Prom视图实例信息
        
        @param request: UpdatePrometheusViewRequest
        @return: UpdatePrometheusViewResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_prometheus_view_with_options_async(prometheus_view_id, request, headers, runtime)

    def update_subscription_with_options(
        self,
        subscription_id: str,
        request: cms_20240330_models.UpdateSubscriptionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateSubscriptionResponse:
        """
        @summary 更新订阅
        
        @param request: UpdateSubscriptionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateSubscriptionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='UpdateSubscription',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/subscriptions/{OpenApiUtilClient.get_encode_param(subscription_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateSubscriptionResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateSubscriptionResponse(),
                self.execute(params, req, runtime)
            )

    async def update_subscription_with_options_async(
        self,
        subscription_id: str,
        request: cms_20240330_models.UpdateSubscriptionRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateSubscriptionResponse:
        """
        @summary 更新订阅
        
        @param request: UpdateSubscriptionRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateSubscriptionResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='UpdateSubscription',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/subscriptions/{OpenApiUtilClient.get_encode_param(subscription_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateSubscriptionResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateSubscriptionResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_subscription(
        self,
        subscription_id: str,
        request: cms_20240330_models.UpdateSubscriptionRequest,
    ) -> cms_20240330_models.UpdateSubscriptionResponse:
        """
        @summary 更新订阅
        
        @param request: UpdateSubscriptionRequest
        @return: UpdateSubscriptionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_subscription_with_options(subscription_id, request, headers, runtime)

    async def update_subscription_async(
        self,
        subscription_id: str,
        request: cms_20240330_models.UpdateSubscriptionRequest,
    ) -> cms_20240330_models.UpdateSubscriptionResponse:
        """
        @summary 更新订阅
        
        @param request: UpdateSubscriptionRequest
        @return: UpdateSubscriptionResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_subscription_with_options_async(subscription_id, request, headers, runtime)

    def update_transformer_with_options(
        self,
        transformer_id: str,
        request: cms_20240330_models.UpdateTransformerRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateTransformerResponse:
        """
        @summary 更新转化器
        
        @param request: UpdateTransformerRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTransformerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='UpdateTransformer',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/transformers/{OpenApiUtilClient.get_encode_param(transformer_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateTransformerResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateTransformerResponse(),
                self.execute(params, req, runtime)
            )

    async def update_transformer_with_options_async(
        self,
        transformer_id: str,
        request: cms_20240330_models.UpdateTransformerRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateTransformerResponse:
        """
        @summary 更新转化器
        
        @param request: UpdateTransformerRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTransformerResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(request.body)
        )
        params = open_api_models.Params(
            action='UpdateTransformer',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/transformers/{OpenApiUtilClient.get_encode_param(transformer_id)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateTransformerResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateTransformerResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_transformer(
        self,
        transformer_id: str,
        request: cms_20240330_models.UpdateTransformerRequest,
    ) -> cms_20240330_models.UpdateTransformerResponse:
        """
        @summary 更新转化器
        
        @param request: UpdateTransformerRequest
        @return: UpdateTransformerResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_transformer_with_options(transformer_id, request, headers, runtime)

    async def update_transformer_async(
        self,
        transformer_id: str,
        request: cms_20240330_models.UpdateTransformerRequest,
    ) -> cms_20240330_models.UpdateTransformerResponse:
        """
        @summary 更新转化器
        
        @param request: UpdateTransformerRequest
        @return: UpdateTransformerResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_transformer_with_options_async(transformer_id, request, headers, runtime)

    def update_transformer_sort_id_with_options(
        self,
        transformer_id: str,
        request: cms_20240330_models.UpdateTransformerSortIdRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateTransformerSortIdResponse:
        """
        @summary 更新转化器
        
        @param request: UpdateTransformerSortIdRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTransformerSortIdResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.sort_id):
            query['sortId'] = request.sort_id
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTransformerSortId',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/transformers/{OpenApiUtilClient.get_encode_param(transformer_id)}/updateSortId',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateTransformerSortIdResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateTransformerSortIdResponse(),
                self.execute(params, req, runtime)
            )

    async def update_transformer_sort_id_with_options_async(
        self,
        transformer_id: str,
        request: cms_20240330_models.UpdateTransformerSortIdRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateTransformerSortIdResponse:
        """
        @summary 更新转化器
        
        @param request: UpdateTransformerSortIdRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateTransformerSortIdResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.client_token):
            query['clientToken'] = request.client_token
        if not UtilClient.is_unset(request.sort_id):
            query['sortId'] = request.sort_id
        if not UtilClient.is_unset(request.workspace):
            query['workspace'] = request.workspace
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='UpdateTransformerSortId',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/transformers/{OpenApiUtilClient.get_encode_param(transformer_id)}/updateSortId',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateTransformerSortIdResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateTransformerSortIdResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_transformer_sort_id(
        self,
        transformer_id: str,
        request: cms_20240330_models.UpdateTransformerSortIdRequest,
    ) -> cms_20240330_models.UpdateTransformerSortIdResponse:
        """
        @summary 更新转化器
        
        @param request: UpdateTransformerSortIdRequest
        @return: UpdateTransformerSortIdResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_transformer_sort_id_with_options(transformer_id, request, headers, runtime)

    async def update_transformer_sort_id_async(
        self,
        transformer_id: str,
        request: cms_20240330_models.UpdateTransformerSortIdRequest,
    ) -> cms_20240330_models.UpdateTransformerSortIdResponse:
        """
        @summary 更新转化器
        
        @param request: UpdateTransformerSortIdRequest
        @return: UpdateTransformerSortIdResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_transformer_sort_id_with_options_async(transformer_id, request, headers, runtime)

    def update_umodel_with_options(
        self,
        workspace: str,
        request: cms_20240330_models.UpdateUmodelRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateUmodelResponse:
        """
        @summary 更新Umodel配置信息
        
        @param request: UpdateUmodelRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateUmodelResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.common_schema_ref):
            body['commonSchemaRef'] = request.common_schema_ref
        if not UtilClient.is_unset(request.description):
            body['description'] = request.description
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateUmodel',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateUmodelResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateUmodelResponse(),
                self.execute(params, req, runtime)
            )

    async def update_umodel_with_options_async(
        self,
        workspace: str,
        request: cms_20240330_models.UpdateUmodelRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpdateUmodelResponse:
        """
        @summary 更新Umodel配置信息
        
        @param request: UpdateUmodelRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpdateUmodelResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.common_schema_ref):
            body['commonSchemaRef'] = request.common_schema_ref
        if not UtilClient.is_unset(request.description):
            body['description'] = request.description
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpdateUmodel',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpdateUmodelResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpdateUmodelResponse(),
                await self.execute_async(params, req, runtime)
            )

    def update_umodel(
        self,
        workspace: str,
        request: cms_20240330_models.UpdateUmodelRequest,
    ) -> cms_20240330_models.UpdateUmodelResponse:
        """
        @summary 更新Umodel配置信息
        
        @param request: UpdateUmodelRequest
        @return: UpdateUmodelResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.update_umodel_with_options(workspace, request, headers, runtime)

    async def update_umodel_async(
        self,
        workspace: str,
        request: cms_20240330_models.UpdateUmodelRequest,
    ) -> cms_20240330_models.UpdateUmodelResponse:
        """
        @summary 更新Umodel配置信息
        
        @param request: UpdateUmodelRequest
        @return: UpdateUmodelResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.update_umodel_with_options_async(workspace, request, headers, runtime)

    def upgrade_addon_release_with_options(
        self,
        release_name: str,
        policy_id: str,
        request: cms_20240330_models.UpgradeAddonReleaseRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpgradeAddonReleaseResponse:
        """
        @summary 升级接入组件
        
        @param request: UpgradeAddonReleaseRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpgradeAddonReleaseResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.addon_version):
            body['addonVersion'] = request.addon_version
        if not UtilClient.is_unset(request.dry_run):
            body['dryRun'] = request.dry_run
        if not UtilClient.is_unset(request.values):
            body['values'] = request.values
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpgradeAddonRelease',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy/{OpenApiUtilClient.get_encode_param(policy_id)}/addonrelease/{OpenApiUtilClient.get_encode_param(release_name)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpgradeAddonReleaseResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpgradeAddonReleaseResponse(),
                self.execute(params, req, runtime)
            )

    async def upgrade_addon_release_with_options_async(
        self,
        release_name: str,
        policy_id: str,
        request: cms_20240330_models.UpgradeAddonReleaseRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpgradeAddonReleaseResponse:
        """
        @summary 升级接入组件
        
        @param request: UpgradeAddonReleaseRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpgradeAddonReleaseResponse
        """
        UtilClient.validate_model(request)
        body = {}
        if not UtilClient.is_unset(request.addon_version):
            body['addonVersion'] = request.addon_version
        if not UtilClient.is_unset(request.dry_run):
            body['dryRun'] = request.dry_run
        if not UtilClient.is_unset(request.values):
            body['values'] = request.values
        req = open_api_models.OpenApiRequest(
            headers=headers,
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpgradeAddonRelease',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/policy/{OpenApiUtilClient.get_encode_param(policy_id)}/addonrelease/{OpenApiUtilClient.get_encode_param(release_name)}',
            method='PUT',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpgradeAddonReleaseResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpgradeAddonReleaseResponse(),
                await self.execute_async(params, req, runtime)
            )

    def upgrade_addon_release(
        self,
        release_name: str,
        policy_id: str,
        request: cms_20240330_models.UpgradeAddonReleaseRequest,
    ) -> cms_20240330_models.UpgradeAddonReleaseResponse:
        """
        @summary 升级接入组件
        
        @param request: UpgradeAddonReleaseRequest
        @return: UpgradeAddonReleaseResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.upgrade_addon_release_with_options(release_name, policy_id, request, headers, runtime)

    async def upgrade_addon_release_async(
        self,
        release_name: str,
        policy_id: str,
        request: cms_20240330_models.UpgradeAddonReleaseRequest,
    ) -> cms_20240330_models.UpgradeAddonReleaseResponse:
        """
        @summary 升级接入组件
        
        @param request: UpgradeAddonReleaseRequest
        @return: UpgradeAddonReleaseResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.upgrade_addon_release_with_options_async(release_name, policy_id, request, headers, runtime)

    def upsert_umodel_data_with_options(
        self,
        workspace: str,
        request: cms_20240330_models.UpsertUmodelDataRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpsertUmodelDataResponse:
        """
        @summary 写入 Umodel Elements
        
        @param request: UpsertUmodelDataRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpsertUmodelDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.method):
            query['method'] = request.method
        body = {}
        if not UtilClient.is_unset(request.elements):
            body['elements'] = request.elements
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpsertUmodelData',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel/data',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpsertUmodelDataResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpsertUmodelDataResponse(),
                self.execute(params, req, runtime)
            )

    async def upsert_umodel_data_with_options_async(
        self,
        workspace: str,
        request: cms_20240330_models.UpsertUmodelDataRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpsertUmodelDataResponse:
        """
        @summary 写入 Umodel Elements
        
        @param request: UpsertUmodelDataRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpsertUmodelDataResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.method):
            query['method'] = request.method
        body = {}
        if not UtilClient.is_unset(request.elements):
            body['elements'] = request.elements
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpsertUmodelData',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel/data',
            method='PATCH',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpsertUmodelDataResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpsertUmodelDataResponse(),
                await self.execute_async(params, req, runtime)
            )

    def upsert_umodel_data(
        self,
        workspace: str,
        request: cms_20240330_models.UpsertUmodelDataRequest,
    ) -> cms_20240330_models.UpsertUmodelDataResponse:
        """
        @summary 写入 Umodel Elements
        
        @param request: UpsertUmodelDataRequest
        @return: UpsertUmodelDataResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.upsert_umodel_data_with_options(workspace, request, headers, runtime)

    async def upsert_umodel_data_async(
        self,
        workspace: str,
        request: cms_20240330_models.UpsertUmodelDataRequest,
    ) -> cms_20240330_models.UpsertUmodelDataResponse:
        """
        @summary 写入 Umodel Elements
        
        @param request: UpsertUmodelDataRequest
        @return: UpsertUmodelDataResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.upsert_umodel_data_with_options_async(workspace, request, headers, runtime)

    def upsert_umodel_data_test_with_options(
        self,
        workspace: str,
        request: cms_20240330_models.UpsertUmodelDataTestRequest,
        headers: cms_20240330_models.UpsertUmodelDataTestHeaders,
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpsertUmodelDataTestResponse:
        """
        @summary 写入 Umodel Elements
        
        @param request: UpsertUmodelDataTestRequest
        @param headers: UpsertUmodelDataTestHeaders
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpsertUmodelDataTestResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.method):
            query['method'] = request.method
        body = {}
        if not UtilClient.is_unset(request.elements):
            body['elements'] = request.elements
        real_headers = {}
        if not UtilClient.is_unset(headers.common_headers):
            real_headers = headers.common_headers
        if not UtilClient.is_unset(headers.x_logapiversion):
            real_headers['X-LOG-APIVERSION'] = UtilClient.to_jsonstring(headers.x_logapiversion)
        req = open_api_models.OpenApiRequest(
            headers=real_headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpsertUmodelDataTest',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel/data',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpsertUmodelDataTestResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpsertUmodelDataTestResponse(),
                self.execute(params, req, runtime)
            )

    async def upsert_umodel_data_test_with_options_async(
        self,
        workspace: str,
        request: cms_20240330_models.UpsertUmodelDataTestRequest,
        headers: cms_20240330_models.UpsertUmodelDataTestHeaders,
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.UpsertUmodelDataTestResponse:
        """
        @summary 写入 Umodel Elements
        
        @param request: UpsertUmodelDataTestRequest
        @param headers: UpsertUmodelDataTestHeaders
        @param runtime: runtime options for this request RuntimeOptions
        @return: UpsertUmodelDataTestResponse
        """
        UtilClient.validate_model(request)
        query = {}
        if not UtilClient.is_unset(request.method):
            query['method'] = request.method
        body = {}
        if not UtilClient.is_unset(request.elements):
            body['elements'] = request.elements
        real_headers = {}
        if not UtilClient.is_unset(headers.common_headers):
            real_headers = headers.common_headers
        if not UtilClient.is_unset(headers.x_logapiversion):
            real_headers['X-LOG-APIVERSION'] = UtilClient.to_jsonstring(headers.x_logapiversion)
        req = open_api_models.OpenApiRequest(
            headers=real_headers,
            query=OpenApiUtilClient.query(query),
            body=OpenApiUtilClient.parse_to_map(body)
        )
        params = open_api_models.Params(
            action='UpsertUmodelDataTest',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/workspace/{OpenApiUtilClient.get_encode_param(workspace)}/umodel/data',
            method='POST',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.UpsertUmodelDataTestResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.UpsertUmodelDataTestResponse(),
                await self.execute_async(params, req, runtime)
            )

    def upsert_umodel_data_test(
        self,
        workspace: str,
        request: cms_20240330_models.UpsertUmodelDataTestRequest,
    ) -> cms_20240330_models.UpsertUmodelDataTestResponse:
        """
        @summary 写入 Umodel Elements
        
        @param request: UpsertUmodelDataTestRequest
        @return: UpsertUmodelDataTestResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = cms_20240330_models.UpsertUmodelDataTestHeaders()
        return self.upsert_umodel_data_test_with_options(workspace, request, headers, runtime)

    async def upsert_umodel_data_test_async(
        self,
        workspace: str,
        request: cms_20240330_models.UpsertUmodelDataTestRequest,
    ) -> cms_20240330_models.UpsertUmodelDataTestResponse:
        """
        @summary 写入 Umodel Elements
        
        @param request: UpsertUmodelDataTestRequest
        @return: UpsertUmodelDataTestResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = cms_20240330_models.UpsertUmodelDataTestHeaders()
        return await self.upsert_umodel_data_test_with_options_async(workspace, request, headers, runtime)

    def view_oncall_schedule_with_options(
        self,
        oncall_schedule_id: str,
        tmp_req: cms_20240330_models.ViewOncallScheduleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ViewOncallScheduleResponse:
        """
        @summary 查看值班日历
        
        @param tmp_req: ViewOncallScheduleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ViewOncallScheduleResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ViewOncallScheduleShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.un_saved_schedule):
            request.un_saved_schedule_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.un_saved_schedule, 'unSavedSchedule', 'json')
        query = {}
        if not UtilClient.is_unset(request.end_date):
            query['endDate'] = request.end_date
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.start_date):
            query['startDate'] = request.start_date
        if not UtilClient.is_unset(request.un_saved_schedule_shrink):
            query['unSavedSchedule'] = request.un_saved_schedule_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ViewOncallSchedule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/oncallSchedule/{OpenApiUtilClient.get_encode_param(oncall_schedule_id)}/calendar',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ViewOncallScheduleResponse(),
                self.call_api(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ViewOncallScheduleResponse(),
                self.execute(params, req, runtime)
            )

    async def view_oncall_schedule_with_options_async(
        self,
        oncall_schedule_id: str,
        tmp_req: cms_20240330_models.ViewOncallScheduleRequest,
        headers: Dict[str, str],
        runtime: util_models.RuntimeOptions,
    ) -> cms_20240330_models.ViewOncallScheduleResponse:
        """
        @summary 查看值班日历
        
        @param tmp_req: ViewOncallScheduleRequest
        @param headers: map
        @param runtime: runtime options for this request RuntimeOptions
        @return: ViewOncallScheduleResponse
        """
        UtilClient.validate_model(tmp_req)
        request = cms_20240330_models.ViewOncallScheduleShrinkRequest()
        OpenApiUtilClient.convert(tmp_req, request)
        if not UtilClient.is_unset(tmp_req.un_saved_schedule):
            request.un_saved_schedule_shrink = OpenApiUtilClient.array_to_string_with_specified_style(tmp_req.un_saved_schedule, 'unSavedSchedule', 'json')
        query = {}
        if not UtilClient.is_unset(request.end_date):
            query['endDate'] = request.end_date
        if not UtilClient.is_unset(request.source):
            query['source'] = request.source
        if not UtilClient.is_unset(request.start_date):
            query['startDate'] = request.start_date
        if not UtilClient.is_unset(request.un_saved_schedule_shrink):
            query['unSavedSchedule'] = request.un_saved_schedule_shrink
        req = open_api_models.OpenApiRequest(
            headers=headers,
            query=OpenApiUtilClient.query(query)
        )
        params = open_api_models.Params(
            action='ViewOncallSchedule',
            version='2024-03-30',
            protocol='HTTPS',
            pathname=f'/oncallSchedule/{OpenApiUtilClient.get_encode_param(oncall_schedule_id)}/calendar',
            method='GET',
            auth_type='AK',
            style='ROA',
            req_body_type='json',
            body_type='json'
        )
        if UtilClient.is_unset(self._signature_version) or not UtilClient.equal_string(self._signature_version, 'v4'):
            return TeaCore.from_map(
                cms_20240330_models.ViewOncallScheduleResponse(),
                await self.call_api_async(params, req, runtime)
            )
        else:
            return TeaCore.from_map(
                cms_20240330_models.ViewOncallScheduleResponse(),
                await self.execute_async(params, req, runtime)
            )

    def view_oncall_schedule(
        self,
        oncall_schedule_id: str,
        request: cms_20240330_models.ViewOncallScheduleRequest,
    ) -> cms_20240330_models.ViewOncallScheduleResponse:
        """
        @summary 查看值班日历
        
        @param request: ViewOncallScheduleRequest
        @return: ViewOncallScheduleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return self.view_oncall_schedule_with_options(oncall_schedule_id, request, headers, runtime)

    async def view_oncall_schedule_async(
        self,
        oncall_schedule_id: str,
        request: cms_20240330_models.ViewOncallScheduleRequest,
    ) -> cms_20240330_models.ViewOncallScheduleResponse:
        """
        @summary 查看值班日历
        
        @param request: ViewOncallScheduleRequest
        @return: ViewOncallScheduleResponse
        """
        runtime = util_models.RuntimeOptions()
        headers = {}
        return await self.view_oncall_schedule_with_options_async(oncall_schedule_id, request, headers, runtime)
