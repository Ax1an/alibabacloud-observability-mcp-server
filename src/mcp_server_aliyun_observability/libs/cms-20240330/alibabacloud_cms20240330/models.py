# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Dict, Any, BinaryIO


class ActionStrategyForView(TeaModel):
    def __init__(
        self,
        alert_action_ids: List[str] = None,
        create_time: str = None,
        description: str = None,
        enable: bool = None,
        name: str = None,
        restore_action_ids: List[str] = None,
        template_uuid: str = None,
        update_time: str = None,
        user_id: str = None,
        uuid: str = None,
        workspace: str = None,
    ):
        self.alert_action_ids = alert_action_ids
        self.create_time = create_time
        self.description = description
        self.enable = enable
        # This parameter is required.
        self.name = name
        self.restore_action_ids = restore_action_ids
        self.template_uuid = template_uuid
        self.update_time = update_time
        self.user_id = user_id
        self.uuid = uuid
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_action_ids is not None:
            result['alertActionIds'] = self.alert_action_ids
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.enable is not None:
            result['enable'] = self.enable
        if self.name is not None:
            result['name'] = self.name
        if self.restore_action_ids is not None:
            result['restoreActionIds'] = self.restore_action_ids
        if self.template_uuid is not None:
            result['templateUuid'] = self.template_uuid
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertActionIds') is not None:
            self.alert_action_ids = m.get('alertActionIds')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('restoreActionIds') is not None:
            self.restore_action_ids = m.get('restoreActionIds')
        if m.get('templateUuid') is not None:
            self.template_uuid = m.get('templateUuid')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class AddonMetaDashboards(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        url: str = None,
    ):
        self.description = description
        self.name = name
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class AddonMetaEnvironmentsDependencies(TeaModel):
    def __init__(
        self,
        cluster_types: List[str] = None,
        features: Dict[str, bool] = None,
        services: List[str] = None,
    ):
        self.cluster_types = cluster_types
        self.features = features
        self.services = services

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_types is not None:
            result['clusterTypes'] = self.cluster_types
        if self.features is not None:
            result['features'] = self.features
        if self.services is not None:
            result['services'] = self.services
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterTypes') is not None:
            self.cluster_types = m.get('clusterTypes')
        if m.get('features') is not None:
            self.features = m.get('features')
        if m.get('services') is not None:
            self.services = m.get('services')
        return self


class AddonMetaEnvironmentsPoliciesBindEntity(TeaModel):
    def __init__(
        self,
        entity_group_mode: bool = None,
        entity_type: str = None,
        single_entity_mode: bool = None,
        vpc_id_field_key: str = None,
    ):
        self.entity_group_mode = entity_group_mode
        self.entity_type = entity_type
        self.single_entity_mode = single_entity_mode
        self.vpc_id_field_key = vpc_id_field_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_group_mode is not None:
            result['entityGroupMode'] = self.entity_group_mode
        if self.entity_type is not None:
            result['entityType'] = self.entity_type
        if self.single_entity_mode is not None:
            result['singleEntityMode'] = self.single_entity_mode
        if self.vpc_id_field_key is not None:
            result['vpcIdFieldKey'] = self.vpc_id_field_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('entityGroupMode') is not None:
            self.entity_group_mode = m.get('entityGroupMode')
        if m.get('entityType') is not None:
            self.entity_type = m.get('entityType')
        if m.get('singleEntityMode') is not None:
            self.single_entity_mode = m.get('singleEntityMode')
        if m.get('vpcIdFieldKey') is not None:
            self.vpc_id_field_key = m.get('vpcIdFieldKey')
        return self


class AddonMetaEnvironmentsPoliciesMetricCheckRule(TeaModel):
    def __init__(
        self,
        prom_ql: List[str] = None,
    ):
        self.prom_ql = prom_ql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prom_ql is not None:
            result['promQL'] = self.prom_ql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('promQL') is not None:
            self.prom_ql = m.get('promQL')
        return self


class AddonMetaEnvironmentsPoliciesProtocols(TeaModel):
    def __init__(
        self,
        description: str = None,
        icon: str = None,
        label: str = None,
        name: str = None,
    ):
        self.description = description
        self.icon = icon
        self.label = label
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.icon is not None:
            result['icon'] = self.icon
        if self.label is not None:
            result['label'] = self.label
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class AddonMetaEnvironmentsPolicies(TeaModel):
    def __init__(
        self,
        alert_default_status: str = None,
        bind_default_policy: bool = None,
        bind_entity: AddonMetaEnvironmentsPoliciesBindEntity = None,
        default_install: bool = None,
        enable_service_account: bool = None,
        metric_check_rule: AddonMetaEnvironmentsPoliciesMetricCheckRule = None,
        need_restart_after_integration: bool = None,
        protocols: List[AddonMetaEnvironmentsPoliciesProtocols] = None,
        target_addon_name: str = None,
    ):
        self.alert_default_status = alert_default_status
        self.bind_default_policy = bind_default_policy
        self.bind_entity = bind_entity
        self.default_install = default_install
        self.enable_service_account = enable_service_account
        self.metric_check_rule = metric_check_rule
        self.need_restart_after_integration = need_restart_after_integration
        self.protocols = protocols
        self.target_addon_name = target_addon_name

    def validate(self):
        if self.bind_entity:
            self.bind_entity.validate()
        if self.metric_check_rule:
            self.metric_check_rule.validate()
        if self.protocols:
            for k in self.protocols:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_default_status is not None:
            result['alertDefaultStatus'] = self.alert_default_status
        if self.bind_default_policy is not None:
            result['bindDefaultPolicy'] = self.bind_default_policy
        if self.bind_entity is not None:
            result['bindEntity'] = self.bind_entity.to_map()
        if self.default_install is not None:
            result['defaultInstall'] = self.default_install
        if self.enable_service_account is not None:
            result['enableServiceAccount'] = self.enable_service_account
        if self.metric_check_rule is not None:
            result['metricCheckRule'] = self.metric_check_rule.to_map()
        if self.need_restart_after_integration is not None:
            result['needRestartAfterIntegration'] = self.need_restart_after_integration
        result['protocols'] = []
        if self.protocols is not None:
            for k in self.protocols:
                result['protocols'].append(k.to_map() if k else None)
        if self.target_addon_name is not None:
            result['targetAddonName'] = self.target_addon_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertDefaultStatus') is not None:
            self.alert_default_status = m.get('alertDefaultStatus')
        if m.get('bindDefaultPolicy') is not None:
            self.bind_default_policy = m.get('bindDefaultPolicy')
        if m.get('bindEntity') is not None:
            temp_model = AddonMetaEnvironmentsPoliciesBindEntity()
            self.bind_entity = temp_model.from_map(m['bindEntity'])
        if m.get('defaultInstall') is not None:
            self.default_install = m.get('defaultInstall')
        if m.get('enableServiceAccount') is not None:
            self.enable_service_account = m.get('enableServiceAccount')
        if m.get('metricCheckRule') is not None:
            temp_model = AddonMetaEnvironmentsPoliciesMetricCheckRule()
            self.metric_check_rule = temp_model.from_map(m['metricCheckRule'])
        if m.get('needRestartAfterIntegration') is not None:
            self.need_restart_after_integration = m.get('needRestartAfterIntegration')
        self.protocols = []
        if m.get('protocols') is not None:
            for k in m.get('protocols'):
                temp_model = AddonMetaEnvironmentsPoliciesProtocols()
                self.protocols.append(temp_model.from_map(k))
        if m.get('targetAddonName') is not None:
            self.target_addon_name = m.get('targetAddonName')
        return self


class AddonMetaEnvironments(TeaModel):
    def __init__(
        self,
        dependencies: AddonMetaEnvironmentsDependencies = None,
        description: str = None,
        enable: bool = None,
        label: str = None,
        name: str = None,
        policies: AddonMetaEnvironmentsPolicies = None,
        policy_type: str = None,
    ):
        self.dependencies = dependencies
        self.description = description
        self.enable = enable
        self.label = label
        self.name = name
        self.policies = policies
        self.policy_type = policy_type

    def validate(self):
        if self.dependencies:
            self.dependencies.validate()
        if self.policies:
            self.policies.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dependencies is not None:
            result['dependencies'] = self.dependencies.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.enable is not None:
            result['enable'] = self.enable
        if self.label is not None:
            result['label'] = self.label
        if self.name is not None:
            result['name'] = self.name
        if self.policies is not None:
            result['policies'] = self.policies.to_map()
        if self.policy_type is not None:
            result['policyType'] = self.policy_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dependencies') is not None:
            temp_model = AddonMetaEnvironmentsDependencies()
            self.dependencies = temp_model.from_map(m['dependencies'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('policies') is not None:
            temp_model = AddonMetaEnvironmentsPolicies()
            self.policies = temp_model.from_map(m['policies'])
        if m.get('policyType') is not None:
            self.policy_type = m.get('policyType')
        return self


class AddonMeta(TeaModel):
    def __init__(
        self,
        alias: str = None,
        categories: List[str] = None,
        dashboards: List[AddonMetaDashboards] = None,
        description: str = None,
        environments: List[AddonMetaEnvironments] = None,
        icon: str = None,
        keywords: List[str] = None,
        language: str = None,
        latest_release_create_time: str = None,
        name: str = None,
        once: bool = None,
        scene: str = None,
        version: str = None,
        weight: int = None,
    ):
        self.alias = alias
        self.categories = categories
        self.dashboards = dashboards
        self.description = description
        self.environments = environments
        self.icon = icon
        self.keywords = keywords
        self.language = language
        self.latest_release_create_time = latest_release_create_time
        self.name = name
        self.once = once
        self.scene = scene
        self.version = version
        self.weight = weight

    def validate(self):
        if self.dashboards:
            for k in self.dashboards:
                if k:
                    k.validate()
        if self.environments:
            for k in self.environments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['alias'] = self.alias
        if self.categories is not None:
            result['categories'] = self.categories
        result['dashboards'] = []
        if self.dashboards is not None:
            for k in self.dashboards:
                result['dashboards'].append(k.to_map() if k else None)
        if self.description is not None:
            result['description'] = self.description
        result['environments'] = []
        if self.environments is not None:
            for k in self.environments:
                result['environments'].append(k.to_map() if k else None)
        if self.icon is not None:
            result['icon'] = self.icon
        if self.keywords is not None:
            result['keywords'] = self.keywords
        if self.language is not None:
            result['language'] = self.language
        if self.latest_release_create_time is not None:
            result['latestReleaseCreateTime'] = self.latest_release_create_time
        if self.name is not None:
            result['name'] = self.name
        if self.once is not None:
            result['once'] = self.once
        if self.scene is not None:
            result['scene'] = self.scene
        if self.version is not None:
            result['version'] = self.version
        if self.weight is not None:
            result['weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alias') is not None:
            self.alias = m.get('alias')
        if m.get('categories') is not None:
            self.categories = m.get('categories')
        self.dashboards = []
        if m.get('dashboards') is not None:
            for k in m.get('dashboards'):
                temp_model = AddonMetaDashboards()
                self.dashboards.append(temp_model.from_map(k))
        if m.get('description') is not None:
            self.description = m.get('description')
        self.environments = []
        if m.get('environments') is not None:
            for k in m.get('environments'):
                temp_model = AddonMetaEnvironments()
                self.environments.append(temp_model.from_map(k))
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('keywords') is not None:
            self.keywords = m.get('keywords')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('latestReleaseCreateTime') is not None:
            self.latest_release_create_time = m.get('latestReleaseCreateTime')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('once') is not None:
            self.once = m.get('once')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        return self


class FilterSettingConditions(TeaModel):
    def __init__(
        self,
        field: str = None,
        op: str = None,
        value: str = None,
    ):
        self.field = field
        self.op = op
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['field'] = self.field
        if self.op is not None:
            result['op'] = self.op
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('field') is not None:
            self.field = m.get('field')
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class FilterSetting(TeaModel):
    def __init__(
        self,
        conditions: List[FilterSettingConditions] = None,
        expression: str = None,
        relation: str = None,
    ):
        self.conditions = conditions
        self.expression = expression
        self.relation = relation

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.expression is not None:
            result['expression'] = self.expression
        if self.relation is not None:
            result['relation'] = self.relation
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = FilterSettingConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('expression') is not None:
            self.expression = m.get('expression')
        if m.get('relation') is not None:
            self.relation = m.get('relation')
        return self


class TransformAction(TeaModel):
    def __init__(
        self,
        filter_setting: FilterSetting = None,
        label_key: str = None,
        mapping: Dict[str, str] = None,
        reg_exp: str = None,
        source: str = None,
        target: str = None,
        type: str = None,
        value: str = None,
        variable: str = None,
    ):
        self.filter_setting = filter_setting
        self.label_key = label_key
        self.mapping = mapping
        self.reg_exp = reg_exp
        self.source = source
        self.target = target
        self.type = type
        self.value = value
        self.variable = variable

    def validate(self):
        if self.filter_setting:
            self.filter_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.label_key is not None:
            result['labelKey'] = self.label_key
        if self.mapping is not None:
            result['mapping'] = self.mapping
        if self.reg_exp is not None:
            result['regExp'] = self.reg_exp
        if self.source is not None:
            result['source'] = self.source
        if self.target is not None:
            result['target'] = self.target
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        if self.variable is not None:
            result['variable'] = self.variable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('filterSetting') is not None:
            temp_model = FilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('labelKey') is not None:
            self.label_key = m.get('labelKey')
        if m.get('mapping') is not None:
            self.mapping = m.get('mapping')
        if m.get('regExp') is not None:
            self.reg_exp = m.get('regExp')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('target') is not None:
            self.target = m.get('target')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('variable') is not None:
            self.variable = m.get('variable')
        return self


class AlertEventIntegrationPolicyForModify(TeaModel):
    def __init__(
        self,
        alert_event_integration_policy_name: str = None,
        description: str = None,
        filter_setting: FilterSetting = None,
        integration_setting: str = None,
        transformer_setting: List[TransformAction] = None,
        type: str = None,
    ):
        # This parameter is required.
        self.alert_event_integration_policy_name = alert_event_integration_policy_name
        self.description = description
        self.filter_setting = filter_setting
        self.integration_setting = integration_setting
        self.transformer_setting = transformer_setting
        self.type = type

    def validate(self):
        if self.filter_setting:
            self.filter_setting.validate()
        if self.transformer_setting:
            for k in self.transformer_setting:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_event_integration_policy_name is not None:
            result['alertEventIntegrationPolicyName'] = self.alert_event_integration_policy_name
        if self.description is not None:
            result['description'] = self.description
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.integration_setting is not None:
            result['integrationSetting'] = self.integration_setting
        result['transformerSetting'] = []
        if self.transformer_setting is not None:
            for k in self.transformer_setting:
                result['transformerSetting'].append(k.to_map() if k else None)
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertEventIntegrationPolicyName') is not None:
            self.alert_event_integration_policy_name = m.get('alertEventIntegrationPolicyName')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('filterSetting') is not None:
            temp_model = FilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('integrationSetting') is not None:
            self.integration_setting = m.get('integrationSetting')
        self.transformer_setting = []
        if m.get('transformerSetting') is not None:
            for k in m.get('transformerSetting'):
                temp_model = TransformAction()
                self.transformer_setting.append(temp_model.from_map(k))
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class AlertEventIntegrationPolicyForView(TeaModel):
    def __init__(
        self,
        alert_event_integration_policy_id: str = None,
        alert_event_integration_policy_name: str = None,
        create_time: str = None,
        description: str = None,
        enable: bool = None,
        filter_setting: FilterSetting = None,
        integration_setting: str = None,
        transformer_setting: List[TransformAction] = None,
        type: str = None,
        update_time: str = None,
        user_id: str = None,
        workspace: str = None,
    ):
        self.alert_event_integration_policy_id = alert_event_integration_policy_id
        # This parameter is required.
        self.alert_event_integration_policy_name = alert_event_integration_policy_name
        self.create_time = create_time
        self.description = description
        self.enable = enable
        self.filter_setting = filter_setting
        self.integration_setting = integration_setting
        self.transformer_setting = transformer_setting
        self.type = type
        self.update_time = update_time
        self.user_id = user_id
        self.workspace = workspace

    def validate(self):
        if self.filter_setting:
            self.filter_setting.validate()
        if self.transformer_setting:
            for k in self.transformer_setting:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_event_integration_policy_id is not None:
            result['alertEventIntegrationPolicyId'] = self.alert_event_integration_policy_id
        if self.alert_event_integration_policy_name is not None:
            result['alertEventIntegrationPolicyName'] = self.alert_event_integration_policy_name
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.enable is not None:
            result['enable'] = self.enable
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.integration_setting is not None:
            result['integrationSetting'] = self.integration_setting
        result['transformerSetting'] = []
        if self.transformer_setting is not None:
            for k in self.transformer_setting:
                result['transformerSetting'].append(k.to_map() if k else None)
        if self.type is not None:
            result['type'] = self.type
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertEventIntegrationPolicyId') is not None:
            self.alert_event_integration_policy_id = m.get('alertEventIntegrationPolicyId')
        if m.get('alertEventIntegrationPolicyName') is not None:
            self.alert_event_integration_policy_name = m.get('alertEventIntegrationPolicyName')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('filterSetting') is not None:
            temp_model = FilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('integrationSetting') is not None:
            self.integration_setting = m.get('integrationSetting')
        self.transformer_setting = []
        if m.get('transformerSetting') is not None:
            for k in m.get('transformerSetting'):
                temp_model = TransformAction()
                self.transformer_setting.append(temp_model.from_map(k))
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class AlertRuleAction(TeaModel):
    def __init__(
        self,
        actions: List[str] = None,
    ):
        self.actions = actions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actions is not None:
            result['actions'] = self.actions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('actions') is not None:
            self.actions = m.get('actions')
        return self


class AlertRuleAlertMetricFilterDefSupportedOpts(TeaModel):
    def __init__(
        self,
        display_name_cn: str = None,
        display_name_en: str = None,
        value: str = None,
    ):
        self.display_name_cn = display_name_cn
        self.display_name_en = display_name_en
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name_cn is not None:
            result['displayNameCn'] = self.display_name_cn
        if self.display_name_en is not None:
            result['displayNameEn'] = self.display_name_en
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('displayNameCn') is not None:
            self.display_name_cn = m.get('displayNameCn')
        if m.get('displayNameEn') is not None:
            self.display_name_en = m.get('displayNameEn')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class AlertRuleAlertMetricFilterDef(TeaModel):
    def __init__(
        self,
        dim: str = None,
        display_name_cn: str = None,
        display_name_en: str = None,
        hidden: bool = None,
        opt: str = None,
        supported_opts: List[AlertRuleAlertMetricFilterDefSupportedOpts] = None,
    ):
        self.dim = dim
        self.display_name_cn = display_name_cn
        self.display_name_en = display_name_en
        self.hidden = hidden
        self.opt = opt
        self.supported_opts = supported_opts

    def validate(self):
        if self.supported_opts:
            for k in self.supported_opts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dim is not None:
            result['dim'] = self.dim
        if self.display_name_cn is not None:
            result['displayNameCn'] = self.display_name_cn
        if self.display_name_en is not None:
            result['displayNameEn'] = self.display_name_en
        if self.hidden is not None:
            result['hidden'] = self.hidden
        if self.opt is not None:
            result['opt'] = self.opt
        result['supportedOpts'] = []
        if self.supported_opts is not None:
            for k in self.supported_opts:
                result['supportedOpts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dim') is not None:
            self.dim = m.get('dim')
        if m.get('displayNameCn') is not None:
            self.display_name_cn = m.get('displayNameCn')
        if m.get('displayNameEn') is not None:
            self.display_name_en = m.get('displayNameEn')
        if m.get('hidden') is not None:
            self.hidden = m.get('hidden')
        if m.get('opt') is not None:
            self.opt = m.get('opt')
        self.supported_opts = []
        if m.get('supportedOpts') is not None:
            for k in m.get('supportedOpts'):
                temp_model = AlertRuleAlertMetricFilterDefSupportedOpts()
                self.supported_opts.append(temp_model.from_map(k))
        return self


class AlertRuleAlertMetricInputFilterValue(TeaModel):
    def __init__(
        self,
        dim: str = None,
        opt: str = None,
        value: str = None,
    ):
        # This parameter is required.
        self.dim = dim
        # This parameter is required.
        self.opt = opt
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dim is not None:
            result['dim'] = self.dim
        if self.opt is not None:
            result['opt'] = self.opt
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dim') is not None:
            self.dim = m.get('dim')
        if m.get('opt') is not None:
            self.opt = m.get('opt')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class AlertRuleAlertMetricInputParamValue(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class AlertRuleAlertMetricInput(TeaModel):
    def __init__(
        self,
        filter_values: List[AlertRuleAlertMetricInputFilterValue] = None,
        group_id: str = None,
        metric_id: str = None,
        param_values: List[AlertRuleAlertMetricInputParamValue] = None,
    ):
        self.filter_values = filter_values
        self.group_id = group_id
        self.metric_id = metric_id
        self.param_values = param_values

    def validate(self):
        if self.filter_values:
            for k in self.filter_values:
                if k:
                    k.validate()
        if self.param_values:
            for k in self.param_values:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['filterValues'] = []
        if self.filter_values is not None:
            for k in self.filter_values:
                result['filterValues'].append(k.to_map() if k else None)
        if self.group_id is not None:
            result['groupId'] = self.group_id
        if self.metric_id is not None:
            result['metricId'] = self.metric_id
        result['paramValues'] = []
        if self.param_values is not None:
            for k in self.param_values:
                result['paramValues'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.filter_values = []
        if m.get('filterValues') is not None:
            for k in m.get('filterValues'):
                temp_model = AlertRuleAlertMetricInputFilterValue()
                self.filter_values.append(temp_model.from_map(k))
        if m.get('groupId') is not None:
            self.group_id = m.get('groupId')
        if m.get('metricId') is not None:
            self.metric_id = m.get('metricId')
        self.param_values = []
        if m.get('paramValues') is not None:
            for k in m.get('paramValues'):
                temp_model = AlertRuleAlertMetricInputParamValue()
                self.param_values.append(temp_model.from_map(k))
        return self


class AlertRuleAlertMetricParamDefValues(TeaModel):
    def __init__(
        self,
        label_cn: str = None,
        label_en: str = None,
        value: str = None,
    ):
        self.label_cn = label_cn
        self.label_en = label_en
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label_cn is not None:
            result['labelCn'] = self.label_cn
        if self.label_en is not None:
            result['labelEn'] = self.label_en
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('labelCn') is not None:
            self.label_cn = m.get('labelCn')
        if m.get('labelEn') is not None:
            self.label_en = m.get('labelEn')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class AlertRuleAlertMetricParamDef(TeaModel):
    def __init__(
        self,
        max_width: int = None,
        min_width: int = None,
        name: str = None,
        placeholder_cn: str = None,
        placeholder_en: str = None,
        type: str = None,
        value: str = None,
        values: List[AlertRuleAlertMetricParamDefValues] = None,
    ):
        self.max_width = max_width
        self.min_width = min_width
        self.name = name
        self.placeholder_cn = placeholder_cn
        self.placeholder_en = placeholder_en
        self.type = type
        self.value = value
        self.values = values

    def validate(self):
        if self.values:
            for k in self.values:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_width is not None:
            result['maxWidth'] = self.max_width
        if self.min_width is not None:
            result['minWidth'] = self.min_width
        if self.name is not None:
            result['name'] = self.name
        if self.placeholder_cn is not None:
            result['placeholderCn'] = self.placeholder_cn
        if self.placeholder_en is not None:
            result['placeholderEn'] = self.placeholder_en
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        result['values'] = []
        if self.values is not None:
            for k in self.values:
                result['values'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxWidth') is not None:
            self.max_width = m.get('maxWidth')
        if m.get('minWidth') is not None:
            self.min_width = m.get('minWidth')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('placeholderCn') is not None:
            self.placeholder_cn = m.get('placeholderCn')
        if m.get('placeholderEn') is not None:
            self.placeholder_en = m.get('placeholderEn')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        self.values = []
        if m.get('values') is not None:
            for k in m.get('values'):
                temp_model = AlertRuleAlertMetricParamDefValues()
                self.values.append(temp_model.from_map(k))
        return self


class AlertRuleConditionCaseList(TeaModel):
    def __init__(
        self,
        condition: str = None,
        count_condition: str = None,
        level: str = None,
        type: str = None,
    ):
        self.condition = condition
        self.count_condition = count_condition
        self.level = level
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition is not None:
            result['condition'] = self.condition
        if self.count_condition is not None:
            result['countCondition'] = self.count_condition
        if self.level is not None:
            result['level'] = self.level
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('countCondition') is not None:
            self.count_condition = m.get('countCondition')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class AlertRuleConditionCompareListValueLevelList(TeaModel):
    def __init__(
        self,
        level: str = None,
        value: float = None,
    ):
        self.level = level
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['level'] = self.level
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class AlertRuleConditionCompareList(TeaModel):
    def __init__(
        self,
        aggregate: str = None,
        oper: str = None,
        value: float = None,
        value_level_list: List[AlertRuleConditionCompareListValueLevelList] = None,
        yoy_time_unit: str = None,
        yoy_time_value: int = None,
    ):
        self.aggregate = aggregate
        self.oper = oper
        self.value = value
        self.value_level_list = value_level_list
        self.yoy_time_unit = yoy_time_unit
        self.yoy_time_value = yoy_time_value

    def validate(self):
        if self.value_level_list:
            for k in self.value_level_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aggregate is not None:
            result['aggregate'] = self.aggregate
        if self.oper is not None:
            result['oper'] = self.oper
        if self.value is not None:
            result['value'] = self.value
        result['valueLevelList'] = []
        if self.value_level_list is not None:
            for k in self.value_level_list:
                result['valueLevelList'].append(k.to_map() if k else None)
        if self.yoy_time_unit is not None:
            result['yoyTimeUnit'] = self.yoy_time_unit
        if self.yoy_time_value is not None:
            result['yoyTimeValue'] = self.yoy_time_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aggregate') is not None:
            self.aggregate = m.get('aggregate')
        if m.get('oper') is not None:
            self.oper = m.get('oper')
        if m.get('value') is not None:
            self.value = m.get('value')
        self.value_level_list = []
        if m.get('valueLevelList') is not None:
            for k in m.get('valueLevelList'):
                temp_model = AlertRuleConditionCompareListValueLevelList()
                self.value_level_list.append(temp_model.from_map(k))
        if m.get('yoyTimeUnit') is not None:
            self.yoy_time_unit = m.get('yoyTimeUnit')
        if m.get('yoyTimeValue') is not None:
            self.yoy_time_value = m.get('yoyTimeValue')
        return self


class AlertRuleCondition(TeaModel):
    def __init__(
        self,
        alert_count: int = None,
        case_list: List[AlertRuleConditionCaseList] = None,
        compare_list: List[AlertRuleConditionCompareList] = None,
        no_data_append_value: str = None,
        nodata_alert_level: str = None,
        relation: str = None,
        type: str = None,
    ):
        # type=SLS_CONDITION时指定，满足条件几次后告警，默认为1
        self.alert_count = alert_count
        # type=SLS_CONDITION时指定
        self.case_list = case_list
        self.compare_list = compare_list
        self.no_data_append_value = no_data_append_value
        # 无数据时按什么级别告警，不指定则不对无数据报警
        self.nodata_alert_level = nodata_alert_level
        self.relation = relation
        # 规则条件类型，可选值：SLS_CONDITION
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.case_list:
            for k in self.case_list:
                if k:
                    k.validate()
        if self.compare_list:
            for k in self.compare_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_count is not None:
            result['alertCount'] = self.alert_count
        result['caseList'] = []
        if self.case_list is not None:
            for k in self.case_list:
                result['caseList'].append(k.to_map() if k else None)
        result['compareList'] = []
        if self.compare_list is not None:
            for k in self.compare_list:
                result['compareList'].append(k.to_map() if k else None)
        if self.no_data_append_value is not None:
            result['noDataAppendValue'] = self.no_data_append_value
        if self.nodata_alert_level is not None:
            result['nodataAlertLevel'] = self.nodata_alert_level
        if self.relation is not None:
            result['relation'] = self.relation
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertCount') is not None:
            self.alert_count = m.get('alertCount')
        self.case_list = []
        if m.get('caseList') is not None:
            for k in m.get('caseList'):
                temp_model = AlertRuleConditionCaseList()
                self.case_list.append(temp_model.from_map(k))
        self.compare_list = []
        if m.get('compareList') is not None:
            for k in m.get('compareList'):
                temp_model = AlertRuleConditionCompareList()
                self.compare_list.append(temp_model.from_map(k))
        if m.get('noDataAppendValue') is not None:
            self.no_data_append_value = m.get('noDataAppendValue')
        if m.get('nodataAlertLevel') is not None:
            self.nodata_alert_level = m.get('nodataAlertLevel')
        if m.get('relation') is not None:
            self.relation = m.get('relation')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class AlertRuleDataSourceDsList(TeaModel):
    def __init__(
        self,
        project: str = None,
        region_id: str = None,
        store: str = None,
        type: str = None,
    ):
        self.project = project
        self.region_id = region_id
        self.store = store
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project is not None:
            result['project'] = self.project
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.store is not None:
            result['store'] = self.store
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('project') is not None:
            self.project = m.get('project')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('store') is not None:
            self.store = m.get('store')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class AlertRuleDataSource(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        ds_list: List[AlertRuleDataSourceDsList] = None,
        instance_id: str = None,
        namespace: str = None,
        region_id: str = None,
        type: str = None,
    ):
        self.app_type = app_type
        self.ds_list = ds_list
        # 实例id，当type=PROMETHEUS_DS/ENTERPRISE_DS时必填，为prometheus实例的clusterId或指标仓库名称
        self.instance_id = instance_id
        self.namespace = namespace
        self.region_id = region_id
        # 数据源类型
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.ds_list:
            for k in self.ds_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['appType'] = self.app_type
        result['dsList'] = []
        if self.ds_list is not None:
            for k in self.ds_list:
                result['dsList'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['instanceId'] = self.instance_id
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appType') is not None:
            self.app_type = m.get('appType')
        self.ds_list = []
        if m.get('dsList') is not None:
            for k in m.get('dsList'):
                temp_model = AlertRuleDataSourceDsList()
                self.ds_list.append(temp_model.from_map(k))
        if m.get('instanceId') is not None:
            self.instance_id = m.get('instanceId')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class AlertRuleLabelFilter(TeaModel):
    def __init__(
        self,
        labels: Dict[str, str] = None,
        opt: str = None,
    ):
        self.labels = labels
        self.opt = opt

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.labels is not None:
            result['labels'] = self.labels
        if self.opt is not None:
            result['opt'] = self.opt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('opt') is not None:
            self.opt = m.get('opt')
        return self


class AlertRuleTimeSpan(TeaModel):
    def __init__(
        self,
        day_of_week: List[int] = None,
        end_time: str = None,
        gmt_offset: str = None,
        start_time: str = None,
    ):
        self.day_of_week = day_of_week
        self.end_time = end_time
        self.gmt_offset = gmt_offset
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.day_of_week is not None:
            result['dayOfWeek'] = self.day_of_week
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.gmt_offset is not None:
            result['gmtOffset'] = self.gmt_offset
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dayOfWeek') is not None:
            self.day_of_week = m.get('dayOfWeek')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('gmtOffset') is not None:
            self.gmt_offset = m.get('gmtOffset')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class AlertRuleNotification(TeaModel):
    def __init__(
        self,
        contacts: List[str] = None,
        custom_webhooks: List[str] = None,
        ding_webhooks: List[str] = None,
        fs_webhooks: List[str] = None,
        groups: List[str] = None,
        notify_time: AlertRuleTimeSpan = None,
        silence_time: int = None,
        slack_webhooks: List[str] = None,
        version: str = None,
        wx_webhooks: List[str] = None,
    ):
        self.contacts = contacts
        self.custom_webhooks = custom_webhooks
        self.ding_webhooks = ding_webhooks
        self.fs_webhooks = fs_webhooks
        self.groups = groups
        self.notify_time = notify_time
        self.silence_time = silence_time
        self.slack_webhooks = slack_webhooks
        self.version = version
        self.wx_webhooks = wx_webhooks

    def validate(self):
        if self.notify_time:
            self.notify_time.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contacts is not None:
            result['contacts'] = self.contacts
        if self.custom_webhooks is not None:
            result['customWebhooks'] = self.custom_webhooks
        if self.ding_webhooks is not None:
            result['dingWebhooks'] = self.ding_webhooks
        if self.fs_webhooks is not None:
            result['fsWebhooks'] = self.fs_webhooks
        if self.groups is not None:
            result['groups'] = self.groups
        if self.notify_time is not None:
            result['notifyTime'] = self.notify_time.to_map()
        if self.silence_time is not None:
            result['silenceTime'] = self.silence_time
        if self.slack_webhooks is not None:
            result['slackWebhooks'] = self.slack_webhooks
        if self.version is not None:
            result['version'] = self.version
        if self.wx_webhooks is not None:
            result['wxWebhooks'] = self.wx_webhooks
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contacts') is not None:
            self.contacts = m.get('contacts')
        if m.get('customWebhooks') is not None:
            self.custom_webhooks = m.get('customWebhooks')
        if m.get('dingWebhooks') is not None:
            self.ding_webhooks = m.get('dingWebhooks')
        if m.get('fsWebhooks') is not None:
            self.fs_webhooks = m.get('fsWebhooks')
        if m.get('groups') is not None:
            self.groups = m.get('groups')
        if m.get('notifyTime') is not None:
            temp_model = AlertRuleTimeSpan()
            self.notify_time = temp_model.from_map(m['notifyTime'])
        if m.get('silenceTime') is not None:
            self.silence_time = m.get('silenceTime')
        if m.get('slackWebhooks') is not None:
            self.slack_webhooks = m.get('slackWebhooks')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('wxWebhooks') is not None:
            self.wx_webhooks = m.get('wxWebhooks')
        return self


class AlertRuleNotificationFilter(TeaModel):
    def __init__(
        self,
        contacts: List[str] = None,
        custom_webhooks: List[str] = None,
        ding_webhooks: List[str] = None,
        fs_webhooks: List[str] = None,
        groups: List[str] = None,
        slack_webhooks: List[str] = None,
        wx_webhooks: List[str] = None,
    ):
        self.contacts = contacts
        self.custom_webhooks = custom_webhooks
        self.ding_webhooks = ding_webhooks
        self.fs_webhooks = fs_webhooks
        self.groups = groups
        self.slack_webhooks = slack_webhooks
        self.wx_webhooks = wx_webhooks

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contacts is not None:
            result['contacts'] = self.contacts
        if self.custom_webhooks is not None:
            result['customWebhooks'] = self.custom_webhooks
        if self.ding_webhooks is not None:
            result['dingWebhooks'] = self.ding_webhooks
        if self.fs_webhooks is not None:
            result['fsWebhooks'] = self.fs_webhooks
        if self.groups is not None:
            result['groups'] = self.groups
        if self.slack_webhooks is not None:
            result['slackWebhooks'] = self.slack_webhooks
        if self.wx_webhooks is not None:
            result['wxWebhooks'] = self.wx_webhooks
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contacts') is not None:
            self.contacts = m.get('contacts')
        if m.get('customWebhooks') is not None:
            self.custom_webhooks = m.get('customWebhooks')
        if m.get('dingWebhooks') is not None:
            self.ding_webhooks = m.get('dingWebhooks')
        if m.get('fsWebhooks') is not None:
            self.fs_webhooks = m.get('fsWebhooks')
        if m.get('groups') is not None:
            self.groups = m.get('groups')
        if m.get('slackWebhooks') is not None:
            self.slack_webhooks = m.get('slackWebhooks')
        if m.get('wxWebhooks') is not None:
            self.wx_webhooks = m.get('wxWebhooks')
        return self


class AlertRuleQueryQueriesApmFilters(TeaModel):
    def __init__(
        self,
        dim: str = None,
        type: str = None,
        value: str = None,
    ):
        self.dim = dim
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dim is not None:
            result['dim'] = self.dim
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dim') is not None:
            self.dim = m.get('dim')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class AlertRuleQueryQueries(TeaModel):
    def __init__(
        self,
        apm_alert_metric_id: str = None,
        apm_filters: List[AlertRuleQueryQueriesApmFilters] = None,
        apm_group_by: List[str] = None,
        duration: int = None,
        end: int = None,
        expr: str = None,
        start: int = None,
        time_unit: str = None,
        window: int = None,
    ):
        self.apm_alert_metric_id = apm_alert_metric_id
        self.apm_filters = apm_filters
        self.apm_group_by = apm_group_by
        self.duration = duration
        # 时间偏移结束时间(相对)，如果指定了start、end，则不指定window。
        self.end = end
        # 查询表达式
        self.expr = expr
        # sls查询的时间偏移开始时间(相对)，如果指定了start、end，则不指定window。  例如：start=15， timeUnit=minute，表示15分钟前
        self.start = start
        # start和end、window的时间单位： day/hour/minute/second
        self.time_unit = time_unit
        # 整点时间查询区间。  如果指定了window则不指定start、end
        self.window = window

    def validate(self):
        if self.apm_filters:
            for k in self.apm_filters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apm_alert_metric_id is not None:
            result['apmAlertMetricId'] = self.apm_alert_metric_id
        result['apmFilters'] = []
        if self.apm_filters is not None:
            for k in self.apm_filters:
                result['apmFilters'].append(k.to_map() if k else None)
        if self.apm_group_by is not None:
            result['apmGroupBy'] = self.apm_group_by
        if self.duration is not None:
            result['duration'] = self.duration
        if self.end is not None:
            result['end'] = self.end
        if self.expr is not None:
            result['expr'] = self.expr
        if self.start is not None:
            result['start'] = self.start
        if self.time_unit is not None:
            result['timeUnit'] = self.time_unit
        if self.window is not None:
            result['window'] = self.window
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('apmAlertMetricId') is not None:
            self.apm_alert_metric_id = m.get('apmAlertMetricId')
        self.apm_filters = []
        if m.get('apmFilters') is not None:
            for k in m.get('apmFilters'):
                temp_model = AlertRuleQueryQueriesApmFilters()
                self.apm_filters.append(temp_model.from_map(k))
        if m.get('apmGroupBy') is not None:
            self.apm_group_by = m.get('apmGroupBy')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('end') is not None:
            self.end = m.get('end')
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('start') is not None:
            self.start = m.get('start')
        if m.get('timeUnit') is not None:
            self.time_unit = m.get('timeUnit')
        if m.get('window') is not None:
            self.window = m.get('window')
        return self


class AlertRuleSlsQueryJoinConditions(TeaModel):
    def __init__(
        self,
        first_field: str = None,
        oper: str = None,
        second_field: str = None,
    ):
        # 条件的左操作参数，格式为$<query_idx>.<结果集字段名>
        self.first_field = first_field
        # <, >, ==, !=, <=, >=\
        self.oper = oper
        # 条件的右操作参数，格式为$<query_idx>.<结果集字段名>
        self.second_field = second_field

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_field is not None:
            result['firstField'] = self.first_field
        if self.oper is not None:
            result['oper'] = self.oper
        if self.second_field is not None:
            result['secondField'] = self.second_field
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('firstField') is not None:
            self.first_field = m.get('firstField')
        if m.get('oper') is not None:
            self.oper = m.get('oper')
        if m.get('secondField') is not None:
            self.second_field = m.get('secondField')
        return self


class AlertRuleSlsQueryJoin(TeaModel):
    def __init__(
        self,
        conditions: List[AlertRuleSlsQueryJoinConditions] = None,
        type: str = None,
    ):
        self.conditions = conditions
        # 集合操作类型。
        #   ● CrossJoin： 笛卡尔积
        #   ● FullJoin：全联
        #   ● InnerJoin：内联
        #   ● LeftExclude： 左斥
        #   ● RightExclude：右斥
        #   ● LeftJoin：左联
        #   ● RightJoin：右联
        #   ● NoJoin：不合并
        #   ● Concat： 拼接
        #   https://help.aliyun.com/zh/sls/user-guide/set-query-statistics-statement
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = AlertRuleSlsQueryJoinConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class AlertRuleQuery(TeaModel):
    def __init__(
        self,
        check_after_data_complete: bool = None,
        duration: int = None,
        expr: str = None,
        first_join: AlertRuleSlsQueryJoin = None,
        group_field_list: List[str] = None,
        group_type: str = None,
        queries: List[AlertRuleQueryQueries] = None,
        second_join: AlertRuleSlsQueryJoin = None,
        type: str = None,
    ):
        self.check_after_data_complete = check_after_data_complete
        self.duration = duration
        self.expr = expr
        self.first_join = first_join
        self.group_field_list = group_field_list
        self.group_type = group_type
        self.queries = queries
        self.second_join = second_join
        # 查询类型
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.first_join:
            self.first_join.validate()
        if self.queries:
            for k in self.queries:
                if k:
                    k.validate()
        if self.second_join:
            self.second_join.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_after_data_complete is not None:
            result['checkAfterDataComplete'] = self.check_after_data_complete
        if self.duration is not None:
            result['duration'] = self.duration
        if self.expr is not None:
            result['expr'] = self.expr
        if self.first_join is not None:
            result['firstJoin'] = self.first_join.to_map()
        if self.group_field_list is not None:
            result['groupFieldList'] = self.group_field_list
        if self.group_type is not None:
            result['groupType'] = self.group_type
        result['queries'] = []
        if self.queries is not None:
            for k in self.queries:
                result['queries'].append(k.to_map() if k else None)
        if self.second_join is not None:
            result['secondJoin'] = self.second_join.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('checkAfterDataComplete') is not None:
            self.check_after_data_complete = m.get('checkAfterDataComplete')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('firstJoin') is not None:
            temp_model = AlertRuleSlsQueryJoin()
            self.first_join = temp_model.from_map(m['firstJoin'])
        if m.get('groupFieldList') is not None:
            self.group_field_list = m.get('groupFieldList')
        if m.get('groupType') is not None:
            self.group_type = m.get('groupType')
        self.queries = []
        if m.get('queries') is not None:
            for k in m.get('queries'):
                temp_model = AlertRuleQueryQueries()
                self.queries.append(temp_model.from_map(k))
        if m.get('secondJoin') is not None:
            temp_model = AlertRuleSlsQueryJoin()
            self.second_join = temp_model.from_map(m['secondJoin'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class AlertRuleSend(TeaModel):
    def __init__(
        self,
        action: AlertRuleAction = None,
        notification: AlertRuleNotification = None,
    ):
        self.action = action
        self.notification = notification

    def validate(self):
        if self.action:
            self.action.validate()
        if self.notification:
            self.notification.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['action'] = self.action.to_map()
        if self.notification is not None:
            result['notification'] = self.notification.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action') is not None:
            temp_model = AlertRuleAction()
            self.action = temp_model.from_map(m['action'])
        if m.get('notification') is not None:
            temp_model = AlertRuleNotification()
            self.notification = temp_model.from_map(m['notification'])
        return self


class BizTraceConfig(TeaModel):
    def __init__(
        self,
        advanced_config: str = None,
        biz_trace_code: str = None,
        biz_trace_id: str = None,
        biz_trace_name: str = None,
        create_time: str = None,
        region_id: str = None,
        rule_config: str = None,
        workspace: str = None,
    ):
        self.advanced_config = advanced_config
        self.biz_trace_code = biz_trace_code
        self.biz_trace_id = biz_trace_id
        self.biz_trace_name = biz_trace_name
        self.create_time = create_time
        self.region_id = region_id
        self.rule_config = rule_config
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advanced_config is not None:
            result['advancedConfig'] = self.advanced_config
        if self.biz_trace_code is not None:
            result['bizTraceCode'] = self.biz_trace_code
        if self.biz_trace_id is not None:
            result['bizTraceId'] = self.biz_trace_id
        if self.biz_trace_name is not None:
            result['bizTraceName'] = self.biz_trace_name
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.rule_config is not None:
            result['ruleConfig'] = self.rule_config
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('advancedConfig') is not None:
            self.advanced_config = m.get('advancedConfig')
        if m.get('bizTraceCode') is not None:
            self.biz_trace_code = m.get('bizTraceCode')
        if m.get('bizTraceId') is not None:
            self.biz_trace_id = m.get('bizTraceId')
        if m.get('bizTraceName') is not None:
            self.biz_trace_name = m.get('bizTraceName')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('ruleConfig') is not None:
            self.rule_config = m.get('ruleConfig')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DataStorageItem(TeaModel):
    def __init__(
        self,
        data_type: str = None,
        project: str = None,
        region_id: str = None,
        store_name: str = None,
        store_type: str = None,
    ):
        self.data_type = data_type
        self.project = project
        self.region_id = region_id
        self.store_name = store_name
        self.store_type = store_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_type is not None:
            result['dataType'] = self.data_type
        if self.project is not None:
            result['project'] = self.project
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.store_name is not None:
            result['storeName'] = self.store_name
        if self.store_type is not None:
            result['storeType'] = self.store_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dataType') is not None:
            self.data_type = m.get('dataType')
        if m.get('project') is not None:
            self.project = m.get('project')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('storeName') is not None:
            self.store_name = m.get('storeName')
        if m.get('storeType') is not None:
            self.store_type = m.get('storeType')
        return self


class EscalationEscalations(TeaModel):
    def __init__(
        self,
        contact_groups: List[str] = None,
        contacts: List[str] = None,
        escalate_min: int = None,
        robots: List[str] = None,
        webhooks: List[str] = None,
    ):
        self.contact_groups = contact_groups
        self.contacts = contacts
        self.escalate_min = escalate_min
        self.robots = robots
        self.webhooks = webhooks

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_groups is not None:
            result['contactGroups'] = self.contact_groups
        if self.contacts is not None:
            result['contacts'] = self.contacts
        if self.escalate_min is not None:
            result['escalateMin'] = self.escalate_min
        if self.robots is not None:
            result['robots'] = self.robots
        if self.webhooks is not None:
            result['webhooks'] = self.webhooks
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactGroups') is not None:
            self.contact_groups = m.get('contactGroups')
        if m.get('contacts') is not None:
            self.contacts = m.get('contacts')
        if m.get('escalateMin') is not None:
            self.escalate_min = m.get('escalateMin')
        if m.get('robots') is not None:
            self.robots = m.get('robots')
        if m.get('webhooks') is not None:
            self.webhooks = m.get('webhooks')
        return self


class Escalation(TeaModel):
    def __init__(
        self,
        description: str = None,
        escalations: List[EscalationEscalations] = None,
        name: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.escalations = escalations
        # This parameter is required.
        self.name = name

    def validate(self):
        if self.escalations:
            for k in self.escalations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        result['escalations'] = []
        if self.escalations is not None:
            for k in self.escalations:
                result['escalations'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        self.escalations = []
        if m.get('escalations') is not None:
            for k in m.get('escalations'):
                temp_model = EscalationEscalations()
                self.escalations.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class EscalationForUpdateEscalations(TeaModel):
    def __init__(
        self,
        contact_groups: List[str] = None,
        contacts: List[str] = None,
        ding_robots: List[str] = None,
        escalate_min: int = None,
        feishu_robots: List[str] = None,
        slack_robots: List[str] = None,
        webhooks: List[str] = None,
        weixin_robots: List[str] = None,
    ):
        self.contact_groups = contact_groups
        self.contacts = contacts
        self.ding_robots = ding_robots
        self.escalate_min = escalate_min
        self.feishu_robots = feishu_robots
        self.slack_robots = slack_robots
        self.webhooks = webhooks
        self.weixin_robots = weixin_robots

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_groups is not None:
            result['contactGroups'] = self.contact_groups
        if self.contacts is not None:
            result['contacts'] = self.contacts
        if self.ding_robots is not None:
            result['dingRobots'] = self.ding_robots
        if self.escalate_min is not None:
            result['escalateMin'] = self.escalate_min
        if self.feishu_robots is not None:
            result['feishuRobots'] = self.feishu_robots
        if self.slack_robots is not None:
            result['slackRobots'] = self.slack_robots
        if self.webhooks is not None:
            result['webhooks'] = self.webhooks
        if self.weixin_robots is not None:
            result['weixinRobots'] = self.weixin_robots
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactGroups') is not None:
            self.contact_groups = m.get('contactGroups')
        if m.get('contacts') is not None:
            self.contacts = m.get('contacts')
        if m.get('dingRobots') is not None:
            self.ding_robots = m.get('dingRobots')
        if m.get('escalateMin') is not None:
            self.escalate_min = m.get('escalateMin')
        if m.get('feishuRobots') is not None:
            self.feishu_robots = m.get('feishuRobots')
        if m.get('slackRobots') is not None:
            self.slack_robots = m.get('slackRobots')
        if m.get('webhooks') is not None:
            self.webhooks = m.get('webhooks')
        if m.get('weixinRobots') is not None:
            self.weixin_robots = m.get('weixinRobots')
        return self


class EscalationForUpdate(TeaModel):
    def __init__(
        self,
        description: str = None,
        escalations: List[EscalationForUpdateEscalations] = None,
        name: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.escalations = escalations
        # This parameter is required.
        self.name = name

    def validate(self):
        if self.escalations:
            for k in self.escalations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        result['escalations'] = []
        if self.escalations is not None:
            for k in self.escalations:
                result['escalations'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        self.escalations = []
        if m.get('escalations') is not None:
            for k in m.get('escalations'):
                temp_model = EscalationForUpdateEscalations()
                self.escalations.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class EscalationForViewEscalations(TeaModel):
    def __init__(
        self,
        contact_groups: List[str] = None,
        contacts: List[str] = None,
        escalate_min: int = None,
        robots: List[str] = None,
        webhooks: List[str] = None,
    ):
        self.contact_groups = contact_groups
        self.contacts = contacts
        self.escalate_min = escalate_min
        self.robots = robots
        self.webhooks = webhooks

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_groups is not None:
            result['contactGroups'] = self.contact_groups
        if self.contacts is not None:
            result['contacts'] = self.contacts
        if self.escalate_min is not None:
            result['escalateMin'] = self.escalate_min
        if self.robots is not None:
            result['robots'] = self.robots
        if self.webhooks is not None:
            result['webhooks'] = self.webhooks
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactGroups') is not None:
            self.contact_groups = m.get('contactGroups')
        if m.get('contacts') is not None:
            self.contacts = m.get('contacts')
        if m.get('escalateMin') is not None:
            self.escalate_min = m.get('escalateMin')
        if m.get('robots') is not None:
            self.robots = m.get('robots')
        if m.get('webhooks') is not None:
            self.webhooks = m.get('webhooks')
        return self


class EscalationForView(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        enable: bool = None,
        escalations: List[EscalationForViewEscalations] = None,
        name: str = None,
        update_time: str = None,
        user_id: str = None,
        uuid: str = None,
    ):
        self.create_time = create_time
        self.description = description
        self.enable = enable
        # This parameter is required.
        self.escalations = escalations
        # This parameter is required.
        self.name = name
        self.update_time = update_time
        self.user_id = user_id
        self.uuid = uuid

    def validate(self):
        if self.escalations:
            for k in self.escalations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.enable is not None:
            result['enable'] = self.enable
        result['escalations'] = []
        if self.escalations is not None:
            for k in self.escalations:
                result['escalations'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        self.escalations = []
        if m.get('escalations') is not None:
            for k in m.get('escalations'):
                temp_model = EscalationForViewEscalations()
                self.escalations.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class IncidentContactStruct(TeaModel):
    def __init__(
        self,
        channel: List[str] = None,
        contact_id: str = None,
        contact_type: str = None,
    ):
        self.channel = channel
        self.contact_id = contact_id
        self.contact_type = contact_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel is not None:
            result['channel'] = self.channel
        if self.contact_id is not None:
            result['contactId'] = self.contact_id
        if self.contact_type is not None:
            result['contactType'] = self.contact_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('channel') is not None:
            self.channel = m.get('channel')
        if m.get('contactId') is not None:
            self.contact_id = m.get('contactId')
        if m.get('contactType') is not None:
            self.contact_type = m.get('contactType')
        return self


class IncidentEscalationStageStruct(TeaModel):
    def __init__(
        self,
        contact: List[IncidentContactStruct] = None,
        cycle_notify_count: str = None,
        cycle_notify_time: str = None,
        description: str = None,
        effect_time: str = None,
        name: str = None,
        stage_index: str = None,
        time_zone: str = None,
        wait_to_next_stage_time: str = None,
    ):
        self.contact = contact
        self.cycle_notify_count = cycle_notify_count
        self.cycle_notify_time = cycle_notify_time
        self.description = description
        self.effect_time = effect_time
        self.name = name
        self.stage_index = stage_index
        self.time_zone = time_zone
        self.wait_to_next_stage_time = wait_to_next_stage_time

    def validate(self):
        if self.contact:
            for k in self.contact:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['contact'] = []
        if self.contact is not None:
            for k in self.contact:
                result['contact'].append(k.to_map() if k else None)
        if self.cycle_notify_count is not None:
            result['cycleNotifyCount'] = self.cycle_notify_count
        if self.cycle_notify_time is not None:
            result['cycleNotifyTime'] = self.cycle_notify_time
        if self.description is not None:
            result['description'] = self.description
        if self.effect_time is not None:
            result['effectTime'] = self.effect_time
        if self.name is not None:
            result['name'] = self.name
        if self.stage_index is not None:
            result['stageIndex'] = self.stage_index
        if self.time_zone is not None:
            result['timeZone'] = self.time_zone
        if self.wait_to_next_stage_time is not None:
            result['waitToNextStageTime'] = self.wait_to_next_stage_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.contact = []
        if m.get('contact') is not None:
            for k in m.get('contact'):
                temp_model = IncidentContactStruct()
                self.contact.append(temp_model.from_map(k))
        if m.get('cycleNotifyCount') is not None:
            self.cycle_notify_count = m.get('cycleNotifyCount')
        if m.get('cycleNotifyTime') is not None:
            self.cycle_notify_time = m.get('cycleNotifyTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('effectTime') is not None:
            self.effect_time = m.get('effectTime')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('stageIndex') is not None:
            self.stage_index = m.get('stageIndex')
        if m.get('timeZone') is not None:
            self.time_zone = m.get('timeZone')
        if m.get('waitToNextStageTime') is not None:
            self.wait_to_next_stage_time = m.get('waitToNextStageTime')
        return self


class IncidentEscalationStruct(TeaModel):
    def __init__(
        self,
        description: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        incident_escalation_id: str = None,
        name: str = None,
        stage: List[IncidentEscalationStageStruct] = None,
        user_id: int = None,
    ):
        self.description = description
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.incident_escalation_id = incident_escalation_id
        self.name = name
        self.stage = stage
        self.user_id = user_id

    def validate(self):
        if self.stage:
            for k in self.stage:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.incident_escalation_id is not None:
            result['incidentEscalationId'] = self.incident_escalation_id
        if self.name is not None:
            result['name'] = self.name
        result['stage'] = []
        if self.stage is not None:
            for k in self.stage:
                result['stage'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('incidentEscalationId') is not None:
            self.incident_escalation_id = m.get('incidentEscalationId')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.stage = []
        if m.get('stage') is not None:
            for k in m.get('stage'):
                temp_model = IncidentEscalationStageStruct()
                self.stage.append(temp_model.from_map(k))
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class IncidentEventStruct(TeaModel):
    def __init__(
        self,
        auto_recover_time: int = None,
        content: str = None,
        count: int = None,
        dimension: Dict[str, str] = None,
        group_by: Dict[str, str] = None,
        incident_event_id: str = None,
        incident_id: str = None,
        last_time: int = None,
        recover_time: int = None,
        resource: Dict[str, str] = None,
        status: int = None,
        time: str = None,
        title: str = None,
        user_id: str = None,
    ):
        self.auto_recover_time = auto_recover_time
        self.content = content
        self.count = count
        self.dimension = dimension
        self.group_by = group_by
        self.incident_event_id = incident_event_id
        self.incident_id = incident_id
        self.last_time = last_time
        self.recover_time = recover_time
        self.resource = resource
        self.status = status
        self.time = time
        self.title = title
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_recover_time is not None:
            result['autoRecoverTime'] = self.auto_recover_time
        if self.content is not None:
            result['content'] = self.content
        if self.count is not None:
            result['count'] = self.count
        if self.dimension is not None:
            result['dimension'] = self.dimension
        if self.group_by is not None:
            result['groupBy'] = self.group_by
        if self.incident_event_id is not None:
            result['incidentEventId'] = self.incident_event_id
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        if self.last_time is not None:
            result['lastTime'] = self.last_time
        if self.recover_time is not None:
            result['recoverTime'] = self.recover_time
        if self.resource is not None:
            result['resource'] = self.resource
        if self.status is not None:
            result['status'] = self.status
        if self.time is not None:
            result['time'] = self.time
        if self.title is not None:
            result['title'] = self.title
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('autoRecoverTime') is not None:
            self.auto_recover_time = m.get('autoRecoverTime')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('dimension') is not None:
            self.dimension = m.get('dimension')
        if m.get('groupBy') is not None:
            self.group_by = m.get('groupBy')
        if m.get('incidentEventId') is not None:
            self.incident_event_id = m.get('incidentEventId')
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        if m.get('lastTime') is not None:
            self.last_time = m.get('lastTime')
        if m.get('recoverTime') is not None:
            self.recover_time = m.get('recoverTime')
        if m.get('resource') is not None:
            self.resource = m.get('resource')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('time') is not None:
            self.time = m.get('time')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class IncidentMemberStructAcknowledge(TeaModel):
    def __init__(
        self,
        break_level: str = None,
        verify_time: int = None,
    ):
        self.break_level = break_level
        self.verify_time = verify_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.break_level is not None:
            result['breakLevel'] = self.break_level
        if self.verify_time is not None:
            result['verifyTime'] = self.verify_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('breakLevel') is not None:
            self.break_level = m.get('breakLevel')
        if m.get('verifyTime') is not None:
            self.verify_time = m.get('verifyTime')
        return self


class IncidentMemberStructContacts(TeaModel):
    def __init__(
        self,
        channel: str = None,
        contact_mask: str = None,
    ):
        self.channel = channel
        self.contact_mask = contact_mask

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel is not None:
            result['channel'] = self.channel
        if self.contact_mask is not None:
            result['contactMask'] = self.contact_mask
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('channel') is not None:
            self.channel = m.get('channel')
        if m.get('contactMask') is not None:
            self.contact_mask = m.get('contactMask')
        return self


class IncidentMemberStructEscalation(TeaModel):
    def __init__(
        self,
        description: str = None,
        incident_escalation_id: str = None,
        name: str = None,
        stage_index: str = None,
        title: str = None,
    ):
        self.description = description
        self.incident_escalation_id = incident_escalation_id
        self.name = name
        self.stage_index = stage_index
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.incident_escalation_id is not None:
            result['incidentEscalationId'] = self.incident_escalation_id
        if self.name is not None:
            result['name'] = self.name
        if self.stage_index is not None:
            result['stageIndex'] = self.stage_index
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('incidentEscalationId') is not None:
            self.incident_escalation_id = m.get('incidentEscalationId')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('stageIndex') is not None:
            self.stage_index = m.get('stageIndex')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class IncidentMemberStructScheduleGroup(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        name: str = None,
    ):
        self.contact_id = contact_id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['contactId'] = self.contact_id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactId') is not None:
            self.contact_id = m.get('contactId')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class IncidentMemberStruct(TeaModel):
    def __init__(
        self,
        acknowledge: IncidentMemberStructAcknowledge = None,
        contact_id: str = None,
        contacts: List[IncidentMemberStructContacts] = None,
        escalation: IncidentMemberStructEscalation = None,
        incident_id: str = None,
        incident_member_id: str = None,
        schedule_group: IncidentMemberStructScheduleGroup = None,
        time: int = None,
        user_id: int = None,
    ):
        self.acknowledge = acknowledge
        self.contact_id = contact_id
        self.contacts = contacts
        self.escalation = escalation
        self.incident_id = incident_id
        self.incident_member_id = incident_member_id
        self.schedule_group = schedule_group
        self.time = time
        self.user_id = user_id

    def validate(self):
        if self.acknowledge:
            self.acknowledge.validate()
        if self.contacts:
            for k in self.contacts:
                if k:
                    k.validate()
        if self.escalation:
            self.escalation.validate()
        if self.schedule_group:
            self.schedule_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acknowledge is not None:
            result['acknowledge'] = self.acknowledge.to_map()
        if self.contact_id is not None:
            result['contactId'] = self.contact_id
        result['contacts'] = []
        if self.contacts is not None:
            for k in self.contacts:
                result['contacts'].append(k.to_map() if k else None)
        if self.escalation is not None:
            result['escalation'] = self.escalation.to_map()
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        if self.incident_member_id is not None:
            result['incidentMemberId'] = self.incident_member_id
        if self.schedule_group is not None:
            result['scheduleGroup'] = self.schedule_group.to_map()
        if self.time is not None:
            result['time'] = self.time
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('acknowledge') is not None:
            temp_model = IncidentMemberStructAcknowledge()
            self.acknowledge = temp_model.from_map(m['acknowledge'])
        if m.get('contactId') is not None:
            self.contact_id = m.get('contactId')
        self.contacts = []
        if m.get('contacts') is not None:
            for k in m.get('contacts'):
                temp_model = IncidentMemberStructContacts()
                self.contacts.append(temp_model.from_map(k))
        if m.get('escalation') is not None:
            temp_model = IncidentMemberStructEscalation()
            self.escalation = temp_model.from_map(m['escalation'])
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        if m.get('incidentMemberId') is not None:
            self.incident_member_id = m.get('incidentMemberId')
        if m.get('scheduleGroup') is not None:
            temp_model = IncidentMemberStructScheduleGroup()
            self.schedule_group = temp_model.from_map(m['scheduleGroup'])
        if m.get('time') is not None:
            self.time = m.get('time')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class IncidentNoteStruct(TeaModel):
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class IncidentPlanCorporationStruct(TeaModel):
    def __init__(
        self,
        channel: str = None,
        robot_id: str = None,
    ):
        self.channel = channel
        self.robot_id = robot_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel is not None:
            result['channel'] = self.channel
        if self.robot_id is not None:
            result['robotId'] = self.robot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('channel') is not None:
            self.channel = m.get('channel')
        if m.get('robotId') is not None:
            self.robot_id = m.get('robotId')
        return self


class IncidentPlanFieldPath(TeaModel):
    def __init__(
        self,
        field_alias: str = None,
        field_path: List[str] = None,
    ):
        self.field_alias = field_alias
        self.field_path = field_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_alias is not None:
            result['fieldAlias'] = self.field_alias
        if self.field_path is not None:
            result['fieldPath'] = self.field_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldAlias') is not None:
            self.field_alias = m.get('fieldAlias')
        if m.get('fieldPath') is not None:
            self.field_path = m.get('fieldPath')
        return self


class IncidentPlanStruct(TeaModel):
    def __init__(
        self,
        auto_recover_seconds: int = None,
        close_expire: str = None,
        corporation: List[IncidentPlanCorporationStruct] = None,
        description: str = None,
        escalation_id: List[str] = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        group_by: List[IncidentPlanFieldPath] = None,
        incident_plan_id: str = None,
        name: str = None,
        resource_filed: List[IncidentPlanFieldPath] = None,
        status: str = None,
        user_id: int = None,
    ):
        self.auto_recover_seconds = auto_recover_seconds
        self.close_expire = close_expire
        self.corporation = corporation
        self.description = description
        self.escalation_id = escalation_id
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.group_by = group_by
        self.incident_plan_id = incident_plan_id
        self.name = name
        self.resource_filed = resource_filed
        self.status = status
        self.user_id = user_id

    def validate(self):
        if self.corporation:
            for k in self.corporation:
                if k:
                    k.validate()
        if self.group_by:
            for k in self.group_by:
                if k:
                    k.validate()
        if self.resource_filed:
            for k in self.resource_filed:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_recover_seconds is not None:
            result['autoRecoverSeconds'] = self.auto_recover_seconds
        if self.close_expire is not None:
            result['closeExpire'] = self.close_expire
        result['corporation'] = []
        if self.corporation is not None:
            for k in self.corporation:
                result['corporation'].append(k.to_map() if k else None)
        if self.description is not None:
            result['description'] = self.description
        if self.escalation_id is not None:
            result['escalationId'] = self.escalation_id
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        result['groupBy'] = []
        if self.group_by is not None:
            for k in self.group_by:
                result['groupBy'].append(k.to_map() if k else None)
        if self.incident_plan_id is not None:
            result['incidentPlanId'] = self.incident_plan_id
        if self.name is not None:
            result['name'] = self.name
        result['resourceFiled'] = []
        if self.resource_filed is not None:
            for k in self.resource_filed:
                result['resourceFiled'].append(k.to_map() if k else None)
        if self.status is not None:
            result['status'] = self.status
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('autoRecoverSeconds') is not None:
            self.auto_recover_seconds = m.get('autoRecoverSeconds')
        if m.get('closeExpire') is not None:
            self.close_expire = m.get('closeExpire')
        self.corporation = []
        if m.get('corporation') is not None:
            for k in m.get('corporation'):
                temp_model = IncidentPlanCorporationStruct()
                self.corporation.append(temp_model.from_map(k))
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('escalationId') is not None:
            self.escalation_id = m.get('escalationId')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        self.group_by = []
        if m.get('groupBy') is not None:
            for k in m.get('groupBy'):
                temp_model = IncidentPlanFieldPath()
                self.group_by.append(temp_model.from_map(k))
        if m.get('incidentPlanId') is not None:
            self.incident_plan_id = m.get('incidentPlanId')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.resource_filed = []
        if m.get('resourceFiled') is not None:
            for k in m.get('resourceFiled'):
                temp_model = IncidentPlanFieldPath()
                self.resource_filed.append(temp_model.from_map(k))
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class IncidentResourceDetail(TeaModel):
    def __init__(
        self,
        extra_id: str = None,
        resource_id: Dict[str, Any] = None,
        type: str = None,
    ):
        self.extra_id = extra_id
        self.resource_id = resource_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extra_id is not None:
            result['extraId'] = self.extra_id
        if self.resource_id is not None:
            result['resourceId'] = self.resource_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('extraId') is not None:
            self.extra_id = m.get('extraId')
        if m.get('resourceId') is not None:
            self.resource_id = m.get('resourceId')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class IncidentResourceStruct(TeaModel):
    def __init__(
        self,
        description: str = None,
        incident_id: str = None,
        incident_resource_id: str = None,
        resource: IncidentResourceDetail = None,
        source: str = None,
        time: int = None,
        user_id: int = None,
    ):
        self.description = description
        self.incident_id = incident_id
        self.incident_resource_id = incident_resource_id
        self.resource = resource
        self.source = source
        self.time = time
        self.user_id = user_id

    def validate(self):
        if self.resource:
            self.resource.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        if self.incident_resource_id is not None:
            result['incidentResourceId'] = self.incident_resource_id
        if self.resource is not None:
            result['resource'] = self.resource.to_map()
        if self.source is not None:
            result['source'] = self.source
        if self.time is not None:
            result['time'] = self.time
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        if m.get('incidentResourceId') is not None:
            self.incident_resource_id = m.get('incidentResourceId')
        if m.get('resource') is not None:
            temp_model = IncidentResourceDetail()
            self.resource = temp_model.from_map(m['resource'])
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('time') is not None:
            self.time = m.get('time')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class IncidentStrategyForView(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        enable: bool = None,
        name: str = None,
        response_plan_id: str = None,
        restore_mins: int = None,
        update_time: str = None,
        user_id: str = None,
        uuid: str = None,
        workspace: str = None,
    ):
        self.create_time = create_time
        self.description = description
        self.enable = enable
        # This parameter is required.
        self.name = name
        self.response_plan_id = response_plan_id
        self.restore_mins = restore_mins
        self.update_time = update_time
        self.user_id = user_id
        self.uuid = uuid
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.enable is not None:
            result['enable'] = self.enable
        if self.name is not None:
            result['name'] = self.name
        if self.response_plan_id is not None:
            result['responsePlanId'] = self.response_plan_id
        if self.restore_mins is not None:
            result['restoreMins'] = self.restore_mins
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('responsePlanId') is not None:
            self.response_plan_id = m.get('responsePlanId')
        if m.get('restoreMins') is not None:
            self.restore_mins = m.get('restoreMins')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class IncidentStruct(TeaModel):
    def __init__(
        self,
        content: str = None,
        escalations: List[IncidentEscalationStruct] = None,
        incident_id: str = None,
        incident_plan: IncidentPlanStruct = None,
        resource: IncidentResourceDetail = None,
        severity: str = None,
        status: str = None,
        time: int = None,
        title: str = None,
        user_id: str = None,
    ):
        self.content = content
        self.escalations = escalations
        self.incident_id = incident_id
        self.incident_plan = incident_plan
        self.resource = resource
        self.severity = severity
        self.status = status
        self.time = time
        self.title = title
        self.user_id = user_id

    def validate(self):
        if self.escalations:
            for k in self.escalations:
                if k:
                    k.validate()
        if self.incident_plan:
            self.incident_plan.validate()
        if self.resource:
            self.resource.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        result['escalations'] = []
        if self.escalations is not None:
            for k in self.escalations:
                result['escalations'].append(k.to_map() if k else None)
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        if self.incident_plan is not None:
            result['incidentPlan'] = self.incident_plan.to_map()
        if self.resource is not None:
            result['resource'] = self.resource.to_map()
        if self.severity is not None:
            result['severity'] = self.severity
        if self.status is not None:
            result['status'] = self.status
        if self.time is not None:
            result['time'] = self.time
        if self.title is not None:
            result['title'] = self.title
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        self.escalations = []
        if m.get('escalations') is not None:
            for k in m.get('escalations'):
                temp_model = IncidentEscalationStruct()
                self.escalations.append(temp_model.from_map(k))
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        if m.get('incidentPlan') is not None:
            temp_model = IncidentPlanStruct()
            self.incident_plan = temp_model.from_map(m['incidentPlan'])
        if m.get('resource') is not None:
            temp_model = IncidentResourceDetail()
            self.resource = temp_model.from_map(m['resource'])
        if m.get('severity') is not None:
            self.severity = m.get('severity')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('time') is not None:
            self.time = m.get('time')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class IncidentTimeline(TeaModel):
    def __init__(
        self,
        child_type: str = None,
        content: str = None,
        incident_id: str = None,
        incident_timeline_id: str = None,
        time: int = None,
        timeline_id: str = None,
        title: str = None,
        type: str = None,
        user_id: str = None,
    ):
        self.child_type = child_type
        self.content = content
        self.incident_id = incident_id
        self.incident_timeline_id = incident_timeline_id
        self.time = time
        self.timeline_id = timeline_id
        self.title = title
        self.type = type
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.child_type is not None:
            result['childType'] = self.child_type
        if self.content is not None:
            result['content'] = self.content
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        if self.incident_timeline_id is not None:
            result['incidentTimelineId'] = self.incident_timeline_id
        if self.time is not None:
            result['time'] = self.time
        if self.timeline_id is not None:
            result['timelineId'] = self.timeline_id
        if self.title is not None:
            result['title'] = self.title
        if self.type is not None:
            result['type'] = self.type
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('childType') is not None:
            self.child_type = m.get('childType')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        if m.get('incidentTimelineId') is not None:
            self.incident_timeline_id = m.get('incidentTimelineId')
        if m.get('time') is not None:
            self.time = m.get('time')
        if m.get('timelineId') is not None:
            self.timeline_id = m.get('timelineId')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class IntegrationFilterSettingConditions(TeaModel):
    def __init__(
        self,
        field: str = None,
        operator: str = None,
        value: str = None,
    ):
        self.field = field
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['field'] = self.field
        if self.operator is not None:
            result['operator'] = self.operator
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('field') is not None:
            self.field = m.get('field')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class IntegrationFilterSetting(TeaModel):
    def __init__(
        self,
        conditions: List[IntegrationFilterSettingConditions] = None,
        relation: str = None,
    ):
        self.conditions = conditions
        self.relation = relation

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.relation is not None:
            result['relation'] = self.relation
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = IntegrationFilterSettingConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('relation') is not None:
            self.relation = m.get('relation')
        return self


class Integration(TeaModel):
    def __init__(
        self,
        description: str = None,
        filter_setting: IntegrationFilterSetting = None,
        integration_setting: str = None,
        name: str = None,
        type: str = None,
    ):
        self.description = description
        self.filter_setting = filter_setting
        self.integration_setting = integration_setting
        # This parameter is required.
        self.name = name
        self.type = type

    def validate(self):
        if self.filter_setting:
            self.filter_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.integration_setting is not None:
            result['integrationSetting'] = self.integration_setting
        if self.name is not None:
            result['name'] = self.name
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('filterSetting') is not None:
            temp_model = IntegrationFilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('integrationSetting') is not None:
            self.integration_setting = m.get('integrationSetting')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class IntegrationForModify(TeaModel):
    def __init__(
        self,
        description: str = None,
        filter_setting: FilterSetting = None,
        integration_name: str = None,
        integration_setting: str = None,
        transformer_setting: List[TransformAction] = None,
        type: str = None,
    ):
        self.description = description
        self.filter_setting = filter_setting
        # This parameter is required.
        self.integration_name = integration_name
        self.integration_setting = integration_setting
        self.transformer_setting = transformer_setting
        self.type = type

    def validate(self):
        if self.filter_setting:
            self.filter_setting.validate()
        if self.transformer_setting:
            for k in self.transformer_setting:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.integration_name is not None:
            result['integrationName'] = self.integration_name
        if self.integration_setting is not None:
            result['integrationSetting'] = self.integration_setting
        result['transformerSetting'] = []
        if self.transformer_setting is not None:
            for k in self.transformer_setting:
                result['transformerSetting'].append(k.to_map() if k else None)
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('filterSetting') is not None:
            temp_model = FilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('integrationName') is not None:
            self.integration_name = m.get('integrationName')
        if m.get('integrationSetting') is not None:
            self.integration_setting = m.get('integrationSetting')
        self.transformer_setting = []
        if m.get('transformerSetting') is not None:
            for k in m.get('transformerSetting'):
                temp_model = TransformAction()
                self.transformer_setting.append(temp_model.from_map(k))
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class IntegrationForViewFilterSettingConditions(TeaModel):
    def __init__(
        self,
        field: str = None,
        operator: str = None,
        value: str = None,
    ):
        self.field = field
        self.operator = operator
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['field'] = self.field
        if self.operator is not None:
            result['operator'] = self.operator
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('field') is not None:
            self.field = m.get('field')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class IntegrationForViewFilterSetting(TeaModel):
    def __init__(
        self,
        conditions: List[IntegrationForViewFilterSettingConditions] = None,
        relation: str = None,
    ):
        self.conditions = conditions
        self.relation = relation

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.relation is not None:
            result['relation'] = self.relation
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = IntegrationForViewFilterSettingConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('relation') is not None:
            self.relation = m.get('relation')
        return self


class IntegrationForView(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        enable: bool = None,
        filter_setting: IntegrationForViewFilterSetting = None,
        integration_setting: str = None,
        name: str = None,
        owner_product: str = None,
        type: str = None,
        update_time: str = None,
        user_id: str = None,
        uuid: str = None,
        workspace: str = None,
    ):
        self.create_time = create_time
        self.description = description
        self.enable = enable
        self.filter_setting = filter_setting
        self.integration_setting = integration_setting
        # This parameter is required.
        self.name = name
        self.owner_product = owner_product
        self.type = type
        self.update_time = update_time
        self.user_id = user_id
        self.uuid = uuid
        self.workspace = workspace

    def validate(self):
        if self.filter_setting:
            self.filter_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.enable is not None:
            result['enable'] = self.enable
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.integration_setting is not None:
            result['integrationSetting'] = self.integration_setting
        if self.name is not None:
            result['name'] = self.name
        if self.owner_product is not None:
            result['ownerProduct'] = self.owner_product
        if self.type is not None:
            result['type'] = self.type
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('filterSetting') is not None:
            temp_model = IntegrationForViewFilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('integrationSetting') is not None:
            self.integration_setting = m.get('integrationSetting')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('ownerProduct') is not None:
            self.owner_product = m.get('ownerProduct')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class MaintainWindowForModifyEffectTimeRange(TeaModel):
    def __init__(
        self,
        day_in_week: List[int] = None,
        end_time_in_minute: int = None,
        start_time_in_minute: int = None,
        time_zone: str = None,
    ):
        self.day_in_week = day_in_week
        self.end_time_in_minute = end_time_in_minute
        self.start_time_in_minute = start_time_in_minute
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.day_in_week is not None:
            result['dayInWeek'] = self.day_in_week
        if self.end_time_in_minute is not None:
            result['endTimeInMinute'] = self.end_time_in_minute
        if self.start_time_in_minute is not None:
            result['startTimeInMinute'] = self.start_time_in_minute
        if self.time_zone is not None:
            result['timeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dayInWeek') is not None:
            self.day_in_week = m.get('dayInWeek')
        if m.get('endTimeInMinute') is not None:
            self.end_time_in_minute = m.get('endTimeInMinute')
        if m.get('startTimeInMinute') is not None:
            self.start_time_in_minute = m.get('startTimeInMinute')
        if m.get('timeZone') is not None:
            self.time_zone = m.get('timeZone')
        return self


class MaintainWindowForModify(TeaModel):
    def __init__(
        self,
        description: str = None,
        effect_time_range: MaintainWindowForModifyEffectTimeRange = None,
        effective: str = None,
        end_time: str = None,
        filter_setting: FilterSetting = None,
        maintain_window_name: str = None,
        start_time: str = None,
    ):
        self.description = description
        self.effect_time_range = effect_time_range
        self.effective = effective
        self.end_time = end_time
        self.filter_setting = filter_setting
        # This parameter is required.
        self.maintain_window_name = maintain_window_name
        self.start_time = start_time

    def validate(self):
        if self.effect_time_range:
            self.effect_time_range.validate()
        if self.filter_setting:
            self.filter_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.effect_time_range is not None:
            result['effectTimeRange'] = self.effect_time_range.to_map()
        if self.effective is not None:
            result['effective'] = self.effective
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.maintain_window_name is not None:
            result['maintainWindowName'] = self.maintain_window_name
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('effectTimeRange') is not None:
            temp_model = MaintainWindowForModifyEffectTimeRange()
            self.effect_time_range = temp_model.from_map(m['effectTimeRange'])
        if m.get('effective') is not None:
            self.effective = m.get('effective')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('filterSetting') is not None:
            temp_model = FilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('maintainWindowName') is not None:
            self.maintain_window_name = m.get('maintainWindowName')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class MaintainWindowForViewEffectTimeRange(TeaModel):
    def __init__(
        self,
        day_in_week: List[int] = None,
        end_time_in_minute: int = None,
        start_time_in_minute: int = None,
        time_zone: str = None,
    ):
        self.day_in_week = day_in_week
        self.end_time_in_minute = end_time_in_minute
        self.start_time_in_minute = start_time_in_minute
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.day_in_week is not None:
            result['dayInWeek'] = self.day_in_week
        if self.end_time_in_minute is not None:
            result['endTimeInMinute'] = self.end_time_in_minute
        if self.start_time_in_minute is not None:
            result['startTimeInMinute'] = self.start_time_in_minute
        if self.time_zone is not None:
            result['timeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dayInWeek') is not None:
            self.day_in_week = m.get('dayInWeek')
        if m.get('endTimeInMinute') is not None:
            self.end_time_in_minute = m.get('endTimeInMinute')
        if m.get('startTimeInMinute') is not None:
            self.start_time_in_minute = m.get('startTimeInMinute')
        if m.get('timeZone') is not None:
            self.time_zone = m.get('timeZone')
        return self


class MaintainWindowForView(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        effect_time_range: MaintainWindowForViewEffectTimeRange = None,
        effective: str = None,
        enable: bool = None,
        end_time: str = None,
        filter_setting: FilterSetting = None,
        maintain_window_id: str = None,
        maintain_window_name: str = None,
        start_time: str = None,
        update_time: str = None,
        user_id: str = None,
        workspace: str = None,
    ):
        self.create_time = create_time
        self.description = description
        self.effect_time_range = effect_time_range
        self.effective = effective
        self.enable = enable
        self.end_time = end_time
        self.filter_setting = filter_setting
        self.maintain_window_id = maintain_window_id
        # This parameter is required.
        self.maintain_window_name = maintain_window_name
        self.start_time = start_time
        self.update_time = update_time
        self.user_id = user_id
        self.workspace = workspace

    def validate(self):
        if self.effect_time_range:
            self.effect_time_range.validate()
        if self.filter_setting:
            self.filter_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.effect_time_range is not None:
            result['effectTimeRange'] = self.effect_time_range.to_map()
        if self.effective is not None:
            result['effective'] = self.effective
        if self.enable is not None:
            result['enable'] = self.enable
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.maintain_window_id is not None:
            result['maintainWindowId'] = self.maintain_window_id
        if self.maintain_window_name is not None:
            result['maintainWindowName'] = self.maintain_window_name
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('effectTimeRange') is not None:
            temp_model = MaintainWindowForViewEffectTimeRange()
            self.effect_time_range = temp_model.from_map(m['effectTimeRange'])
        if m.get('effective') is not None:
            self.effective = m.get('effective')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('filterSetting') is not None:
            temp_model = FilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('maintainWindowId') is not None:
            self.maintain_window_id = m.get('maintainWindowId')
        if m.get('maintainWindowName') is not None:
            self.maintain_window_name = m.get('maintainWindowName')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class NotifyStrategyForModifyCustomTemplateEntries(TeaModel):
    def __init__(
        self,
        target_type: str = None,
        template_uuid: str = None,
    ):
        # This parameter is required.
        self.target_type = target_type
        # This parameter is required.
        self.template_uuid = template_uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_type is not None:
            result['targetType'] = self.target_type
        if self.template_uuid is not None:
            result['templateUuid'] = self.template_uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('targetType') is not None:
            self.target_type = m.get('targetType')
        if m.get('templateUuid') is not None:
            self.template_uuid = m.get('templateUuid')
        return self


class NotifyStrategyForModifyGroupingSetting(TeaModel):
    def __init__(
        self,
        grouping_keys: List[str] = None,
        period_min: int = None,
        silence_sec: int = None,
        times: int = None,
    ):
        self.grouping_keys = grouping_keys
        self.period_min = period_min
        self.silence_sec = silence_sec
        self.times = times

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grouping_keys is not None:
            result['groupingKeys'] = self.grouping_keys
        if self.period_min is not None:
            result['periodMin'] = self.period_min
        if self.silence_sec is not None:
            result['silenceSec'] = self.silence_sec
        if self.times is not None:
            result['times'] = self.times
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('groupingKeys') is not None:
            self.grouping_keys = m.get('groupingKeys')
        if m.get('periodMin') is not None:
            self.period_min = m.get('periodMin')
        if m.get('silenceSec') is not None:
            self.silence_sec = m.get('silenceSec')
        if m.get('times') is not None:
            self.times = m.get('times')
        return self


class NotifyStrategyForModifyRoutesChannels(TeaModel):
    def __init__(
        self,
        channel_type: str = None,
        enabled_sub_channels: List[str] = None,
        receivers: List[str] = None,
    ):
        # This parameter is required.
        self.channel_type = channel_type
        self.enabled_sub_channels = enabled_sub_channels
        # This parameter is required.
        self.receivers = receivers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_type is not None:
            result['channelType'] = self.channel_type
        if self.enabled_sub_channels is not None:
            result['enabledSubChannels'] = self.enabled_sub_channels
        if self.receivers is not None:
            result['receivers'] = self.receivers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('channelType') is not None:
            self.channel_type = m.get('channelType')
        if m.get('enabledSubChannels') is not None:
            self.enabled_sub_channels = m.get('enabledSubChannels')
        if m.get('receivers') is not None:
            self.receivers = m.get('receivers')
        return self


class NotifyStrategyForModifyRoutesEffectTimeRange(TeaModel):
    def __init__(
        self,
        day_in_week: List[int] = None,
        end_time_in_minute: int = None,
        start_time_in_minute: int = None,
        time_zone: str = None,
    ):
        self.day_in_week = day_in_week
        self.end_time_in_minute = end_time_in_minute
        self.start_time_in_minute = start_time_in_minute
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.day_in_week is not None:
            result['dayInWeek'] = self.day_in_week
        if self.end_time_in_minute is not None:
            result['endTimeInMinute'] = self.end_time_in_minute
        if self.start_time_in_minute is not None:
            result['startTimeInMinute'] = self.start_time_in_minute
        if self.time_zone is not None:
            result['timeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dayInWeek') is not None:
            self.day_in_week = m.get('dayInWeek')
        if m.get('endTimeInMinute') is not None:
            self.end_time_in_minute = m.get('endTimeInMinute')
        if m.get('startTimeInMinute') is not None:
            self.start_time_in_minute = m.get('startTimeInMinute')
        if m.get('timeZone') is not None:
            self.time_zone = m.get('timeZone')
        return self


class NotifyStrategyForModifyRoutes(TeaModel):
    def __init__(
        self,
        channels: List[NotifyStrategyForModifyRoutesChannels] = None,
        effect_time_range: NotifyStrategyForModifyRoutesEffectTimeRange = None,
        filter_setting: FilterSetting = None,
        severities: List[str] = None,
    ):
        self.channels = channels
        self.effect_time_range = effect_time_range
        self.filter_setting = filter_setting
        self.severities = severities

    def validate(self):
        if self.channels:
            for k in self.channels:
                if k:
                    k.validate()
        if self.effect_time_range:
            self.effect_time_range.validate()
        if self.filter_setting:
            self.filter_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['channels'] = []
        if self.channels is not None:
            for k in self.channels:
                result['channels'].append(k.to_map() if k else None)
        if self.effect_time_range is not None:
            result['effectTimeRange'] = self.effect_time_range.to_map()
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.severities is not None:
            result['severities'] = self.severities
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.channels = []
        if m.get('channels') is not None:
            for k in m.get('channels'):
                temp_model = NotifyStrategyForModifyRoutesChannels()
                self.channels.append(temp_model.from_map(k))
        if m.get('effectTimeRange') is not None:
            temp_model = NotifyStrategyForModifyRoutesEffectTimeRange()
            self.effect_time_range = temp_model.from_map(m['effectTimeRange'])
        if m.get('filterSetting') is not None:
            temp_model = FilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('severities') is not None:
            self.severities = m.get('severities')
        return self


class NotifyStrategyForModify(TeaModel):
    def __init__(
        self,
        custom_template_entries: List[NotifyStrategyForModifyCustomTemplateEntries] = None,
        description: str = None,
        grouping_setting: NotifyStrategyForModifyGroupingSetting = None,
        ignore_restored_notification: bool = None,
        notify_strategy_name: str = None,
        routes: List[NotifyStrategyForModifyRoutes] = None,
    ):
        self.custom_template_entries = custom_template_entries
        self.description = description
        # This parameter is required.
        self.grouping_setting = grouping_setting
        self.ignore_restored_notification = ignore_restored_notification
        # This parameter is required.
        self.notify_strategy_name = notify_strategy_name
        # This parameter is required.
        self.routes = routes

    def validate(self):
        if self.custom_template_entries:
            for k in self.custom_template_entries:
                if k:
                    k.validate()
        if self.grouping_setting:
            self.grouping_setting.validate()
        if self.routes:
            for k in self.routes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['customTemplateEntries'] = []
        if self.custom_template_entries is not None:
            for k in self.custom_template_entries:
                result['customTemplateEntries'].append(k.to_map() if k else None)
        if self.description is not None:
            result['description'] = self.description
        if self.grouping_setting is not None:
            result['groupingSetting'] = self.grouping_setting.to_map()
        if self.ignore_restored_notification is not None:
            result['ignoreRestoredNotification'] = self.ignore_restored_notification
        if self.notify_strategy_name is not None:
            result['notifyStrategyName'] = self.notify_strategy_name
        result['routes'] = []
        if self.routes is not None:
            for k in self.routes:
                result['routes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.custom_template_entries = []
        if m.get('customTemplateEntries') is not None:
            for k in m.get('customTemplateEntries'):
                temp_model = NotifyStrategyForModifyCustomTemplateEntries()
                self.custom_template_entries.append(temp_model.from_map(k))
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('groupingSetting') is not None:
            temp_model = NotifyStrategyForModifyGroupingSetting()
            self.grouping_setting = temp_model.from_map(m['groupingSetting'])
        if m.get('ignoreRestoredNotification') is not None:
            self.ignore_restored_notification = m.get('ignoreRestoredNotification')
        if m.get('notifyStrategyName') is not None:
            self.notify_strategy_name = m.get('notifyStrategyName')
        self.routes = []
        if m.get('routes') is not None:
            for k in m.get('routes'):
                temp_model = NotifyStrategyForModifyRoutes()
                self.routes.append(temp_model.from_map(k))
        return self


class NotifyStrategyForViewCustomTemplateEntries(TeaModel):
    def __init__(
        self,
        target_type: str = None,
        template_uuid: str = None,
    ):
        # This parameter is required.
        self.target_type = target_type
        # This parameter is required.
        self.template_uuid = template_uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_type is not None:
            result['targetType'] = self.target_type
        if self.template_uuid is not None:
            result['templateUuid'] = self.template_uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('targetType') is not None:
            self.target_type = m.get('targetType')
        if m.get('templateUuid') is not None:
            self.template_uuid = m.get('templateUuid')
        return self


class NotifyStrategyForViewGroupingSetting(TeaModel):
    def __init__(
        self,
        grouping_keys: List[str] = None,
        period_min: int = None,
        silence_sec: int = None,
        times: int = None,
    ):
        self.grouping_keys = grouping_keys
        self.period_min = period_min
        self.silence_sec = silence_sec
        self.times = times

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grouping_keys is not None:
            result['groupingKeys'] = self.grouping_keys
        if self.period_min is not None:
            result['periodMin'] = self.period_min
        if self.silence_sec is not None:
            result['silenceSec'] = self.silence_sec
        if self.times is not None:
            result['times'] = self.times
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('groupingKeys') is not None:
            self.grouping_keys = m.get('groupingKeys')
        if m.get('periodMin') is not None:
            self.period_min = m.get('periodMin')
        if m.get('silenceSec') is not None:
            self.silence_sec = m.get('silenceSec')
        if m.get('times') is not None:
            self.times = m.get('times')
        return self


class NotifyStrategyForViewRoutesChannels(TeaModel):
    def __init__(
        self,
        channel_type: str = None,
        enabled_sub_channels: List[str] = None,
        receivers: List[str] = None,
    ):
        # This parameter is required.
        self.channel_type = channel_type
        self.enabled_sub_channels = enabled_sub_channels
        # This parameter is required.
        self.receivers = receivers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_type is not None:
            result['channelType'] = self.channel_type
        if self.enabled_sub_channels is not None:
            result['enabledSubChannels'] = self.enabled_sub_channels
        if self.receivers is not None:
            result['receivers'] = self.receivers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('channelType') is not None:
            self.channel_type = m.get('channelType')
        if m.get('enabledSubChannels') is not None:
            self.enabled_sub_channels = m.get('enabledSubChannels')
        if m.get('receivers') is not None:
            self.receivers = m.get('receivers')
        return self


class NotifyStrategyForViewRoutesEffectTimeRange(TeaModel):
    def __init__(
        self,
        day_in_week: List[int] = None,
        end_time_in_minute: int = None,
        start_time_in_minute: int = None,
        time_zone: str = None,
    ):
        self.day_in_week = day_in_week
        self.end_time_in_minute = end_time_in_minute
        self.start_time_in_minute = start_time_in_minute
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.day_in_week is not None:
            result['dayInWeek'] = self.day_in_week
        if self.end_time_in_minute is not None:
            result['endTimeInMinute'] = self.end_time_in_minute
        if self.start_time_in_minute is not None:
            result['startTimeInMinute'] = self.start_time_in_minute
        if self.time_zone is not None:
            result['timeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dayInWeek') is not None:
            self.day_in_week = m.get('dayInWeek')
        if m.get('endTimeInMinute') is not None:
            self.end_time_in_minute = m.get('endTimeInMinute')
        if m.get('startTimeInMinute') is not None:
            self.start_time_in_minute = m.get('startTimeInMinute')
        if m.get('timeZone') is not None:
            self.time_zone = m.get('timeZone')
        return self


class NotifyStrategyForViewRoutes(TeaModel):
    def __init__(
        self,
        channels: List[NotifyStrategyForViewRoutesChannels] = None,
        effect_time_range: NotifyStrategyForViewRoutesEffectTimeRange = None,
        filter_setting: FilterSetting = None,
        severities: List[str] = None,
    ):
        self.channels = channels
        self.effect_time_range = effect_time_range
        self.filter_setting = filter_setting
        self.severities = severities

    def validate(self):
        if self.channels:
            for k in self.channels:
                if k:
                    k.validate()
        if self.effect_time_range:
            self.effect_time_range.validate()
        if self.filter_setting:
            self.filter_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['channels'] = []
        if self.channels is not None:
            for k in self.channels:
                result['channels'].append(k.to_map() if k else None)
        if self.effect_time_range is not None:
            result['effectTimeRange'] = self.effect_time_range.to_map()
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.severities is not None:
            result['severities'] = self.severities
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.channels = []
        if m.get('channels') is not None:
            for k in m.get('channels'):
                temp_model = NotifyStrategyForViewRoutesChannels()
                self.channels.append(temp_model.from_map(k))
        if m.get('effectTimeRange') is not None:
            temp_model = NotifyStrategyForViewRoutesEffectTimeRange()
            self.effect_time_range = temp_model.from_map(m['effectTimeRange'])
        if m.get('filterSetting') is not None:
            temp_model = FilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('severities') is not None:
            self.severities = m.get('severities')
        return self


class NotifyStrategyForView(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        custom_template_entries: List[NotifyStrategyForViewCustomTemplateEntries] = None,
        description: str = None,
        enable: bool = None,
        grouping_setting: NotifyStrategyForViewGroupingSetting = None,
        ignore_restored_notification: bool = None,
        notify_strategy_id: str = None,
        notify_strategy_name: str = None,
        routes: List[NotifyStrategyForViewRoutes] = None,
        update_time: str = None,
        user_id: str = None,
        workspace: str = None,
    ):
        self.create_time = create_time
        self.custom_template_entries = custom_template_entries
        self.description = description
        self.enable = enable
        # This parameter is required.
        self.grouping_setting = grouping_setting
        self.ignore_restored_notification = ignore_restored_notification
        self.notify_strategy_id = notify_strategy_id
        # This parameter is required.
        self.notify_strategy_name = notify_strategy_name
        # This parameter is required.
        self.routes = routes
        self.update_time = update_time
        self.user_id = user_id
        self.workspace = workspace

    def validate(self):
        if self.custom_template_entries:
            for k in self.custom_template_entries:
                if k:
                    k.validate()
        if self.grouping_setting:
            self.grouping_setting.validate()
        if self.routes:
            for k in self.routes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        result['customTemplateEntries'] = []
        if self.custom_template_entries is not None:
            for k in self.custom_template_entries:
                result['customTemplateEntries'].append(k.to_map() if k else None)
        if self.description is not None:
            result['description'] = self.description
        if self.enable is not None:
            result['enable'] = self.enable
        if self.grouping_setting is not None:
            result['groupingSetting'] = self.grouping_setting.to_map()
        if self.ignore_restored_notification is not None:
            result['ignoreRestoredNotification'] = self.ignore_restored_notification
        if self.notify_strategy_id is not None:
            result['notifyStrategyId'] = self.notify_strategy_id
        if self.notify_strategy_name is not None:
            result['notifyStrategyName'] = self.notify_strategy_name
        result['routes'] = []
        if self.routes is not None:
            for k in self.routes:
                result['routes'].append(k.to_map() if k else None)
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        self.custom_template_entries = []
        if m.get('customTemplateEntries') is not None:
            for k in m.get('customTemplateEntries'):
                temp_model = NotifyStrategyForViewCustomTemplateEntries()
                self.custom_template_entries.append(temp_model.from_map(k))
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('groupingSetting') is not None:
            temp_model = NotifyStrategyForViewGroupingSetting()
            self.grouping_setting = temp_model.from_map(m['groupingSetting'])
        if m.get('ignoreRestoredNotification') is not None:
            self.ignore_restored_notification = m.get('ignoreRestoredNotification')
        if m.get('notifyStrategyId') is not None:
            self.notify_strategy_id = m.get('notifyStrategyId')
        if m.get('notifyStrategyName') is not None:
            self.notify_strategy_name = m.get('notifyStrategyName')
        self.routes = []
        if m.get('routes') is not None:
            for k in m.get('routes'):
                temp_model = NotifyStrategyForViewRoutes()
                self.routes.append(temp_model.from_map(k))
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class PrometheusManagedInstance(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        instance_type: str = None,
        prometheus_instance_id: str = None,
        prometheus_instance_name: str = None,
        region_id: str = None,
        status: str = None,
        workspace: str = None,
    ):
        self.create_time = create_time
        self.instance_type = instance_type
        self.prometheus_instance_id = prometheus_instance_id
        self.prometheus_instance_name = prometheus_instance_name
        self.region_id = region_id
        self.status = status
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.instance_type is not None:
            result['instanceType'] = self.instance_type
        if self.prometheus_instance_id is not None:
            result['prometheusInstanceId'] = self.prometheus_instance_id
        if self.prometheus_instance_name is not None:
            result['prometheusInstanceName'] = self.prometheus_instance_name
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.status is not None:
            result['status'] = self.status
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('instanceType') is not None:
            self.instance_type = m.get('instanceType')
        if m.get('prometheusInstanceId') is not None:
            self.prometheus_instance_id = m.get('prometheusInstanceId')
        if m.get('prometheusInstanceName') is not None:
            self.prometheus_instance_name = m.get('prometheusInstanceName')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class RumDnsResponse(TeaModel):
    def __init__(
        self,
        domain: str = None,
        message: str = None,
        result: bool = None,
    ):
        self.domain = domain
        self.message = message
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['domain'] = self.domain
        if self.message is not None:
            result['message'] = self.message
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain') is not None:
            self.domain = m.get('domain')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class SubscriptionEscalationSettingCustomChannels(TeaModel):
    def __init__(
        self,
        channel_type: str = None,
        severities: List[str] = None,
        template_uuid: str = None,
    ):
        # This parameter is required.
        self.channel_type = channel_type
        self.severities = severities
        self.template_uuid = template_uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_type is not None:
            result['channelType'] = self.channel_type
        if self.severities is not None:
            result['severities'] = self.severities
        if self.template_uuid is not None:
            result['templateUuid'] = self.template_uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('channelType') is not None:
            self.channel_type = m.get('channelType')
        if m.get('severities') is not None:
            self.severities = m.get('severities')
        if m.get('templateUuid') is not None:
            self.template_uuid = m.get('templateUuid')
        return self


class SubscriptionEscalationSetting(TeaModel):
    def __init__(
        self,
        auto_resolve_min: int = None,
        custom_channels: List[SubscriptionEscalationSettingCustomChannels] = None,
        escalation_level: str = None,
        escalation_type: str = None,
        escalation_uuid: str = None,
        retrigger_min: int = None,
    ):
        self.auto_resolve_min = auto_resolve_min
        self.custom_channels = custom_channels
        self.escalation_level = escalation_level
        self.escalation_type = escalation_type
        self.escalation_uuid = escalation_uuid
        self.retrigger_min = retrigger_min

    def validate(self):
        if self.custom_channels:
            for k in self.custom_channels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_resolve_min is not None:
            result['autoResolveMin'] = self.auto_resolve_min
        result['customChannels'] = []
        if self.custom_channels is not None:
            for k in self.custom_channels:
                result['customChannels'].append(k.to_map() if k else None)
        if self.escalation_level is not None:
            result['escalationLevel'] = self.escalation_level
        if self.escalation_type is not None:
            result['escalationType'] = self.escalation_type
        if self.escalation_uuid is not None:
            result['escalationUuid'] = self.escalation_uuid
        if self.retrigger_min is not None:
            result['retriggerMin'] = self.retrigger_min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('autoResolveMin') is not None:
            self.auto_resolve_min = m.get('autoResolveMin')
        self.custom_channels = []
        if m.get('customChannels') is not None:
            for k in m.get('customChannels'):
                temp_model = SubscriptionEscalationSettingCustomChannels()
                self.custom_channels.append(temp_model.from_map(k))
        if m.get('escalationLevel') is not None:
            self.escalation_level = m.get('escalationLevel')
        if m.get('escalationType') is not None:
            self.escalation_type = m.get('escalationType')
        if m.get('escalationUuid') is not None:
            self.escalation_uuid = m.get('escalationUuid')
        if m.get('retriggerMin') is not None:
            self.retrigger_min = m.get('retriggerMin')
        return self


class SubscriptionFilterSettingConditions(TeaModel):
    def __init__(
        self,
        field: str = None,
        op: str = None,
        value: str = None,
    ):
        self.field = field
        self.op = op
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['field'] = self.field
        if self.op is not None:
            result['op'] = self.op
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('field') is not None:
            self.field = m.get('field')
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class SubscriptionFilterSetting(TeaModel):
    def __init__(
        self,
        conditions: List[SubscriptionFilterSettingConditions] = None,
        expression: str = None,
        relation: str = None,
    ):
        self.conditions = conditions
        self.expression = expression
        self.relation = relation

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.expression is not None:
            result['expression'] = self.expression
        if self.relation is not None:
            result['relation'] = self.relation
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = SubscriptionFilterSettingConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('expression') is not None:
            self.expression = m.get('expression')
        if m.get('relation') is not None:
            self.relation = m.get('relation')
        return self


class SubscriptionGroupingSettingGroupingItem(TeaModel):
    def __init__(
        self,
        keys: List[str] = None,
        type: str = None,
    ):
        self.keys = keys
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keys is not None:
            result['keys'] = self.keys
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('keys') is not None:
            self.keys = m.get('keys')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class SubscriptionGroupingSetting(TeaModel):
    def __init__(
        self,
        grouping_item: SubscriptionGroupingSettingGroupingItem = None,
        grouping_scope: str = None,
        period_min: int = None,
        silence_sec: int = None,
        times: int = None,
    ):
        self.grouping_item = grouping_item
        self.grouping_scope = grouping_scope
        self.period_min = period_min
        self.silence_sec = silence_sec
        self.times = times

    def validate(self):
        if self.grouping_item:
            self.grouping_item.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grouping_item is not None:
            result['groupingItem'] = self.grouping_item.to_map()
        if self.grouping_scope is not None:
            result['groupingScope'] = self.grouping_scope
        if self.period_min is not None:
            result['periodMin'] = self.period_min
        if self.silence_sec is not None:
            result['silenceSec'] = self.silence_sec
        if self.times is not None:
            result['times'] = self.times
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('groupingItem') is not None:
            temp_model = SubscriptionGroupingSettingGroupingItem()
            self.grouping_item = temp_model.from_map(m['groupingItem'])
        if m.get('groupingScope') is not None:
            self.grouping_scope = m.get('groupingScope')
        if m.get('periodMin') is not None:
            self.period_min = m.get('periodMin')
        if m.get('silenceSec') is not None:
            self.silence_sec = m.get('silenceSec')
        if m.get('times') is not None:
            self.times = m.get('times')
        return self


class SubscriptionPushingSetting(TeaModel):
    def __init__(
        self,
        pushing_data_format: str = None,
        target_uuids: List[str] = None,
        template_uuid: str = None,
    ):
        self.pushing_data_format = pushing_data_format
        self.target_uuids = target_uuids
        self.template_uuid = template_uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pushing_data_format is not None:
            result['pushingDataFormat'] = self.pushing_data_format
        if self.target_uuids is not None:
            result['targetUuids'] = self.target_uuids
        if self.template_uuid is not None:
            result['templateUuid'] = self.template_uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('pushingDataFormat') is not None:
            self.pushing_data_format = m.get('pushingDataFormat')
        if m.get('targetUuids') is not None:
            self.target_uuids = m.get('targetUuids')
        if m.get('templateUuid') is not None:
            self.template_uuid = m.get('templateUuid')
        return self


class Subscription(TeaModel):
    def __init__(
        self,
        description: str = None,
        escalation_setting: SubscriptionEscalationSetting = None,
        filter_setting: SubscriptionFilterSetting = None,
        grouping_setting: SubscriptionGroupingSetting = None,
        name: str = None,
        pushing_setting: SubscriptionPushingSetting = None,
    ):
        self.description = description
        self.escalation_setting = escalation_setting
        self.filter_setting = filter_setting
        self.grouping_setting = grouping_setting
        # This parameter is required.
        self.name = name
        self.pushing_setting = pushing_setting

    def validate(self):
        if self.escalation_setting:
            self.escalation_setting.validate()
        if self.filter_setting:
            self.filter_setting.validate()
        if self.grouping_setting:
            self.grouping_setting.validate()
        if self.pushing_setting:
            self.pushing_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.escalation_setting is not None:
            result['escalationSetting'] = self.escalation_setting.to_map()
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.grouping_setting is not None:
            result['groupingSetting'] = self.grouping_setting.to_map()
        if self.name is not None:
            result['name'] = self.name
        if self.pushing_setting is not None:
            result['pushingSetting'] = self.pushing_setting.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('escalationSetting') is not None:
            temp_model = SubscriptionEscalationSetting()
            self.escalation_setting = temp_model.from_map(m['escalationSetting'])
        if m.get('filterSetting') is not None:
            temp_model = SubscriptionFilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('groupingSetting') is not None:
            temp_model = SubscriptionGroupingSetting()
            self.grouping_setting = temp_model.from_map(m['groupingSetting'])
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pushingSetting') is not None:
            temp_model = SubscriptionPushingSetting()
            self.pushing_setting = temp_model.from_map(m['pushingSetting'])
        return self


class SubscriptionForModifyPushingSetting(TeaModel):
    def __init__(
        self,
        alert_action_ids: List[str] = None,
        response_plan_id: str = None,
        restore_action_ids: List[str] = None,
        template_uuid: str = None,
    ):
        self.alert_action_ids = alert_action_ids
        self.response_plan_id = response_plan_id
        self.restore_action_ids = restore_action_ids
        self.template_uuid = template_uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_action_ids is not None:
            result['alertActionIds'] = self.alert_action_ids
        if self.response_plan_id is not None:
            result['responsePlanId'] = self.response_plan_id
        if self.restore_action_ids is not None:
            result['restoreActionIds'] = self.restore_action_ids
        if self.template_uuid is not None:
            result['templateUuid'] = self.template_uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertActionIds') is not None:
            self.alert_action_ids = m.get('alertActionIds')
        if m.get('responsePlanId') is not None:
            self.response_plan_id = m.get('responsePlanId')
        if m.get('restoreActionIds') is not None:
            self.restore_action_ids = m.get('restoreActionIds')
        if m.get('templateUuid') is not None:
            self.template_uuid = m.get('templateUuid')
        return self


class SubscriptionForModify(TeaModel):
    def __init__(
        self,
        description: str = None,
        filter_setting: FilterSetting = None,
        notify_strategy_id: str = None,
        pushing_setting: SubscriptionForModifyPushingSetting = None,
        subscription_name: str = None,
    ):
        self.description = description
        self.filter_setting = filter_setting
        self.notify_strategy_id = notify_strategy_id
        self.pushing_setting = pushing_setting
        # This parameter is required.
        self.subscription_name = subscription_name

    def validate(self):
        if self.filter_setting:
            self.filter_setting.validate()
        if self.pushing_setting:
            self.pushing_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.notify_strategy_id is not None:
            result['notifyStrategyId'] = self.notify_strategy_id
        if self.pushing_setting is not None:
            result['pushingSetting'] = self.pushing_setting.to_map()
        if self.subscription_name is not None:
            result['subscriptionName'] = self.subscription_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('filterSetting') is not None:
            temp_model = FilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('notifyStrategyId') is not None:
            self.notify_strategy_id = m.get('notifyStrategyId')
        if m.get('pushingSetting') is not None:
            temp_model = SubscriptionForModifyPushingSetting()
            self.pushing_setting = temp_model.from_map(m['pushingSetting'])
        if m.get('subscriptionName') is not None:
            self.subscription_name = m.get('subscriptionName')
        return self


class SubscriptionForViewEscalationSettingCustomChannels(TeaModel):
    def __init__(
        self,
        channel_type: str = None,
        severities: List[str] = None,
        template_uuid: str = None,
    ):
        # This parameter is required.
        self.channel_type = channel_type
        self.severities = severities
        self.template_uuid = template_uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_type is not None:
            result['channelType'] = self.channel_type
        if self.severities is not None:
            result['severities'] = self.severities
        if self.template_uuid is not None:
            result['templateUuid'] = self.template_uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('channelType') is not None:
            self.channel_type = m.get('channelType')
        if m.get('severities') is not None:
            self.severities = m.get('severities')
        if m.get('templateUuid') is not None:
            self.template_uuid = m.get('templateUuid')
        return self


class SubscriptionForViewEscalationSetting(TeaModel):
    def __init__(
        self,
        auto_resolve_min: int = None,
        custom_channels: List[SubscriptionForViewEscalationSettingCustomChannels] = None,
        escalation_level: str = None,
        escalation_type: str = None,
        escalation_uuid: str = None,
        retrigger_min: int = None,
    ):
        self.auto_resolve_min = auto_resolve_min
        self.custom_channels = custom_channels
        self.escalation_level = escalation_level
        self.escalation_type = escalation_type
        self.escalation_uuid = escalation_uuid
        self.retrigger_min = retrigger_min

    def validate(self):
        if self.custom_channels:
            for k in self.custom_channels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_resolve_min is not None:
            result['autoResolveMin'] = self.auto_resolve_min
        result['customChannels'] = []
        if self.custom_channels is not None:
            for k in self.custom_channels:
                result['customChannels'].append(k.to_map() if k else None)
        if self.escalation_level is not None:
            result['escalationLevel'] = self.escalation_level
        if self.escalation_type is not None:
            result['escalationType'] = self.escalation_type
        if self.escalation_uuid is not None:
            result['escalationUuid'] = self.escalation_uuid
        if self.retrigger_min is not None:
            result['retriggerMin'] = self.retrigger_min
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('autoResolveMin') is not None:
            self.auto_resolve_min = m.get('autoResolveMin')
        self.custom_channels = []
        if m.get('customChannels') is not None:
            for k in m.get('customChannels'):
                temp_model = SubscriptionForViewEscalationSettingCustomChannels()
                self.custom_channels.append(temp_model.from_map(k))
        if m.get('escalationLevel') is not None:
            self.escalation_level = m.get('escalationLevel')
        if m.get('escalationType') is not None:
            self.escalation_type = m.get('escalationType')
        if m.get('escalationUuid') is not None:
            self.escalation_uuid = m.get('escalationUuid')
        if m.get('retriggerMin') is not None:
            self.retrigger_min = m.get('retriggerMin')
        return self


class SubscriptionForViewFilterSettingConditions(TeaModel):
    def __init__(
        self,
        field: str = None,
        op: str = None,
        value: str = None,
    ):
        self.field = field
        self.op = op
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['field'] = self.field
        if self.op is not None:
            result['op'] = self.op
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('field') is not None:
            self.field = m.get('field')
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class SubscriptionForViewFilterSetting(TeaModel):
    def __init__(
        self,
        conditions: List[SubscriptionForViewFilterSettingConditions] = None,
        expression: str = None,
        relation: str = None,
    ):
        self.conditions = conditions
        self.expression = expression
        self.relation = relation

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.expression is not None:
            result['expression'] = self.expression
        if self.relation is not None:
            result['relation'] = self.relation
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = SubscriptionForViewFilterSettingConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('expression') is not None:
            self.expression = m.get('expression')
        if m.get('relation') is not None:
            self.relation = m.get('relation')
        return self


class SubscriptionForViewGroupingSettingGroupingItem(TeaModel):
    def __init__(
        self,
        keys: List[str] = None,
        type: str = None,
    ):
        self.keys = keys
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keys is not None:
            result['keys'] = self.keys
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('keys') is not None:
            self.keys = m.get('keys')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class SubscriptionForViewGroupingSetting(TeaModel):
    def __init__(
        self,
        grouping_item: SubscriptionForViewGroupingSettingGroupingItem = None,
        grouping_scope: str = None,
        period_min: int = None,
        silence_sec: int = None,
        times: int = None,
    ):
        self.grouping_item = grouping_item
        self.grouping_scope = grouping_scope
        self.period_min = period_min
        self.silence_sec = silence_sec
        self.times = times

    def validate(self):
        if self.grouping_item:
            self.grouping_item.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grouping_item is not None:
            result['groupingItem'] = self.grouping_item.to_map()
        if self.grouping_scope is not None:
            result['groupingScope'] = self.grouping_scope
        if self.period_min is not None:
            result['periodMin'] = self.period_min
        if self.silence_sec is not None:
            result['silenceSec'] = self.silence_sec
        if self.times is not None:
            result['times'] = self.times
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('groupingItem') is not None:
            temp_model = SubscriptionForViewGroupingSettingGroupingItem()
            self.grouping_item = temp_model.from_map(m['groupingItem'])
        if m.get('groupingScope') is not None:
            self.grouping_scope = m.get('groupingScope')
        if m.get('periodMin') is not None:
            self.period_min = m.get('periodMin')
        if m.get('silenceSec') is not None:
            self.silence_sec = m.get('silenceSec')
        if m.get('times') is not None:
            self.times = m.get('times')
        return self


class SubscriptionForViewPushingSetting(TeaModel):
    def __init__(
        self,
        pushing_data_format: str = None,
        target_uuids: List[str] = None,
        template_uuid: str = None,
    ):
        self.pushing_data_format = pushing_data_format
        self.target_uuids = target_uuids
        self.template_uuid = template_uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pushing_data_format is not None:
            result['pushingDataFormat'] = self.pushing_data_format
        if self.target_uuids is not None:
            result['targetUuids'] = self.target_uuids
        if self.template_uuid is not None:
            result['templateUuid'] = self.template_uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('pushingDataFormat') is not None:
            self.pushing_data_format = m.get('pushingDataFormat')
        if m.get('targetUuids') is not None:
            self.target_uuids = m.get('targetUuids')
        if m.get('templateUuid') is not None:
            self.template_uuid = m.get('templateUuid')
        return self


class SubscriptionForView(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        enable: bool = None,
        escalation_setting: SubscriptionForViewEscalationSetting = None,
        filter_setting: SubscriptionForViewFilterSetting = None,
        grouping_setting: SubscriptionForViewGroupingSetting = None,
        name: str = None,
        owner_product: str = None,
        pushing_setting: SubscriptionForViewPushingSetting = None,
        update_time: str = None,
        user_id: str = None,
        uuid: str = None,
        workspace: str = None,
    ):
        self.create_time = create_time
        self.description = description
        self.enable = enable
        self.escalation_setting = escalation_setting
        self.filter_setting = filter_setting
        self.grouping_setting = grouping_setting
        # This parameter is required.
        self.name = name
        self.owner_product = owner_product
        self.pushing_setting = pushing_setting
        self.update_time = update_time
        self.user_id = user_id
        self.uuid = uuid
        self.workspace = workspace

    def validate(self):
        if self.escalation_setting:
            self.escalation_setting.validate()
        if self.filter_setting:
            self.filter_setting.validate()
        if self.grouping_setting:
            self.grouping_setting.validate()
        if self.pushing_setting:
            self.pushing_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.enable is not None:
            result['enable'] = self.enable
        if self.escalation_setting is not None:
            result['escalationSetting'] = self.escalation_setting.to_map()
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.grouping_setting is not None:
            result['groupingSetting'] = self.grouping_setting.to_map()
        if self.name is not None:
            result['name'] = self.name
        if self.owner_product is not None:
            result['ownerProduct'] = self.owner_product
        if self.pushing_setting is not None:
            result['pushingSetting'] = self.pushing_setting.to_map()
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('escalationSetting') is not None:
            temp_model = SubscriptionForViewEscalationSetting()
            self.escalation_setting = temp_model.from_map(m['escalationSetting'])
        if m.get('filterSetting') is not None:
            temp_model = SubscriptionForViewFilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('groupingSetting') is not None:
            temp_model = SubscriptionForViewGroupingSetting()
            self.grouping_setting = temp_model.from_map(m['groupingSetting'])
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('ownerProduct') is not None:
            self.owner_product = m.get('ownerProduct')
        if m.get('pushingSetting') is not None:
            temp_model = SubscriptionForViewPushingSetting()
            self.pushing_setting = temp_model.from_map(m['pushingSetting'])
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class TransformerActionsFilterSettingConditions(TeaModel):
    def __init__(
        self,
        field: str = None,
        op: str = None,
        value: str = None,
    ):
        self.field = field
        self.op = op
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['field'] = self.field
        if self.op is not None:
            result['op'] = self.op
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('field') is not None:
            self.field = m.get('field')
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class TransformerActionsFilterSetting(TeaModel):
    def __init__(
        self,
        conditions: List[TransformerActionsFilterSettingConditions] = None,
        expression: str = None,
        relation: str = None,
    ):
        self.conditions = conditions
        self.expression = expression
        self.relation = relation

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.expression is not None:
            result['expression'] = self.expression
        if self.relation is not None:
            result['relation'] = self.relation
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = TransformerActionsFilterSettingConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('expression') is not None:
            self.expression = m.get('expression')
        if m.get('relation') is not None:
            self.relation = m.get('relation')
        return self


class TransformerActions(TeaModel):
    def __init__(
        self,
        filter_setting: TransformerActionsFilterSetting = None,
        label_key: str = None,
        mapping: Dict[str, str] = None,
        reg_exp: str = None,
        source: str = None,
        target: str = None,
        type: str = None,
        value: str = None,
        variable: str = None,
    ):
        self.filter_setting = filter_setting
        self.label_key = label_key
        self.mapping = mapping
        self.reg_exp = reg_exp
        self.source = source
        self.target = target
        self.type = type
        self.value = value
        self.variable = variable

    def validate(self):
        if self.filter_setting:
            self.filter_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.label_key is not None:
            result['labelKey'] = self.label_key
        if self.mapping is not None:
            result['mapping'] = self.mapping
        if self.reg_exp is not None:
            result['regExp'] = self.reg_exp
        if self.source is not None:
            result['source'] = self.source
        if self.target is not None:
            result['target'] = self.target
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        if self.variable is not None:
            result['variable'] = self.variable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('filterSetting') is not None:
            temp_model = TransformerActionsFilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('labelKey') is not None:
            self.label_key = m.get('labelKey')
        if m.get('mapping') is not None:
            self.mapping = m.get('mapping')
        if m.get('regExp') is not None:
            self.reg_exp = m.get('regExp')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('target') is not None:
            self.target = m.get('target')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('variable') is not None:
            self.variable = m.get('variable')
        return self


class TransformerFilterSettingConditions(TeaModel):
    def __init__(
        self,
        field: str = None,
        op: str = None,
        value: str = None,
    ):
        self.field = field
        self.op = op
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['field'] = self.field
        if self.op is not None:
            result['op'] = self.op
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('field') is not None:
            self.field = m.get('field')
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class TransformerFilterSetting(TeaModel):
    def __init__(
        self,
        conditions: List[TransformerFilterSettingConditions] = None,
        expression: str = None,
        relation: str = None,
    ):
        self.conditions = conditions
        self.expression = expression
        self.relation = relation

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.expression is not None:
            result['expression'] = self.expression
        if self.relation is not None:
            result['relation'] = self.relation
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = TransformerFilterSettingConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('expression') is not None:
            self.expression = m.get('expression')
        if m.get('relation') is not None:
            self.relation = m.get('relation')
        return self


class Transformer(TeaModel):
    def __init__(
        self,
        actions: List[TransformerActions] = None,
        description: str = None,
        filter_setting: TransformerFilterSetting = None,
        name: str = None,
    ):
        self.actions = actions
        self.description = description
        self.filter_setting = filter_setting
        # This parameter is required.
        self.name = name

    def validate(self):
        if self.actions:
            for k in self.actions:
                if k:
                    k.validate()
        if self.filter_setting:
            self.filter_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['actions'] = []
        if self.actions is not None:
            for k in self.actions:
                result['actions'].append(k.to_map() if k else None)
        if self.description is not None:
            result['description'] = self.description
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.actions = []
        if m.get('actions') is not None:
            for k in m.get('actions'):
                temp_model = TransformerActions()
                self.actions.append(temp_model.from_map(k))
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('filterSetting') is not None:
            temp_model = TransformerFilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class TransformerForModify(TeaModel):
    def __init__(
        self,
        actions: List[TransformAction] = None,
        description: str = None,
        filter_setting: FilterSetting = None,
        quit_after_match: bool = None,
        sort_id: int = None,
        transformer_name: str = None,
    ):
        self.actions = actions
        self.description = description
        self.filter_setting = filter_setting
        self.quit_after_match = quit_after_match
        self.sort_id = sort_id
        # This parameter is required.
        self.transformer_name = transformer_name

    def validate(self):
        if self.actions:
            for k in self.actions:
                if k:
                    k.validate()
        if self.filter_setting:
            self.filter_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['actions'] = []
        if self.actions is not None:
            for k in self.actions:
                result['actions'].append(k.to_map() if k else None)
        if self.description is not None:
            result['description'] = self.description
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.quit_after_match is not None:
            result['quitAfterMatch'] = self.quit_after_match
        if self.sort_id is not None:
            result['sortId'] = self.sort_id
        if self.transformer_name is not None:
            result['transformerName'] = self.transformer_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.actions = []
        if m.get('actions') is not None:
            for k in m.get('actions'):
                temp_model = TransformAction()
                self.actions.append(temp_model.from_map(k))
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('filterSetting') is not None:
            temp_model = FilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('quitAfterMatch') is not None:
            self.quit_after_match = m.get('quitAfterMatch')
        if m.get('sortId') is not None:
            self.sort_id = m.get('sortId')
        if m.get('transformerName') is not None:
            self.transformer_name = m.get('transformerName')
        return self


class TransformerForViewActionsFilterSettingConditions(TeaModel):
    def __init__(
        self,
        field: str = None,
        op: str = None,
        value: str = None,
    ):
        self.field = field
        self.op = op
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['field'] = self.field
        if self.op is not None:
            result['op'] = self.op
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('field') is not None:
            self.field = m.get('field')
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class TransformerForViewActionsFilterSetting(TeaModel):
    def __init__(
        self,
        conditions: List[TransformerForViewActionsFilterSettingConditions] = None,
        expression: str = None,
        relation: str = None,
    ):
        self.conditions = conditions
        self.expression = expression
        self.relation = relation

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.expression is not None:
            result['expression'] = self.expression
        if self.relation is not None:
            result['relation'] = self.relation
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = TransformerForViewActionsFilterSettingConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('expression') is not None:
            self.expression = m.get('expression')
        if m.get('relation') is not None:
            self.relation = m.get('relation')
        return self


class TransformerForViewActions(TeaModel):
    def __init__(
        self,
        filter_setting: TransformerForViewActionsFilterSetting = None,
        label_key: str = None,
        mapping: Dict[str, str] = None,
        reg_exp: str = None,
        source: str = None,
        target: str = None,
        type: str = None,
        value: str = None,
        variable: str = None,
    ):
        self.filter_setting = filter_setting
        self.label_key = label_key
        self.mapping = mapping
        self.reg_exp = reg_exp
        self.source = source
        self.target = target
        self.type = type
        self.value = value
        self.variable = variable

    def validate(self):
        if self.filter_setting:
            self.filter_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.label_key is not None:
            result['labelKey'] = self.label_key
        if self.mapping is not None:
            result['mapping'] = self.mapping
        if self.reg_exp is not None:
            result['regExp'] = self.reg_exp
        if self.source is not None:
            result['source'] = self.source
        if self.target is not None:
            result['target'] = self.target
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        if self.variable is not None:
            result['variable'] = self.variable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('filterSetting') is not None:
            temp_model = TransformerForViewActionsFilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('labelKey') is not None:
            self.label_key = m.get('labelKey')
        if m.get('mapping') is not None:
            self.mapping = m.get('mapping')
        if m.get('regExp') is not None:
            self.reg_exp = m.get('regExp')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('target') is not None:
            self.target = m.get('target')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('variable') is not None:
            self.variable = m.get('variable')
        return self


class TransformerForViewFilterSettingConditions(TeaModel):
    def __init__(
        self,
        field: str = None,
        op: str = None,
        value: str = None,
    ):
        self.field = field
        self.op = op
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['field'] = self.field
        if self.op is not None:
            result['op'] = self.op
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('field') is not None:
            self.field = m.get('field')
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class TransformerForViewFilterSetting(TeaModel):
    def __init__(
        self,
        conditions: List[TransformerForViewFilterSettingConditions] = None,
        expression: str = None,
        relation: str = None,
    ):
        self.conditions = conditions
        self.expression = expression
        self.relation = relation

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.expression is not None:
            result['expression'] = self.expression
        if self.relation is not None:
            result['relation'] = self.relation
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = TransformerForViewFilterSettingConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('expression') is not None:
            self.expression = m.get('expression')
        if m.get('relation') is not None:
            self.relation = m.get('relation')
        return self


class TransformerForView(TeaModel):
    def __init__(
        self,
        actions: List[TransformerForViewActions] = None,
        create_time: str = None,
        description: str = None,
        enable: bool = None,
        filter_setting: TransformerForViewFilterSetting = None,
        name: str = None,
        update_time: str = None,
        user_id: str = None,
        uuid: str = None,
        workspace: str = None,
    ):
        self.actions = actions
        self.create_time = create_time
        self.description = description
        self.enable = enable
        self.filter_setting = filter_setting
        # This parameter is required.
        self.name = name
        self.update_time = update_time
        self.user_id = user_id
        self.uuid = uuid
        self.workspace = workspace

    def validate(self):
        if self.actions:
            for k in self.actions:
                if k:
                    k.validate()
        if self.filter_setting:
            self.filter_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['actions'] = []
        if self.actions is not None:
            for k in self.actions:
                result['actions'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.enable is not None:
            result['enable'] = self.enable
        if self.filter_setting is not None:
            result['filterSetting'] = self.filter_setting.to_map()
        if self.name is not None:
            result['name'] = self.name
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.actions = []
        if m.get('actions') is not None:
            for k in m.get('actions'):
                temp_model = TransformerForViewActions()
                self.actions.append(temp_model.from_map(k))
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('filterSetting') is not None:
            temp_model = TransformerForViewFilterSetting()
            self.filter_setting = temp_model.from_map(m['filterSetting'])
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ScheduleValue(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        end: str = None,
        start: str = None,
        contact_name: str = None,
    ):
        self.contact_id = contact_id
        self.end = end
        self.start = start
        self.contact_name = contact_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['contactId'] = self.contact_id
        if self.end is not None:
            result['end'] = self.end
        if self.start is not None:
            result['start'] = self.start
        if self.contact_name is not None:
            result['contactName'] = self.contact_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactId') is not None:
            self.contact_id = m.get('contactId')
        if m.get('end') is not None:
            self.end = m.get('end')
        if m.get('start') is not None:
            self.start = m.get('start')
        if m.get('contactName') is not None:
            self.contact_name = m.get('contactName')
        return self


class ActiveContactChannelRequest(TeaModel):
    def __init__(
        self,
        code: str = None,
        site: str = None,
    ):
        self.code = code
        self.site = site

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.site is not None:
            result['site'] = self.site
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('site') is not None:
            self.site = m.get('site')
        return self


class ActiveContactChannelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ActiveContactChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ActiveContactChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ActiveContactChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckDispatchRoleResponseBody(TeaModel):
    def __init__(
        self,
        has_auth: bool = None,
        request_id: str = None,
    ):
        self.has_auth = has_auth
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_auth is not None:
            result['hasAuth'] = self.has_auth
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hasAuth') is not None:
            self.has_auth = m.get('hasAuth')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CheckDispatchRoleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CheckDispatchRoleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckDispatchRoleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CountAlertHistoriesByFieldsRequest(TeaModel):
    def __init__(
        self,
        alert_rule_id: str = None,
        biz_source: str = None,
        display_name_key_word: str = None,
        field_list: List[str] = None,
        instance_key: str = None,
        label_filter: AlertRuleLabelFilter = None,
        latest_level: str = None,
        max_level: str = None,
        notification_filter: AlertRuleNotificationFilter = None,
        start_time_from: int = None,
        start_time_to: int = None,
        status: str = None,
        workspace: str = None,
    ):
        self.alert_rule_id = alert_rule_id
        self.biz_source = biz_source
        self.display_name_key_word = display_name_key_word
        self.field_list = field_list
        self.instance_key = instance_key
        self.label_filter = label_filter
        self.latest_level = latest_level
        self.max_level = max_level
        self.notification_filter = notification_filter
        self.start_time_from = start_time_from
        self.start_time_to = start_time_to
        self.status = status
        self.workspace = workspace

    def validate(self):
        if self.label_filter:
            self.label_filter.validate()
        if self.notification_filter:
            self.notification_filter.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_id is not None:
            result['alertRuleId'] = self.alert_rule_id
        if self.biz_source is not None:
            result['bizSource'] = self.biz_source
        if self.display_name_key_word is not None:
            result['displayNameKeyWord'] = self.display_name_key_word
        if self.field_list is not None:
            result['fieldList'] = self.field_list
        if self.instance_key is not None:
            result['instanceKey'] = self.instance_key
        if self.label_filter is not None:
            result['labelFilter'] = self.label_filter.to_map()
        if self.latest_level is not None:
            result['latestLevel'] = self.latest_level
        if self.max_level is not None:
            result['maxLevel'] = self.max_level
        if self.notification_filter is not None:
            result['notificationFilter'] = self.notification_filter.to_map()
        if self.start_time_from is not None:
            result['startTimeFrom'] = self.start_time_from
        if self.start_time_to is not None:
            result['startTimeTo'] = self.start_time_to
        if self.status is not None:
            result['status'] = self.status
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleId') is not None:
            self.alert_rule_id = m.get('alertRuleId')
        if m.get('bizSource') is not None:
            self.biz_source = m.get('bizSource')
        if m.get('displayNameKeyWord') is not None:
            self.display_name_key_word = m.get('displayNameKeyWord')
        if m.get('fieldList') is not None:
            self.field_list = m.get('fieldList')
        if m.get('instanceKey') is not None:
            self.instance_key = m.get('instanceKey')
        if m.get('labelFilter') is not None:
            temp_model = AlertRuleLabelFilter()
            self.label_filter = temp_model.from_map(m['labelFilter'])
        if m.get('latestLevel') is not None:
            self.latest_level = m.get('latestLevel')
        if m.get('maxLevel') is not None:
            self.max_level = m.get('maxLevel')
        if m.get('notificationFilter') is not None:
            temp_model = AlertRuleNotificationFilter()
            self.notification_filter = temp_model.from_map(m['notificationFilter'])
        if m.get('startTimeFrom') is not None:
            self.start_time_from = m.get('startTimeFrom')
        if m.get('startTimeTo') is not None:
            self.start_time_to = m.get('startTimeTo')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CountAlertHistoriesByFieldsShrinkRequest(TeaModel):
    def __init__(
        self,
        alert_rule_id: str = None,
        biz_source: str = None,
        display_name_key_word: str = None,
        field_list_shrink: str = None,
        instance_key: str = None,
        label_filter_shrink: str = None,
        latest_level: str = None,
        max_level: str = None,
        notification_filter_shrink: str = None,
        start_time_from: int = None,
        start_time_to: int = None,
        status: str = None,
        workspace: str = None,
    ):
        self.alert_rule_id = alert_rule_id
        self.biz_source = biz_source
        self.display_name_key_word = display_name_key_word
        self.field_list_shrink = field_list_shrink
        self.instance_key = instance_key
        self.label_filter_shrink = label_filter_shrink
        self.latest_level = latest_level
        self.max_level = max_level
        self.notification_filter_shrink = notification_filter_shrink
        self.start_time_from = start_time_from
        self.start_time_to = start_time_to
        self.status = status
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_id is not None:
            result['alertRuleId'] = self.alert_rule_id
        if self.biz_source is not None:
            result['bizSource'] = self.biz_source
        if self.display_name_key_word is not None:
            result['displayNameKeyWord'] = self.display_name_key_word
        if self.field_list_shrink is not None:
            result['fieldList'] = self.field_list_shrink
        if self.instance_key is not None:
            result['instanceKey'] = self.instance_key
        if self.label_filter_shrink is not None:
            result['labelFilter'] = self.label_filter_shrink
        if self.latest_level is not None:
            result['latestLevel'] = self.latest_level
        if self.max_level is not None:
            result['maxLevel'] = self.max_level
        if self.notification_filter_shrink is not None:
            result['notificationFilter'] = self.notification_filter_shrink
        if self.start_time_from is not None:
            result['startTimeFrom'] = self.start_time_from
        if self.start_time_to is not None:
            result['startTimeTo'] = self.start_time_to
        if self.status is not None:
            result['status'] = self.status
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleId') is not None:
            self.alert_rule_id = m.get('alertRuleId')
        if m.get('bizSource') is not None:
            self.biz_source = m.get('bizSource')
        if m.get('displayNameKeyWord') is not None:
            self.display_name_key_word = m.get('displayNameKeyWord')
        if m.get('fieldList') is not None:
            self.field_list_shrink = m.get('fieldList')
        if m.get('instanceKey') is not None:
            self.instance_key = m.get('instanceKey')
        if m.get('labelFilter') is not None:
            self.label_filter_shrink = m.get('labelFilter')
        if m.get('latestLevel') is not None:
            self.latest_level = m.get('latestLevel')
        if m.get('maxLevel') is not None:
            self.max_level = m.get('maxLevel')
        if m.get('notificationFilter') is not None:
            self.notification_filter_shrink = m.get('notificationFilter')
        if m.get('startTimeFrom') is not None:
            self.start_time_from = m.get('startTimeFrom')
        if m.get('startTimeTo') is not None:
            self.start_time_to = m.get('startTimeTo')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CountAlertHistoriesByFieldsResponseBody(TeaModel):
    def __init__(
        self,
        data: Dict[str, dict] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.data = data
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class CountAlertHistoriesByFieldsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CountAlertHistoriesByFieldsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CountAlertHistoriesByFieldsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CountAlertHistoriesByTimeRequest(TeaModel):
    def __init__(
        self,
        alert_rule_id: str = None,
        biz_source: str = None,
        display_name_key_word: str = None,
        instance_key: str = None,
        interval: int = None,
        label_filter: AlertRuleLabelFilter = None,
        latest_level: str = None,
        max_level: str = None,
        notification_filter: AlertRuleNotificationFilter = None,
        start_time_from: int = None,
        start_time_to: int = None,
        status: str = None,
        workspace: str = None,
    ):
        self.alert_rule_id = alert_rule_id
        self.biz_source = biz_source
        self.display_name_key_word = display_name_key_word
        self.instance_key = instance_key
        self.interval = interval
        self.label_filter = label_filter
        self.latest_level = latest_level
        self.max_level = max_level
        self.notification_filter = notification_filter
        self.start_time_from = start_time_from
        self.start_time_to = start_time_to
        self.status = status
        self.workspace = workspace

    def validate(self):
        if self.label_filter:
            self.label_filter.validate()
        if self.notification_filter:
            self.notification_filter.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_id is not None:
            result['alertRuleId'] = self.alert_rule_id
        if self.biz_source is not None:
            result['bizSource'] = self.biz_source
        if self.display_name_key_word is not None:
            result['displayNameKeyWord'] = self.display_name_key_word
        if self.instance_key is not None:
            result['instanceKey'] = self.instance_key
        if self.interval is not None:
            result['interval'] = self.interval
        if self.label_filter is not None:
            result['labelFilter'] = self.label_filter.to_map()
        if self.latest_level is not None:
            result['latestLevel'] = self.latest_level
        if self.max_level is not None:
            result['maxLevel'] = self.max_level
        if self.notification_filter is not None:
            result['notificationFilter'] = self.notification_filter.to_map()
        if self.start_time_from is not None:
            result['startTimeFrom'] = self.start_time_from
        if self.start_time_to is not None:
            result['startTimeTo'] = self.start_time_to
        if self.status is not None:
            result['status'] = self.status
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleId') is not None:
            self.alert_rule_id = m.get('alertRuleId')
        if m.get('bizSource') is not None:
            self.biz_source = m.get('bizSource')
        if m.get('displayNameKeyWord') is not None:
            self.display_name_key_word = m.get('displayNameKeyWord')
        if m.get('instanceKey') is not None:
            self.instance_key = m.get('instanceKey')
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('labelFilter') is not None:
            temp_model = AlertRuleLabelFilter()
            self.label_filter = temp_model.from_map(m['labelFilter'])
        if m.get('latestLevel') is not None:
            self.latest_level = m.get('latestLevel')
        if m.get('maxLevel') is not None:
            self.max_level = m.get('maxLevel')
        if m.get('notificationFilter') is not None:
            temp_model = AlertRuleNotificationFilter()
            self.notification_filter = temp_model.from_map(m['notificationFilter'])
        if m.get('startTimeFrom') is not None:
            self.start_time_from = m.get('startTimeFrom')
        if m.get('startTimeTo') is not None:
            self.start_time_to = m.get('startTimeTo')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CountAlertHistoriesByTimeShrinkRequest(TeaModel):
    def __init__(
        self,
        alert_rule_id: str = None,
        biz_source: str = None,
        display_name_key_word: str = None,
        instance_key: str = None,
        interval: int = None,
        label_filter_shrink: str = None,
        latest_level: str = None,
        max_level: str = None,
        notification_filter_shrink: str = None,
        start_time_from: int = None,
        start_time_to: int = None,
        status: str = None,
        workspace: str = None,
    ):
        self.alert_rule_id = alert_rule_id
        self.biz_source = biz_source
        self.display_name_key_word = display_name_key_word
        self.instance_key = instance_key
        self.interval = interval
        self.label_filter_shrink = label_filter_shrink
        self.latest_level = latest_level
        self.max_level = max_level
        self.notification_filter_shrink = notification_filter_shrink
        self.start_time_from = start_time_from
        self.start_time_to = start_time_to
        self.status = status
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_id is not None:
            result['alertRuleId'] = self.alert_rule_id
        if self.biz_source is not None:
            result['bizSource'] = self.biz_source
        if self.display_name_key_word is not None:
            result['displayNameKeyWord'] = self.display_name_key_word
        if self.instance_key is not None:
            result['instanceKey'] = self.instance_key
        if self.interval is not None:
            result['interval'] = self.interval
        if self.label_filter_shrink is not None:
            result['labelFilter'] = self.label_filter_shrink
        if self.latest_level is not None:
            result['latestLevel'] = self.latest_level
        if self.max_level is not None:
            result['maxLevel'] = self.max_level
        if self.notification_filter_shrink is not None:
            result['notificationFilter'] = self.notification_filter_shrink
        if self.start_time_from is not None:
            result['startTimeFrom'] = self.start_time_from
        if self.start_time_to is not None:
            result['startTimeTo'] = self.start_time_to
        if self.status is not None:
            result['status'] = self.status
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleId') is not None:
            self.alert_rule_id = m.get('alertRuleId')
        if m.get('bizSource') is not None:
            self.biz_source = m.get('bizSource')
        if m.get('displayNameKeyWord') is not None:
            self.display_name_key_word = m.get('displayNameKeyWord')
        if m.get('instanceKey') is not None:
            self.instance_key = m.get('instanceKey')
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('labelFilter') is not None:
            self.label_filter_shrink = m.get('labelFilter')
        if m.get('latestLevel') is not None:
            self.latest_level = m.get('latestLevel')
        if m.get('maxLevel') is not None:
            self.max_level = m.get('maxLevel')
        if m.get('notificationFilter') is not None:
            self.notification_filter_shrink = m.get('notificationFilter')
        if m.get('startTimeFrom') is not None:
            self.start_time_from = m.get('startTimeFrom')
        if m.get('startTimeTo') is not None:
            self.start_time_to = m.get('startTimeTo')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CountAlertHistoriesByTimeResponseBodyData(TeaModel):
    def __init__(
        self,
        ts: int = None,
        value: int = None,
    ):
        self.ts = ts
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ts is not None:
            result['ts'] = self.ts
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ts') is not None:
            self.ts = m.get('ts')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class CountAlertHistoriesByTimeResponseBody(TeaModel):
    def __init__(
        self,
        data: List[CountAlertHistoriesByTimeResponseBodyData] = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = CountAlertHistoriesByTimeResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CountAlertHistoriesByTimeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CountAlertHistoriesByTimeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CountAlertHistoriesByTimeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CountAlertRulesByFieldsRequest(TeaModel):
    def __init__(
        self,
        biz_source: str = None,
        display_name_key_word: str = None,
        enabled: bool = None,
        field_list: List[str] = None,
        label_filter: AlertRuleLabelFilter = None,
        notification_filter: AlertRuleNotificationFilter = None,
        status: str = None,
        workspace: str = None,
    ):
        self.biz_source = biz_source
        self.display_name_key_word = display_name_key_word
        self.enabled = enabled
        self.field_list = field_list
        self.label_filter = label_filter
        self.notification_filter = notification_filter
        self.status = status
        self.workspace = workspace

    def validate(self):
        if self.label_filter:
            self.label_filter.validate()
        if self.notification_filter:
            self.notification_filter.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_source is not None:
            result['bizSource'] = self.biz_source
        if self.display_name_key_word is not None:
            result['displayNameKeyWord'] = self.display_name_key_word
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.field_list is not None:
            result['fieldList'] = self.field_list
        if self.label_filter is not None:
            result['labelFilter'] = self.label_filter.to_map()
        if self.notification_filter is not None:
            result['notificationFilter'] = self.notification_filter.to_map()
        if self.status is not None:
            result['status'] = self.status
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizSource') is not None:
            self.biz_source = m.get('bizSource')
        if m.get('displayNameKeyWord') is not None:
            self.display_name_key_word = m.get('displayNameKeyWord')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('fieldList') is not None:
            self.field_list = m.get('fieldList')
        if m.get('labelFilter') is not None:
            temp_model = AlertRuleLabelFilter()
            self.label_filter = temp_model.from_map(m['labelFilter'])
        if m.get('notificationFilter') is not None:
            temp_model = AlertRuleNotificationFilter()
            self.notification_filter = temp_model.from_map(m['notificationFilter'])
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CountAlertRulesByFieldsShrinkRequest(TeaModel):
    def __init__(
        self,
        biz_source: str = None,
        display_name_key_word: str = None,
        enabled: bool = None,
        field_list_shrink: str = None,
        label_filter_shrink: str = None,
        notification_filter_shrink: str = None,
        status: str = None,
        workspace: str = None,
    ):
        self.biz_source = biz_source
        self.display_name_key_word = display_name_key_word
        self.enabled = enabled
        self.field_list_shrink = field_list_shrink
        self.label_filter_shrink = label_filter_shrink
        self.notification_filter_shrink = notification_filter_shrink
        self.status = status
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_source is not None:
            result['bizSource'] = self.biz_source
        if self.display_name_key_word is not None:
            result['displayNameKeyWord'] = self.display_name_key_word
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.field_list_shrink is not None:
            result['fieldList'] = self.field_list_shrink
        if self.label_filter_shrink is not None:
            result['labelFilter'] = self.label_filter_shrink
        if self.notification_filter_shrink is not None:
            result['notificationFilter'] = self.notification_filter_shrink
        if self.status is not None:
            result['status'] = self.status
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizSource') is not None:
            self.biz_source = m.get('bizSource')
        if m.get('displayNameKeyWord') is not None:
            self.display_name_key_word = m.get('displayNameKeyWord')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('fieldList') is not None:
            self.field_list_shrink = m.get('fieldList')
        if m.get('labelFilter') is not None:
            self.label_filter_shrink = m.get('labelFilter')
        if m.get('notificationFilter') is not None:
            self.notification_filter_shrink = m.get('notificationFilter')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CountAlertRulesByFieldsResponseBody(TeaModel):
    def __init__(
        self,
        data: Dict[str, dict] = None,
        request_id: str = None,
        total_count: str = None,
    ):
        self.data = data
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class CountAlertRulesByFieldsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CountAlertRulesByFieldsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CountAlertRulesByFieldsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAddonReleaseRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        aliyun_lang: str = None,
        dry_run: bool = None,
        env_type: str = None,
        parent_addon_release_id: str = None,
        release_name: str = None,
        values: str = None,
        version: str = None,
        workspace: str = None,
    ):
        # This parameter is required.
        self.addon_name = addon_name
        self.aliyun_lang = aliyun_lang
        self.dry_run = dry_run
        self.env_type = env_type
        self.parent_addon_release_id = parent_addon_release_id
        self.release_name = release_name
        self.values = values
        # This parameter is required.
        self.version = version
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.dry_run is not None:
            result['dryRun'] = self.dry_run
        if self.env_type is not None:
            result['envType'] = self.env_type
        if self.parent_addon_release_id is not None:
            result['parentAddonReleaseId'] = self.parent_addon_release_id
        if self.release_name is not None:
            result['releaseName'] = self.release_name
        if self.values is not None:
            result['values'] = self.values
        if self.version is not None:
            result['version'] = self.version
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('dryRun') is not None:
            self.dry_run = m.get('dryRun')
        if m.get('envType') is not None:
            self.env_type = m.get('envType')
        if m.get('parentAddonReleaseId') is not None:
            self.parent_addon_release_id = m.get('parentAddonReleaseId')
        if m.get('releaseName') is not None:
            self.release_name = m.get('releaseName')
        if m.get('values') is not None:
            self.values = m.get('values')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateAddonReleaseResponseBodyReleaseConditions(TeaModel):
    def __init__(
        self,
        first_transition_time: str = None,
        last_transition_time: str = None,
        message: str = None,
        status: str = None,
        type: str = None,
    ):
        self.first_transition_time = first_transition_time
        self.last_transition_time = last_transition_time
        self.message = message
        self.status = status
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_transition_time is not None:
            result['firstTransitionTime'] = self.first_transition_time
        if self.last_transition_time is not None:
            result['lastTransitionTime'] = self.last_transition_time
        if self.message is not None:
            result['message'] = self.message
        if self.status is not None:
            result['status'] = self.status
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('firstTransitionTime') is not None:
            self.first_transition_time = m.get('firstTransitionTime')
        if m.get('lastTransitionTime') is not None:
            self.last_transition_time = m.get('lastTransitionTime')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateAddonReleaseResponseBodyRelease(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        alert_rule_count: int = None,
        conditions: List[CreateAddonReleaseResponseBodyReleaseConditions] = None,
        config: str = None,
        create_time: str = None,
        dashboard_count: int = None,
        env_type: str = None,
        environment_id: str = None,
        exporter_count: int = None,
        have_config: bool = None,
        install_user_id: str = None,
        language: str = None,
        managed: bool = None,
        parent_addon_release_id: str = None,
        policy_id: str = None,
        region_id: str = None,
        release_id: str = None,
        release_name: str = None,
        scene: str = None,
        status: str = None,
        update_time: str = None,
        user_id: str = None,
        version: str = None,
        workspace: str = None,
    ):
        self.addon_name = addon_name
        self.alert_rule_count = alert_rule_count
        self.conditions = conditions
        self.config = config
        self.create_time = create_time
        self.dashboard_count = dashboard_count
        self.env_type = env_type
        self.environment_id = environment_id
        self.exporter_count = exporter_count
        self.have_config = have_config
        self.install_user_id = install_user_id
        self.language = language
        self.managed = managed
        self.parent_addon_release_id = parent_addon_release_id
        self.policy_id = policy_id
        self.region_id = region_id
        self.release_id = release_id
        self.release_name = release_name
        self.scene = scene
        self.status = status
        self.update_time = update_time
        self.user_id = user_id
        self.version = version
        self.workspace = workspace

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.alert_rule_count is not None:
            result['alertRuleCount'] = self.alert_rule_count
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.config is not None:
            result['config'] = self.config
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.dashboard_count is not None:
            result['dashboardCount'] = self.dashboard_count
        if self.env_type is not None:
            result['envType'] = self.env_type
        if self.environment_id is not None:
            result['environmentId'] = self.environment_id
        if self.exporter_count is not None:
            result['exporterCount'] = self.exporter_count
        if self.have_config is not None:
            result['haveConfig'] = self.have_config
        if self.install_user_id is not None:
            result['installUserId'] = self.install_user_id
        if self.language is not None:
            result['language'] = self.language
        if self.managed is not None:
            result['managed'] = self.managed
        if self.parent_addon_release_id is not None:
            result['parentAddonReleaseId'] = self.parent_addon_release_id
        if self.policy_id is not None:
            result['policyId'] = self.policy_id
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.release_id is not None:
            result['releaseId'] = self.release_id
        if self.release_name is not None:
            result['releaseName'] = self.release_name
        if self.scene is not None:
            result['scene'] = self.scene
        if self.status is not None:
            result['status'] = self.status
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.version is not None:
            result['version'] = self.version
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('alertRuleCount') is not None:
            self.alert_rule_count = m.get('alertRuleCount')
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = CreateAddonReleaseResponseBodyReleaseConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('config') is not None:
            self.config = m.get('config')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('dashboardCount') is not None:
            self.dashboard_count = m.get('dashboardCount')
        if m.get('envType') is not None:
            self.env_type = m.get('envType')
        if m.get('environmentId') is not None:
            self.environment_id = m.get('environmentId')
        if m.get('exporterCount') is not None:
            self.exporter_count = m.get('exporterCount')
        if m.get('haveConfig') is not None:
            self.have_config = m.get('haveConfig')
        if m.get('installUserId') is not None:
            self.install_user_id = m.get('installUserId')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('managed') is not None:
            self.managed = m.get('managed')
        if m.get('parentAddonReleaseId') is not None:
            self.parent_addon_release_id = m.get('parentAddonReleaseId')
        if m.get('policyId') is not None:
            self.policy_id = m.get('policyId')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('releaseId') is not None:
            self.release_id = m.get('releaseId')
        if m.get('releaseName') is not None:
            self.release_name = m.get('releaseName')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateAddonReleaseResponseBody(TeaModel):
    def __init__(
        self,
        release: CreateAddonReleaseResponseBodyRelease = None,
        request_id: str = None,
    ):
        self.release = release
        self.request_id = request_id

    def validate(self):
        if self.release:
            self.release.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.release is not None:
            result['release'] = self.release.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('release') is not None:
            temp_model = CreateAddonReleaseResponseBodyRelease()
            self.release = temp_model.from_map(m['release'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateAddonReleaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAddonReleaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAddonReleaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAggTaskGroupRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class CreateAggTaskGroupRequest(TeaModel):
    def __init__(
        self,
        agg_task_group_config: str = None,
        agg_task_group_config_type: str = None,
        agg_task_group_name: str = None,
        cron_expr: str = None,
        delay: int = None,
        description: str = None,
        from_time: int = None,
        max_retries: int = None,
        max_run_time_in_seconds: int = None,
        precheck_string: str = None,
        schedule_mode: str = None,
        schedule_time_expr: str = None,
        status: str = None,
        tags: List[CreateAggTaskGroupRequestTags] = None,
        target_prometheus_id: str = None,
        to_time: int = None,
        override_if_exists: bool = None,
    ):
        # This parameter is required.
        self.agg_task_group_config = agg_task_group_config
        self.agg_task_group_config_type = agg_task_group_config_type
        # This parameter is required.
        self.agg_task_group_name = agg_task_group_name
        self.cron_expr = cron_expr
        self.delay = delay
        self.description = description
        self.from_time = from_time
        self.max_retries = max_retries
        self.max_run_time_in_seconds = max_run_time_in_seconds
        self.precheck_string = precheck_string
        self.schedule_mode = schedule_mode
        self.schedule_time_expr = schedule_time_expr
        self.status = status
        self.tags = tags
        # This parameter is required.
        self.target_prometheus_id = target_prometheus_id
        self.to_time = to_time
        self.override_if_exists = override_if_exists

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agg_task_group_config is not None:
            result['aggTaskGroupConfig'] = self.agg_task_group_config
        if self.agg_task_group_config_type is not None:
            result['aggTaskGroupConfigType'] = self.agg_task_group_config_type
        if self.agg_task_group_name is not None:
            result['aggTaskGroupName'] = self.agg_task_group_name
        if self.cron_expr is not None:
            result['cronExpr'] = self.cron_expr
        if self.delay is not None:
            result['delay'] = self.delay
        if self.description is not None:
            result['description'] = self.description
        if self.from_time is not None:
            result['fromTime'] = self.from_time
        if self.max_retries is not None:
            result['maxRetries'] = self.max_retries
        if self.max_run_time_in_seconds is not None:
            result['maxRunTimeInSeconds'] = self.max_run_time_in_seconds
        if self.precheck_string is not None:
            result['precheckString'] = self.precheck_string
        if self.schedule_mode is not None:
            result['scheduleMode'] = self.schedule_mode
        if self.schedule_time_expr is not None:
            result['scheduleTimeExpr'] = self.schedule_time_expr
        if self.status is not None:
            result['status'] = self.status
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.target_prometheus_id is not None:
            result['targetPrometheusId'] = self.target_prometheus_id
        if self.to_time is not None:
            result['toTime'] = self.to_time
        if self.override_if_exists is not None:
            result['overrideIfExists'] = self.override_if_exists
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aggTaskGroupConfig') is not None:
            self.agg_task_group_config = m.get('aggTaskGroupConfig')
        if m.get('aggTaskGroupConfigType') is not None:
            self.agg_task_group_config_type = m.get('aggTaskGroupConfigType')
        if m.get('aggTaskGroupName') is not None:
            self.agg_task_group_name = m.get('aggTaskGroupName')
        if m.get('cronExpr') is not None:
            self.cron_expr = m.get('cronExpr')
        if m.get('delay') is not None:
            self.delay = m.get('delay')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('fromTime') is not None:
            self.from_time = m.get('fromTime')
        if m.get('maxRetries') is not None:
            self.max_retries = m.get('maxRetries')
        if m.get('maxRunTimeInSeconds') is not None:
            self.max_run_time_in_seconds = m.get('maxRunTimeInSeconds')
        if m.get('precheckString') is not None:
            self.precheck_string = m.get('precheckString')
        if m.get('scheduleMode') is not None:
            self.schedule_mode = m.get('scheduleMode')
        if m.get('scheduleTimeExpr') is not None:
            self.schedule_time_expr = m.get('scheduleTimeExpr')
        if m.get('status') is not None:
            self.status = m.get('status')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = CreateAggTaskGroupRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('targetPrometheusId') is not None:
            self.target_prometheus_id = m.get('targetPrometheusId')
        if m.get('toTime') is not None:
            self.to_time = m.get('toTime')
        if m.get('overrideIfExists') is not None:
            self.override_if_exists = m.get('overrideIfExists')
        return self


class CreateAggTaskGroupResponseBody(TeaModel):
    def __init__(
        self,
        agg_task_group_config_hash: str = None,
        agg_task_group_id: str = None,
        agg_task_group_name: str = None,
        request_id: str = None,
        source_prometheus_id: str = None,
        status: str = None,
    ):
        self.agg_task_group_config_hash = agg_task_group_config_hash
        self.agg_task_group_id = agg_task_group_id
        self.agg_task_group_name = agg_task_group_name
        self.request_id = request_id
        self.source_prometheus_id = source_prometheus_id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agg_task_group_config_hash is not None:
            result['aggTaskGroupConfigHash'] = self.agg_task_group_config_hash
        if self.agg_task_group_id is not None:
            result['aggTaskGroupId'] = self.agg_task_group_id
        if self.agg_task_group_name is not None:
            result['aggTaskGroupName'] = self.agg_task_group_name
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.source_prometheus_id is not None:
            result['sourcePrometheusId'] = self.source_prometheus_id
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aggTaskGroupConfigHash') is not None:
            self.agg_task_group_config_hash = m.get('aggTaskGroupConfigHash')
        if m.get('aggTaskGroupId') is not None:
            self.agg_task_group_id = m.get('aggTaskGroupId')
        if m.get('aggTaskGroupName') is not None:
            self.agg_task_group_name = m.get('aggTaskGroupName')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('sourcePrometheusId') is not None:
            self.source_prometheus_id = m.get('sourcePrometheusId')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class CreateAggTaskGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAggTaskGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAggTaskGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAlertActionRequestEssParam(TeaModel):
    def __init__(
        self,
        ess_group_id: str = None,
        ess_rule_id: str = None,
        region_id: str = None,
    ):
        self.ess_group_id = ess_group_id
        self.ess_rule_id = ess_rule_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ess_group_id is not None:
            result['essGroupId'] = self.ess_group_id
        if self.ess_rule_id is not None:
            result['essRuleId'] = self.ess_rule_id
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('essGroupId') is not None:
            self.ess_group_id = m.get('essGroupId')
        if m.get('essRuleId') is not None:
            self.ess_rule_id = m.get('essRuleId')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class CreateAlertActionRequestFcParam(TeaModel):
    def __init__(
        self,
        function: str = None,
        region_id: str = None,
        service: str = None,
    ):
        self.function = function
        self.region_id = region_id
        self.service = service

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function is not None:
            result['function'] = self.function
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.service is not None:
            result['service'] = self.service
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('function') is not None:
            self.function = m.get('function')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('service') is not None:
            self.service = m.get('service')
        return self


class CreateAlertActionRequestMnsParam(TeaModel):
    def __init__(
        self,
        mns_type: str = None,
        name: str = None,
        region_id: str = None,
    ):
        self.mns_type = mns_type
        self.name = name
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mns_type is not None:
            result['mnsType'] = self.mns_type
        if self.name is not None:
            result['name'] = self.name
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('mnsType') is not None:
            self.mns_type = m.get('mnsType')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class CreateAlertActionRequestPagerDutyParam(TeaModel):
    def __init__(
        self,
        key: str = None,
        url: str = None,
    ):
        self.key = key
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class CreateAlertActionRequestSlsParam(TeaModel):
    def __init__(
        self,
        logstore: str = None,
        project: str = None,
        region_id: str = None,
    ):
        self.logstore = logstore
        self.project = project
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logstore is not None:
            result['logstore'] = self.logstore
        if self.project is not None:
            result['project'] = self.project
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('logstore') is not None:
            self.logstore = m.get('logstore')
        if m.get('project') is not None:
            self.project = m.get('project')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class CreateAlertActionRequestWebhookParam(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        headers: Dict[str, str] = None,
        method: str = None,
        url: str = None,
    ):
        self.content_type = content_type
        self.headers = headers
        self.method = method
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.headers is not None:
            result['headers'] = self.headers
        if self.method is not None:
            result['method'] = self.method
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('method') is not None:
            self.method = m.get('method')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class CreateAlertActionRequest(TeaModel):
    def __init__(
        self,
        alert_action_id: str = None,
        alert_action_name: str = None,
        ess_param: CreateAlertActionRequestEssParam = None,
        fc_param: CreateAlertActionRequestFcParam = None,
        mns_param: CreateAlertActionRequestMnsParam = None,
        pager_duty_param: CreateAlertActionRequestPagerDutyParam = None,
        sls_param: CreateAlertActionRequestSlsParam = None,
        source: str = None,
        type: str = None,
        webhook_param: CreateAlertActionRequestWebhookParam = None,
    ):
        self.alert_action_id = alert_action_id
        # This parameter is required.
        self.alert_action_name = alert_action_name
        self.ess_param = ess_param
        self.fc_param = fc_param
        self.mns_param = mns_param
        self.pager_duty_param = pager_duty_param
        self.sls_param = sls_param
        self.source = source
        # This parameter is required.
        self.type = type
        self.webhook_param = webhook_param

    def validate(self):
        if self.ess_param:
            self.ess_param.validate()
        if self.fc_param:
            self.fc_param.validate()
        if self.mns_param:
            self.mns_param.validate()
        if self.pager_duty_param:
            self.pager_duty_param.validate()
        if self.sls_param:
            self.sls_param.validate()
        if self.webhook_param:
            self.webhook_param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_action_id is not None:
            result['alertActionId'] = self.alert_action_id
        if self.alert_action_name is not None:
            result['alertActionName'] = self.alert_action_name
        if self.ess_param is not None:
            result['essParam'] = self.ess_param.to_map()
        if self.fc_param is not None:
            result['fcParam'] = self.fc_param.to_map()
        if self.mns_param is not None:
            result['mnsParam'] = self.mns_param.to_map()
        if self.pager_duty_param is not None:
            result['pagerDutyParam'] = self.pager_duty_param.to_map()
        if self.sls_param is not None:
            result['slsParam'] = self.sls_param.to_map()
        if self.source is not None:
            result['source'] = self.source
        if self.type is not None:
            result['type'] = self.type
        if self.webhook_param is not None:
            result['webhookParam'] = self.webhook_param.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertActionId') is not None:
            self.alert_action_id = m.get('alertActionId')
        if m.get('alertActionName') is not None:
            self.alert_action_name = m.get('alertActionName')
        if m.get('essParam') is not None:
            temp_model = CreateAlertActionRequestEssParam()
            self.ess_param = temp_model.from_map(m['essParam'])
        if m.get('fcParam') is not None:
            temp_model = CreateAlertActionRequestFcParam()
            self.fc_param = temp_model.from_map(m['fcParam'])
        if m.get('mnsParam') is not None:
            temp_model = CreateAlertActionRequestMnsParam()
            self.mns_param = temp_model.from_map(m['mnsParam'])
        if m.get('pagerDutyParam') is not None:
            temp_model = CreateAlertActionRequestPagerDutyParam()
            self.pager_duty_param = temp_model.from_map(m['pagerDutyParam'])
        if m.get('slsParam') is not None:
            temp_model = CreateAlertActionRequestSlsParam()
            self.sls_param = temp_model.from_map(m['slsParam'])
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('webhookParam') is not None:
            temp_model = CreateAlertActionRequestWebhookParam()
            self.webhook_param = temp_model.from_map(m['webhookParam'])
        return self


class CreateAlertActionResponseBody(TeaModel):
    def __init__(
        self,
        alert_action_id: str = None,
        request_id: str = None,
    ):
        self.alert_action_id = alert_action_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_action_id is not None:
            result['alertActionId'] = self.alert_action_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertActionId') is not None:
            self.alert_action_id = m.get('alertActionId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateAlertActionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAlertActionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAlertActionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAlertEventIntegrationPolicyRequest(TeaModel):
    def __init__(
        self,
        body: AlertEventIntegrationPolicyForModify = None,
        client_token: str = None,
        workspace: str = None,
    ):
        self.body = body
        self.client_token = client_token
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body.to_map()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            temp_model = AlertEventIntegrationPolicyForModify()
            self.body = temp_model.from_map(m['body'])
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateAlertEventIntegrationPolicyResponseBody(TeaModel):
    def __init__(
        self,
        alert_event_integration_policy_id: str = None,
        request_id: str = None,
    ):
        self.alert_event_integration_policy_id = alert_event_integration_policy_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_event_integration_policy_id is not None:
            result['alertEventIntegrationPolicyId'] = self.alert_event_integration_policy_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertEventIntegrationPolicyId') is not None:
            self.alert_event_integration_policy_id = m.get('alertEventIntegrationPolicyId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateAlertEventIntegrationPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAlertEventIntegrationPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAlertEventIntegrationPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAlertNotifyTemplateRequest(TeaModel):
    def __init__(
        self,
        alert_notify_template_id: str = None,
        alert_notify_template_name: str = None,
        program_lang: str = None,
        templates: Dict[str, dict] = None,
        type: str = None,
    ):
        # This parameter is required.
        self.alert_notify_template_id = alert_notify_template_id
        self.alert_notify_template_name = alert_notify_template_name
        self.program_lang = program_lang
        self.templates = templates
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_notify_template_id is not None:
            result['alertNotifyTemplateId'] = self.alert_notify_template_id
        if self.alert_notify_template_name is not None:
            result['alertNotifyTemplateName'] = self.alert_notify_template_name
        if self.program_lang is not None:
            result['programLang'] = self.program_lang
        if self.templates is not None:
            result['templates'] = self.templates
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertNotifyTemplateId') is not None:
            self.alert_notify_template_id = m.get('alertNotifyTemplateId')
        if m.get('alertNotifyTemplateName') is not None:
            self.alert_notify_template_name = m.get('alertNotifyTemplateName')
        if m.get('programLang') is not None:
            self.program_lang = m.get('programLang')
        if m.get('templates') is not None:
            self.templates = m.get('templates')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateAlertNotifyTemplateResponseBody(TeaModel):
    def __init__(
        self,
        alert_notify_template_id: str = None,
        request_id: str = None,
    ):
        self.alert_notify_template_id = alert_notify_template_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_notify_template_id is not None:
            result['alertNotifyTemplateId'] = self.alert_notify_template_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertNotifyTemplateId') is not None:
            self.alert_notify_template_id = m.get('alertNotifyTemplateId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateAlertNotifyTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAlertNotifyTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAlertNotifyTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAlertPushActionRequestFcParam(TeaModel):
    def __init__(
        self,
        function: str = None,
        region_id: str = None,
        service: str = None,
    ):
        self.function = function
        self.region_id = region_id
        self.service = service

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function is not None:
            result['function'] = self.function
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.service is not None:
            result['service'] = self.service
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('function') is not None:
            self.function = m.get('function')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('service') is not None:
            self.service = m.get('service')
        return self


class CreateAlertPushActionRequestSlsParam(TeaModel):
    def __init__(
        self,
        logstore: str = None,
        project: str = None,
        region_id: str = None,
    ):
        self.logstore = logstore
        self.project = project
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logstore is not None:
            result['logstore'] = self.logstore
        if self.project is not None:
            result['project'] = self.project
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('logstore') is not None:
            self.logstore = m.get('logstore')
        if m.get('project') is not None:
            self.project = m.get('project')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class CreateAlertPushActionRequest(TeaModel):
    def __init__(
        self,
        alert_push_actioni_d: str = None,
        fc_param: CreateAlertPushActionRequestFcParam = None,
        name: str = None,
        sls_param: CreateAlertPushActionRequestSlsParam = None,
        type: str = None,
    ):
        self.alert_push_actioni_d = alert_push_actioni_d
        self.fc_param = fc_param
        self.name = name
        self.sls_param = sls_param
        self.type = type

    def validate(self):
        if self.fc_param:
            self.fc_param.validate()
        if self.sls_param:
            self.sls_param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_push_actioni_d is not None:
            result['alertPushActioniD'] = self.alert_push_actioni_d
        if self.fc_param is not None:
            result['fcParam'] = self.fc_param.to_map()
        if self.name is not None:
            result['name'] = self.name
        if self.sls_param is not None:
            result['slsParam'] = self.sls_param.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertPushActioniD') is not None:
            self.alert_push_actioni_d = m.get('alertPushActioniD')
        if m.get('fcParam') is not None:
            temp_model = CreateAlertPushActionRequestFcParam()
            self.fc_param = temp_model.from_map(m['fcParam'])
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('slsParam') is not None:
            temp_model = CreateAlertPushActionRequestSlsParam()
            self.sls_param = temp_model.from_map(m['slsParam'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateAlertPushActionResponseBody(TeaModel):
    def __init__(
        self,
        alert_action_id: str = None,
        request_id: str = None,
    ):
        self.alert_action_id = alert_action_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_action_id is not None:
            result['alertActionId'] = self.alert_action_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertActionId') is not None:
            self.alert_action_id = m.get('alertActionId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateAlertPushActionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAlertPushActionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAlertPushActionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAlertRobotRequest(TeaModel):
    def __init__(
        self,
        is_custom: str = None,
        lang: str = None,
        name: str = None,
        robot_id: str = None,
        source: str = None,
        type: str = None,
        url: str = None,
    ):
        self.is_custom = is_custom
        self.lang = lang
        self.name = name
        self.robot_id = robot_id
        self.source = source
        # This parameter is required.
        self.type = type
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_custom is not None:
            result['isCustom'] = self.is_custom
        if self.lang is not None:
            result['lang'] = self.lang
        if self.name is not None:
            result['name'] = self.name
        if self.robot_id is not None:
            result['robotId'] = self.robot_id
        if self.source is not None:
            result['source'] = self.source
        if self.type is not None:
            result['type'] = self.type
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isCustom') is not None:
            self.is_custom = m.get('isCustom')
        if m.get('lang') is not None:
            self.lang = m.get('lang')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('robotId') is not None:
            self.robot_id = m.get('robotId')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class CreateAlertRobotResponseBody(TeaModel):
    def __init__(
        self,
        alert_robot_id: str = None,
        request_id: str = None,
    ):
        self.alert_robot_id = alert_robot_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_robot_id is not None:
            result['alertRobotId'] = self.alert_robot_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRobotId') is not None:
            self.alert_robot_id = m.get('alertRobotId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateAlertRobotResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAlertRobotResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAlertRobotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAlertRuleRequest(TeaModel):
    def __init__(
        self,
        alert_metric_input: AlertRuleAlertMetricInput = None,
        annotations: Dict[str, str] = None,
        biz_source: str = None,
        condition: AlertRuleCondition = None,
        datasource: AlertRuleDataSource = None,
        display_name: str = None,
        effect_time: AlertRuleTimeSpan = None,
        enabled: bool = None,
        interval: int = None,
        labels: Dict[str, str] = None,
        level: str = None,
        message: str = None,
        query: AlertRuleQuery = None,
        send: AlertRuleSend = None,
        workspace: str = None,
    ):
        self.alert_metric_input = alert_metric_input
        # 规则注解，允许设置长文本
        self.annotations = annotations
        # This parameter is required.
        self.biz_source = biz_source
        self.condition = condition
        # This parameter is required.
        self.datasource = datasource
        # 代表资源名称的资源属性字段
        # 
        # This parameter is required.
        self.display_name = display_name
        self.effect_time = effect_time
        # 是否启用
        self.enabled = enabled
        # 告警检查周期（单位：秒），默认60
        self.interval = interval
        self.labels = labels
        # 告警级别，CRITICAL,ERROR,WARNING,INFO，默认INFO，
        self.level = level
        # 告警规则的通知消息内容
        self.message = message
        # This parameter is required.
        self.query = query
        self.send = send
        # 工作空间
        self.workspace = workspace

    def validate(self):
        if self.alert_metric_input:
            self.alert_metric_input.validate()
        if self.condition:
            self.condition.validate()
        if self.datasource:
            self.datasource.validate()
        if self.effect_time:
            self.effect_time.validate()
        if self.query:
            self.query.validate()
        if self.send:
            self.send.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_metric_input is not None:
            result['alertMetricInput'] = self.alert_metric_input.to_map()
        if self.annotations is not None:
            result['annotations'] = self.annotations
        if self.biz_source is not None:
            result['bizSource'] = self.biz_source
        if self.condition is not None:
            result['condition'] = self.condition.to_map()
        if self.datasource is not None:
            result['datasource'] = self.datasource.to_map()
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.effect_time is not None:
            result['effectTime'] = self.effect_time.to_map()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.interval is not None:
            result['interval'] = self.interval
        if self.labels is not None:
            result['labels'] = self.labels
        if self.level is not None:
            result['level'] = self.level
        if self.message is not None:
            result['message'] = self.message
        if self.query is not None:
            result['query'] = self.query.to_map()
        if self.send is not None:
            result['send'] = self.send.to_map()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertMetricInput') is not None:
            temp_model = AlertRuleAlertMetricInput()
            self.alert_metric_input = temp_model.from_map(m['alertMetricInput'])
        if m.get('annotations') is not None:
            self.annotations = m.get('annotations')
        if m.get('bizSource') is not None:
            self.biz_source = m.get('bizSource')
        if m.get('condition') is not None:
            temp_model = AlertRuleCondition()
            self.condition = temp_model.from_map(m['condition'])
        if m.get('datasource') is not None:
            temp_model = AlertRuleDataSource()
            self.datasource = temp_model.from_map(m['datasource'])
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('effectTime') is not None:
            temp_model = AlertRuleTimeSpan()
            self.effect_time = temp_model.from_map(m['effectTime'])
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('query') is not None:
            temp_model = AlertRuleQuery()
            self.query = temp_model.from_map(m['query'])
        if m.get('send') is not None:
            temp_model = AlertRuleSend()
            self.send = temp_model.from_map(m['send'])
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        alert_rule_id: str = None,
        request_id: str = None,
    ):
        self.alert_rule_id = alert_rule_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_id is not None:
            result['alertRuleId'] = self.alert_rule_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleId') is not None:
            self.alert_rule_id = m.get('alertRuleId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAlertWebhookRequest(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        headers: Dict[str, str] = None,
        is_custom: str = None,
        lang: str = None,
        method: str = None,
        name: str = None,
        source: str = None,
        url: str = None,
        webhook_id: str = None,
    ):
        self.content_type = content_type
        self.headers = headers
        self.is_custom = is_custom
        self.lang = lang
        self.method = method
        # This parameter is required.
        self.name = name
        self.source = source
        # This parameter is required.
        self.url = url
        self.webhook_id = webhook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.headers is not None:
            result['headers'] = self.headers
        if self.is_custom is not None:
            result['isCustom'] = self.is_custom
        if self.lang is not None:
            result['lang'] = self.lang
        if self.method is not None:
            result['method'] = self.method
        if self.name is not None:
            result['name'] = self.name
        if self.source is not None:
            result['source'] = self.source
        if self.url is not None:
            result['url'] = self.url
        if self.webhook_id is not None:
            result['webhookId'] = self.webhook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('isCustom') is not None:
            self.is_custom = m.get('isCustom')
        if m.get('lang') is not None:
            self.lang = m.get('lang')
        if m.get('method') is not None:
            self.method = m.get('method')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('webhookId') is not None:
            self.webhook_id = m.get('webhookId')
        return self


class CreateAlertWebhookResponseBody(TeaModel):
    def __init__(
        self,
        alert_webhook_id: str = None,
        request_id: str = None,
    ):
        self.alert_webhook_id = alert_webhook_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_webhook_id is not None:
            result['alertWebhookId'] = self.alert_webhook_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertWebhookId') is not None:
            self.alert_webhook_id = m.get('alertWebhookId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateAlertWebhookResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAlertWebhookResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAlertWebhookResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateApplicationInsightsInstanceRequest(TeaModel):
    def __init__(
        self,
        app_codes: List[str] = None,
        workspace_name: str = None,
    ):
        self.app_codes = app_codes
        self.workspace_name = workspace_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_codes is not None:
            result['appCodes'] = self.app_codes
        if self.workspace_name is not None:
            result['workspaceName'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appCodes') is not None:
            self.app_codes = m.get('appCodes')
        if m.get('workspaceName') is not None:
            self.workspace_name = m.get('workspaceName')
        return self


class CreateApplicationInsightsInstanceResponseBody(TeaModel):
    def __init__(
        self,
        entity_store: str = None,
        request_id: str = None,
        storages: Dict[str, List[DataStorageItem]] = None,
        topo_store: str = None,
        workspace_name: str = None,
        workspace_project: str = None,
        workspace_region_id: str = None,
    ):
        self.entity_store = entity_store
        self.request_id = request_id
        self.storages = storages
        self.topo_store = topo_store
        self.workspace_name = workspace_name
        self.workspace_project = workspace_project
        self.workspace_region_id = workspace_region_id

    def validate(self):
        if self.storages:
            for v in self.storages.values():
                for k1 in v:
                    if k1:
                        k1.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_store is not None:
            result['entityStore'] = self.entity_store
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['storages'] = {}
        if self.storages is not None:
            for k, v in self.storages.items():
                l1 = []
                for k1 in v:
                    l1.append(k1.to_map() if k1 else None)
                result['storages'][k] = l1
        if self.topo_store is not None:
            result['topoStore'] = self.topo_store
        if self.workspace_name is not None:
            result['workspaceName'] = self.workspace_name
        if self.workspace_project is not None:
            result['workspaceProject'] = self.workspace_project
        if self.workspace_region_id is not None:
            result['workspaceRegionId'] = self.workspace_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('entityStore') is not None:
            self.entity_store = m.get('entityStore')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.storages = {}
        if m.get('storages') is not None:
            for k, v in m.get('storages').items():
                l1 = []
                for k1 in v:
                    temp_model = DataStorageItem()
                    l1.append(temp_model.from_map(k1))
                self.storages['k'] = l1
        if m.get('topoStore') is not None:
            self.topo_store = m.get('topoStore')
        if m.get('workspaceName') is not None:
            self.workspace_name = m.get('workspaceName')
        if m.get('workspaceProject') is not None:
            self.workspace_project = m.get('workspaceProject')
        if m.get('workspaceRegionId') is not None:
            self.workspace_region_id = m.get('workspaceRegionId')
        return self


class CreateApplicationInsightsInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateApplicationInsightsInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateApplicationInsightsInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateBizTraceRequest(TeaModel):
    def __init__(
        self,
        advanced_config: str = None,
        biz_trace_code: str = None,
        biz_trace_name: str = None,
        rule_config: str = None,
        workspace: str = None,
    ):
        self.advanced_config = advanced_config
        self.biz_trace_code = biz_trace_code
        self.biz_trace_name = biz_trace_name
        self.rule_config = rule_config
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advanced_config is not None:
            result['advancedConfig'] = self.advanced_config
        if self.biz_trace_code is not None:
            result['bizTraceCode'] = self.biz_trace_code
        if self.biz_trace_name is not None:
            result['bizTraceName'] = self.biz_trace_name
        if self.rule_config is not None:
            result['ruleConfig'] = self.rule_config
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('advancedConfig') is not None:
            self.advanced_config = m.get('advancedConfig')
        if m.get('bizTraceCode') is not None:
            self.biz_trace_code = m.get('bizTraceCode')
        if m.get('bizTraceName') is not None:
            self.biz_trace_name = m.get('bizTraceName')
        if m.get('ruleConfig') is not None:
            self.rule_config = m.get('ruleConfig')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateBizTraceResponseBody(TeaModel):
    def __init__(
        self,
        biz_trace_id: str = None,
        request_id: str = None,
    ):
        self.biz_trace_id = biz_trace_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_trace_id is not None:
            result['bizTraceId'] = self.biz_trace_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizTraceId') is not None:
            self.biz_trace_id = m.get('bizTraceId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateBizTraceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateBizTraceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateBizTraceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCloudResourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateCloudResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCloudResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCloudResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateContactRequest(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        email: str = None,
        im_user_ids: Dict[str, str] = None,
        is_inner_call: bool = None,
        lang: str = None,
        name: str = None,
        phone: str = None,
        phone_code: str = None,
        source: str = None,
    ):
        self.contact_id = contact_id
        self.email = email
        self.im_user_ids = im_user_ids
        self.is_inner_call = is_inner_call
        self.lang = lang
        self.name = name
        self.phone = phone
        self.phone_code = phone_code
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['contactId'] = self.contact_id
        if self.email is not None:
            result['email'] = self.email
        if self.im_user_ids is not None:
            result['imUserIds'] = self.im_user_ids
        if self.is_inner_call is not None:
            result['isInnerCall'] = self.is_inner_call
        if self.lang is not None:
            result['lang'] = self.lang
        if self.name is not None:
            result['name'] = self.name
        if self.phone is not None:
            result['phone'] = self.phone
        if self.phone_code is not None:
            result['phoneCode'] = self.phone_code
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactId') is not None:
            self.contact_id = m.get('contactId')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('imUserIds') is not None:
            self.im_user_ids = m.get('imUserIds')
        if m.get('isInnerCall') is not None:
            self.is_inner_call = m.get('isInnerCall')
        if m.get('lang') is not None:
            self.lang = m.get('lang')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('phone') is not None:
            self.phone = m.get('phone')
        if m.get('phoneCode') is not None:
            self.phone_code = m.get('phoneCode')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class CreateContactResponseBody(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        request_id: str = None,
    ):
        self.contact_id = contact_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['contactId'] = self.contact_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactId') is not None:
            self.contact_id = m.get('contactId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateContactResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateContactResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateContactResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateContactGroupRequest(TeaModel):
    def __init__(
        self,
        contact_group_id: str = None,
        contacts: List[str] = None,
        name: str = None,
        source: str = None,
    ):
        self.contact_group_id = contact_group_id
        self.contacts = contacts
        self.name = name
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_id is not None:
            result['contactGroupId'] = self.contact_group_id
        if self.contacts is not None:
            result['contacts'] = self.contacts
        if self.name is not None:
            result['name'] = self.name
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactGroupId') is not None:
            self.contact_group_id = m.get('contactGroupId')
        if m.get('contacts') is not None:
            self.contacts = m.get('contacts')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class CreateContactGroupResponseBody(TeaModel):
    def __init__(
        self,
        contact_group_id: str = None,
        request_id: str = None,
    ):
        self.contact_group_id = contact_group_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_id is not None:
            result['contactGroupId'] = self.contact_group_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactGroupId') is not None:
            self.contact_group_id = m.get('contactGroupId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateContactGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateContactGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateContactGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEntityGroupRequestEntityRulesAnnotations(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class CreateEntityGroupRequestEntityRulesFieldRules(TeaModel):
    def __init__(
        self,
        field_key: str = None,
        field_values: List[str] = None,
        op: str = None,
    ):
        self.field_key = field_key
        self.field_values = field_values
        self.op = op

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_key is not None:
            result['fieldKey'] = self.field_key
        if self.field_values is not None:
            result['fieldValues'] = self.field_values
        if self.op is not None:
            result['op'] = self.op
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldKey') is not None:
            self.field_key = m.get('fieldKey')
        if m.get('fieldValues') is not None:
            self.field_values = m.get('fieldValues')
        if m.get('op') is not None:
            self.op = m.get('op')
        return self


class CreateEntityGroupRequestEntityRulesIpMatchRule(TeaModel):
    def __init__(
        self,
        ip_cidr: str = None,
        ip_field_key: str = None,
    ):
        self.ip_cidr = ip_cidr
        self.ip_field_key = ip_field_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_cidr is not None:
            result['ipCIDR'] = self.ip_cidr
        if self.ip_field_key is not None:
            result['ipFieldKey'] = self.ip_field_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ipCIDR') is not None:
            self.ip_cidr = m.get('ipCIDR')
        if m.get('ipFieldKey') is not None:
            self.ip_field_key = m.get('ipFieldKey')
        return self


class CreateEntityGroupRequestEntityRulesLabels(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class CreateEntityGroupRequestEntityRulesTags(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class CreateEntityGroupRequestEntityRules(TeaModel):
    def __init__(
        self,
        annotations: List[CreateEntityGroupRequestEntityRulesAnnotations] = None,
        entity_types: List[str] = None,
        field_rules: List[CreateEntityGroupRequestEntityRulesFieldRules] = None,
        instance_ids: List[str] = None,
        ip_match_rule: CreateEntityGroupRequestEntityRulesIpMatchRule = None,
        labels: List[CreateEntityGroupRequestEntityRulesLabels] = None,
        region_ids: List[str] = None,
        resource_group_id: str = None,
        tags: List[CreateEntityGroupRequestEntityRulesTags] = None,
    ):
        self.annotations = annotations
        self.entity_types = entity_types
        self.field_rules = field_rules
        self.instance_ids = instance_ids
        self.ip_match_rule = ip_match_rule
        self.labels = labels
        self.region_ids = region_ids
        self.resource_group_id = resource_group_id
        self.tags = tags

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.field_rules:
            for k in self.field_rules:
                if k:
                    k.validate()
        if self.ip_match_rule:
            self.ip_match_rule.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        if self.entity_types is not None:
            result['entityTypes'] = self.entity_types
        result['fieldRules'] = []
        if self.field_rules is not None:
            for k in self.field_rules:
                result['fieldRules'].append(k.to_map() if k else None)
        if self.instance_ids is not None:
            result['instanceIds'] = self.instance_ids
        if self.ip_match_rule is not None:
            result['ipMatchRule'] = self.ip_match_rule.to_map()
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.region_ids is not None:
            result['regionIds'] = self.region_ids
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = CreateEntityGroupRequestEntityRulesAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('entityTypes') is not None:
            self.entity_types = m.get('entityTypes')
        self.field_rules = []
        if m.get('fieldRules') is not None:
            for k in m.get('fieldRules'):
                temp_model = CreateEntityGroupRequestEntityRulesFieldRules()
                self.field_rules.append(temp_model.from_map(k))
        if m.get('instanceIds') is not None:
            self.instance_ids = m.get('instanceIds')
        if m.get('ipMatchRule') is not None:
            temp_model = CreateEntityGroupRequestEntityRulesIpMatchRule()
            self.ip_match_rule = temp_model.from_map(m['ipMatchRule'])
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = CreateEntityGroupRequestEntityRulesLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('regionIds') is not None:
            self.region_ids = m.get('regionIds')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = CreateEntityGroupRequestEntityRulesTags()
                self.tags.append(temp_model.from_map(k))
        return self


class CreateEntityGroupRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        entity_group_name: str = None,
        entity_rules: CreateEntityGroupRequestEntityRules = None,
        workspace: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.entity_group_name = entity_group_name
        # This parameter is required.
        self.entity_rules = entity_rules
        self.workspace = workspace

    def validate(self):
        if self.entity_rules:
            self.entity_rules.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.entity_group_name is not None:
            result['entityGroupName'] = self.entity_group_name
        if self.entity_rules is not None:
            result['entityRules'] = self.entity_rules.to_map()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('entityGroupName') is not None:
            self.entity_group_name = m.get('entityGroupName')
        if m.get('entityRules') is not None:
            temp_model = CreateEntityGroupRequestEntityRules()
            self.entity_rules = temp_model.from_map(m['entityRules'])
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateEntityGroupResponseBody(TeaModel):
    def __init__(
        self,
        entity_group_id: str = None,
        region_id: str = None,
        request_id: str = None,
        user_id: str = None,
        workspace: str = None,
    ):
        self.entity_group_id = entity_group_id
        self.region_id = region_id
        self.request_id = request_id
        self.user_id = user_id
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_group_id is not None:
            result['entityGroupId'] = self.entity_group_id
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('entityGroupId') is not None:
            self.entity_group_id = m.get('entityGroupId')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateEntityGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEntityGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEntityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEntityStoreResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        workspace_name: str = None,
    ):
        self.request_id = request_id
        self.workspace_name = workspace_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.workspace_name is not None:
            result['workspaceName'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('workspaceName') is not None:
            self.workspace_name = m.get('workspaceName')
        return self


class CreateEntityStoreResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEntityStoreResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEntityStoreResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEnvironmentRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateEnvironmentRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        bind_resource_id: str = None,
        environment_name: str = None,
        environment_sub_type: str = None,
        environment_type: str = None,
        fee_package: str = None,
        init_environment: bool = None,
        managed_type: str = None,
        prometheus_instance_id: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tags: List[CreateEnvironmentRequestTags] = None,
        workspace: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        # This parameter is required.
        self.bind_resource_id = bind_resource_id
        # This parameter is required.
        self.environment_name = environment_name
        # This parameter is required.
        self.environment_sub_type = environment_sub_type
        # This parameter is required.
        self.environment_type = environment_type
        self.fee_package = fee_package
        self.init_environment = init_environment
        self.managed_type = managed_type
        self.prometheus_instance_id = prometheus_instance_id
        # This parameter is required.
        self.region_id = region_id
        self.resource_group_id = resource_group_id
        self.tags = tags
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.bind_resource_id is not None:
            result['BindResourceId'] = self.bind_resource_id
        if self.environment_name is not None:
            result['EnvironmentName'] = self.environment_name
        if self.environment_sub_type is not None:
            result['EnvironmentSubType'] = self.environment_sub_type
        if self.environment_type is not None:
            result['EnvironmentType'] = self.environment_type
        if self.fee_package is not None:
            result['FeePackage'] = self.fee_package
        if self.init_environment is not None:
            result['InitEnvironment'] = self.init_environment
        if self.managed_type is not None:
            result['ManagedType'] = self.managed_type
        if self.prometheus_instance_id is not None:
            result['PrometheusInstanceId'] = self.prometheus_instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.workspace is not None:
            result['Workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('BindResourceId') is not None:
            self.bind_resource_id = m.get('BindResourceId')
        if m.get('EnvironmentName') is not None:
            self.environment_name = m.get('EnvironmentName')
        if m.get('EnvironmentSubType') is not None:
            self.environment_sub_type = m.get('EnvironmentSubType')
        if m.get('EnvironmentType') is not None:
            self.environment_type = m.get('EnvironmentType')
        if m.get('FeePackage') is not None:
            self.fee_package = m.get('FeePackage')
        if m.get('InitEnvironment') is not None:
            self.init_environment = m.get('InitEnvironment')
        if m.get('ManagedType') is not None:
            self.managed_type = m.get('ManagedType')
        if m.get('PrometheusInstanceId') is not None:
            self.prometheus_instance_id = m.get('PrometheusInstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = CreateEnvironmentRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Workspace') is not None:
            self.workspace = m.get('Workspace')
        return self


class CreateEnvironmentResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateEnvironmentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEnvironmentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEnvironmentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEscalationRequest(TeaModel):
    def __init__(
        self,
        body: EscalationForUpdate = None,
        workspace: str = None,
    ):
        self.body = body
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body.to_map()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            temp_model = EscalationForUpdate()
            self.body = temp_model.from_map(m['body'])
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateEscalationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        uuid: str = None,
    ):
        self.request_id = request_id
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class CreateEscalationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEscalationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEscalationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateIncidentEscalationRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        stage: List[IncidentEscalationStageStruct] = None,
        workspace: str = None,
    ):
        self.description = description
        self.name = name
        self.stage = stage
        self.workspace = workspace

    def validate(self):
        if self.stage:
            for k in self.stage:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        result['stage'] = []
        if self.stage is not None:
            for k in self.stage:
                result['stage'].append(k.to_map() if k else None)
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.stage = []
        if m.get('stage') is not None:
            for k in m.get('stage'):
                temp_model = IncidentEscalationStageStruct()
                self.stage.append(temp_model.from_map(k))
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateIncidentEscalationResponseBody(TeaModel):
    def __init__(
        self,
        incident_escalation_id: str = None,
        request_id: str = None,
    ):
        self.incident_escalation_id = incident_escalation_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.incident_escalation_id is not None:
            result['incidentEscalationId'] = self.incident_escalation_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('incidentEscalationId') is not None:
            self.incident_escalation_id = m.get('incidentEscalationId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateIncidentEscalationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateIncidentEscalationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateIncidentEscalationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateIncidentPlanRequestCorporation(TeaModel):
    def __init__(
        self,
        channel: str = None,
        robot_id: str = None,
    ):
        self.channel = channel
        self.robot_id = robot_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel is not None:
            result['channel'] = self.channel
        if self.robot_id is not None:
            result['robotId'] = self.robot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('channel') is not None:
            self.channel = m.get('channel')
        if m.get('robotId') is not None:
            self.robot_id = m.get('robotId')
        return self


class CreateIncidentPlanRequest(TeaModel):
    def __init__(
        self,
        auto_recover_seconds: int = None,
        corporation: List[CreateIncidentPlanRequestCorporation] = None,
        description: str = None,
        escalation_id: List[str] = None,
        group_by: List[IncidentPlanFieldPath] = None,
        name: str = None,
        resource_field: List[IncidentPlanFieldPath] = None,
        workspace: str = None,
    ):
        self.auto_recover_seconds = auto_recover_seconds
        self.corporation = corporation
        self.description = description
        self.escalation_id = escalation_id
        self.group_by = group_by
        self.name = name
        self.resource_field = resource_field
        self.workspace = workspace

    def validate(self):
        if self.corporation:
            for k in self.corporation:
                if k:
                    k.validate()
        if self.group_by:
            for k in self.group_by:
                if k:
                    k.validate()
        if self.resource_field:
            for k in self.resource_field:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_recover_seconds is not None:
            result['autoRecoverSeconds'] = self.auto_recover_seconds
        result['corporation'] = []
        if self.corporation is not None:
            for k in self.corporation:
                result['corporation'].append(k.to_map() if k else None)
        if self.description is not None:
            result['description'] = self.description
        if self.escalation_id is not None:
            result['escalationId'] = self.escalation_id
        result['groupBy'] = []
        if self.group_by is not None:
            for k in self.group_by:
                result['groupBy'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        result['resourceField'] = []
        if self.resource_field is not None:
            for k in self.resource_field:
                result['resourceField'].append(k.to_map() if k else None)
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('autoRecoverSeconds') is not None:
            self.auto_recover_seconds = m.get('autoRecoverSeconds')
        self.corporation = []
        if m.get('corporation') is not None:
            for k in m.get('corporation'):
                temp_model = CreateIncidentPlanRequestCorporation()
                self.corporation.append(temp_model.from_map(k))
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('escalationId') is not None:
            self.escalation_id = m.get('escalationId')
        self.group_by = []
        if m.get('groupBy') is not None:
            for k in m.get('groupBy'):
                temp_model = IncidentPlanFieldPath()
                self.group_by.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        self.resource_field = []
        if m.get('resourceField') is not None:
            for k in m.get('resourceField'):
                temp_model = IncidentPlanFieldPath()
                self.resource_field.append(temp_model.from_map(k))
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateIncidentPlanResponseBody(TeaModel):
    def __init__(
        self,
        incident_plan_id: str = None,
        request_id: str = None,
    ):
        self.incident_plan_id = incident_plan_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.incident_plan_id is not None:
            result['incidentPlanId'] = self.incident_plan_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('incidentPlanId') is not None:
            self.incident_plan_id = m.get('incidentPlanId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateIncidentPlanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateIncidentPlanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateIncidentPlanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateIntegrationRequest(TeaModel):
    def __init__(
        self,
        body: IntegrationForModify = None,
        client_token: str = None,
        workspace: str = None,
    ):
        self.body = body
        self.client_token = client_token
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body.to_map()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            temp_model = IntegrationForModify()
            self.body = temp_model.from_map(m['body'])
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        integration_id: str = None,
        request_id: str = None,
    ):
        self.integration_id = integration_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integration_id is not None:
            result['integrationId'] = self.integration_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('integrationId') is not None:
            self.integration_id = m.get('integrationId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateIntegrationPolicyRequestEntityGroup(TeaModel):
    def __init__(
        self,
        cluster_entity_type: str = None,
        cluster_id: str = None,
        entity_group_id: str = None,
        vpc_id: str = None,
    ):
        self.cluster_entity_type = cluster_entity_type
        self.cluster_id = cluster_id
        self.entity_group_id = entity_group_id
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_entity_type is not None:
            result['clusterEntityType'] = self.cluster_entity_type
        if self.cluster_id is not None:
            result['clusterId'] = self.cluster_id
        if self.entity_group_id is not None:
            result['entityGroupId'] = self.entity_group_id
        if self.vpc_id is not None:
            result['vpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterEntityType') is not None:
            self.cluster_entity_type = m.get('clusterEntityType')
        if m.get('clusterId') is not None:
            self.cluster_id = m.get('clusterId')
        if m.get('entityGroupId') is not None:
            self.entity_group_id = m.get('entityGroupId')
        if m.get('vpcId') is not None:
            self.vpc_id = m.get('vpcId')
        return self


class CreateIntegrationPolicyRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class CreateIntegrationPolicyRequest(TeaModel):
    def __init__(
        self,
        entity_group: CreateIntegrationPolicyRequestEntityGroup = None,
        policy_name: str = None,
        policy_type: str = None,
        resource_group_id: str = None,
        tags: List[CreateIntegrationPolicyRequestTags] = None,
        workspace: str = None,
    ):
        self.entity_group = entity_group
        self.policy_name = policy_name
        # This parameter is required.
        self.policy_type = policy_type
        self.resource_group_id = resource_group_id
        self.tags = tags
        self.workspace = workspace

    def validate(self):
        if self.entity_group:
            self.entity_group.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_group is not None:
            result['entityGroup'] = self.entity_group.to_map()
        if self.policy_name is not None:
            result['policyName'] = self.policy_name
        if self.policy_type is not None:
            result['policyType'] = self.policy_type
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('entityGroup') is not None:
            temp_model = CreateIntegrationPolicyRequestEntityGroup()
            self.entity_group = temp_model.from_map(m['entityGroup'])
        if m.get('policyName') is not None:
            self.policy_name = m.get('policyName')
        if m.get('policyType') is not None:
            self.policy_type = m.get('policyType')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = CreateIntegrationPolicyRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateIntegrationPolicyResponseBodyPolicy(TeaModel):
    def __init__(
        self,
        entity_group_id: str = None,
        policy_id: str = None,
        policy_name: str = None,
        policy_type: str = None,
        region_id: str = None,
        user_id: str = None,
        workspace: str = None,
    ):
        self.entity_group_id = entity_group_id
        self.policy_id = policy_id
        self.policy_name = policy_name
        self.policy_type = policy_type
        self.region_id = region_id
        self.user_id = user_id
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_group_id is not None:
            result['entityGroupId'] = self.entity_group_id
        if self.policy_id is not None:
            result['policyId'] = self.policy_id
        if self.policy_name is not None:
            result['policyName'] = self.policy_name
        if self.policy_type is not None:
            result['policyType'] = self.policy_type
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('entityGroupId') is not None:
            self.entity_group_id = m.get('entityGroupId')
        if m.get('policyId') is not None:
            self.policy_id = m.get('policyId')
        if m.get('policyName') is not None:
            self.policy_name = m.get('policyName')
        if m.get('policyType') is not None:
            self.policy_type = m.get('policyType')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateIntegrationPolicyResponseBody(TeaModel):
    def __init__(
        self,
        created: bool = None,
        policy: CreateIntegrationPolicyResponseBodyPolicy = None,
        request_id: str = None,
    ):
        self.created = created
        self.policy = policy
        self.request_id = request_id

    def validate(self):
        if self.policy:
            self.policy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created is not None:
            result['created'] = self.created
        if self.policy is not None:
            result['policy'] = self.policy.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created') is not None:
            self.created = m.get('created')
        if m.get('policy') is not None:
            temp_model = CreateIntegrationPolicyResponseBodyPolicy()
            self.policy = temp_model.from_map(m['policy'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateIntegrationPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateIntegrationPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateIntegrationPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMaintainWindowRequest(TeaModel):
    def __init__(
        self,
        body: MaintainWindowForModify = None,
        client_token: str = None,
        workspace: str = None,
    ):
        self.body = body
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body.to_map()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            temp_model = MaintainWindowForModify()
            self.body = temp_model.from_map(m['body'])
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateMaintainWindowResponseBody(TeaModel):
    def __init__(
        self,
        maintain_window_id: str = None,
        request_id: str = None,
    ):
        self.maintain_window_id = maintain_window_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.maintain_window_id is not None:
            result['maintainWindowId'] = self.maintain_window_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maintainWindowId') is not None:
            self.maintain_window_id = m.get('maintainWindowId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateMaintainWindowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMaintainWindowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMaintainWindowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNotifyStrategyRequest(TeaModel):
    def __init__(
        self,
        body: NotifyStrategyForModify = None,
        client_token: str = None,
        workspace: str = None,
    ):
        self.body = body
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body.to_map()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            temp_model = NotifyStrategyForModify()
            self.body = temp_model.from_map(m['body'])
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateNotifyStrategyResponseBody(TeaModel):
    def __init__(
        self,
        notify_strategy_id: str = None,
        request_id: str = None,
    ):
        self.notify_strategy_id = notify_strategy_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify_strategy_id is not None:
            result['notifyStrategyId'] = self.notify_strategy_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('notifyStrategyId') is not None:
            self.notify_strategy_id = m.get('notifyStrategyId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateNotifyStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateNotifyStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNotifyStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOncallScheduleRequestRotations(TeaModel):
    def __init__(
        self,
        active_days: List[int] = None,
        contacts: List[str] = None,
        rotation_end_time: str = None,
        rotation_name: str = None,
        rotation_start_time: str = None,
        shift_length: int = None,
        shift_recurrence_frequency: str = None,
        start_date: str = None,
        time_zone: str = None,
    ):
        # This parameter is required.
        self.active_days = active_days
        # This parameter is required.
        self.contacts = contacts
        # This parameter is required.
        self.rotation_end_time = rotation_end_time
        # This parameter is required.
        self.rotation_name = rotation_name
        # This parameter is required.
        self.rotation_start_time = rotation_start_time
        self.shift_length = shift_length
        # This parameter is required.
        self.shift_recurrence_frequency = shift_recurrence_frequency
        # This parameter is required.
        self.start_date = start_date
        # This parameter is required.
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_days is not None:
            result['activeDays'] = self.active_days
        if self.contacts is not None:
            result['contacts'] = self.contacts
        if self.rotation_end_time is not None:
            result['rotationEndTime'] = self.rotation_end_time
        if self.rotation_name is not None:
            result['rotationName'] = self.rotation_name
        if self.rotation_start_time is not None:
            result['rotationStartTime'] = self.rotation_start_time
        if self.shift_length is not None:
            result['shiftLength'] = self.shift_length
        if self.shift_recurrence_frequency is not None:
            result['shiftRecurrenceFrequency'] = self.shift_recurrence_frequency
        if self.start_date is not None:
            result['startDate'] = self.start_date
        if self.time_zone is not None:
            result['timeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('activeDays') is not None:
            self.active_days = m.get('activeDays')
        if m.get('contacts') is not None:
            self.contacts = m.get('contacts')
        if m.get('rotationEndTime') is not None:
            self.rotation_end_time = m.get('rotationEndTime')
        if m.get('rotationName') is not None:
            self.rotation_name = m.get('rotationName')
        if m.get('rotationStartTime') is not None:
            self.rotation_start_time = m.get('rotationStartTime')
        if m.get('shiftLength') is not None:
            self.shift_length = m.get('shiftLength')
        if m.get('shiftRecurrenceFrequency') is not None:
            self.shift_recurrence_frequency = m.get('shiftRecurrenceFrequency')
        if m.get('startDate') is not None:
            self.start_date = m.get('startDate')
        if m.get('timeZone') is not None:
            self.time_zone = m.get('timeZone')
        return self


class CreateOncallScheduleRequest(TeaModel):
    def __init__(
        self,
        oncall_schedule_id: str = None,
        oncall_schedule_name: str = None,
        rotations: List[CreateOncallScheduleRequestRotations] = None,
        shift_robot_id: str = None,
        source: str = None,
    ):
        self.oncall_schedule_id = oncall_schedule_id
        self.oncall_schedule_name = oncall_schedule_name
        self.rotations = rotations
        self.shift_robot_id = shift_robot_id
        self.source = source

    def validate(self):
        if self.rotations:
            for k in self.rotations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.oncall_schedule_id is not None:
            result['oncallScheduleId'] = self.oncall_schedule_id
        if self.oncall_schedule_name is not None:
            result['oncallScheduleName'] = self.oncall_schedule_name
        result['rotations'] = []
        if self.rotations is not None:
            for k in self.rotations:
                result['rotations'].append(k.to_map() if k else None)
        if self.shift_robot_id is not None:
            result['shiftRobotId'] = self.shift_robot_id
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('oncallScheduleId') is not None:
            self.oncall_schedule_id = m.get('oncallScheduleId')
        if m.get('oncallScheduleName') is not None:
            self.oncall_schedule_name = m.get('oncallScheduleName')
        self.rotations = []
        if m.get('rotations') is not None:
            for k in m.get('rotations'):
                temp_model = CreateOncallScheduleRequestRotations()
                self.rotations.append(temp_model.from_map(k))
        if m.get('shiftRobotId') is not None:
            self.shift_robot_id = m.get('shiftRobotId')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class CreateOncallScheduleResponseBody(TeaModel):
    def __init__(
        self,
        oncall_schedule_id: str = None,
        request_id: str = None,
    ):
        self.oncall_schedule_id = oncall_schedule_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.oncall_schedule_id is not None:
            result['oncallScheduleId'] = self.oncall_schedule_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('oncallScheduleId') is not None:
            self.oncall_schedule_id = m.get('oncallScheduleId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreateOncallScheduleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOncallScheduleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOncallScheduleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePolicyRequestFilter(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        filter_conditions: Dict[str, str] = None,
        instance_ids: List[str] = None,
        provider: str = None,
        taint_conditions: Dict[str, str] = None,
    ):
        self.cluster_id = cluster_id
        self.filter_conditions = filter_conditions
        self.instance_ids = instance_ids
        self.provider = provider
        self.taint_conditions = taint_conditions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['clusterId'] = self.cluster_id
        if self.filter_conditions is not None:
            result['filterConditions'] = self.filter_conditions
        if self.instance_ids is not None:
            result['instanceIds'] = self.instance_ids
        if self.provider is not None:
            result['provider'] = self.provider
        if self.taint_conditions is not None:
            result['taintConditions'] = self.taint_conditions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterId') is not None:
            self.cluster_id = m.get('clusterId')
        if m.get('filterConditions') is not None:
            self.filter_conditions = m.get('filterConditions')
        if m.get('instanceIds') is not None:
            self.instance_ids = m.get('instanceIds')
        if m.get('provider') is not None:
            self.provider = m.get('provider')
        if m.get('taintConditions') is not None:
            self.taint_conditions = m.get('taintConditions')
        return self


class CreatePolicyRequest(TeaModel):
    def __init__(
        self,
        filter: CreatePolicyRequestFilter = None,
        policy_name: str = None,
        policy_type: str = None,
        region: str = None,
        workspace: str = None,
    ):
        self.filter = filter
        self.policy_name = policy_name
        # This parameter is required.
        self.policy_type = policy_type
        # This parameter is required.
        self.region = region
        self.workspace = workspace

    def validate(self):
        if self.filter:
            self.filter.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter is not None:
            result['filter'] = self.filter.to_map()
        if self.policy_name is not None:
            result['policyName'] = self.policy_name
        if self.policy_type is not None:
            result['policyType'] = self.policy_type
        if self.region is not None:
            result['region'] = self.region
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('filter') is not None:
            temp_model = CreatePolicyRequestFilter()
            self.filter = temp_model.from_map(m['filter'])
        if m.get('policyName') is not None:
            self.policy_name = m.get('policyName')
        if m.get('policyType') is not None:
            self.policy_type = m.get('policyType')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreatePolicyResponseBodyData(TeaModel):
    def __init__(
        self,
        policy_id: str = None,
        policy_name: str = None,
        policy_type: str = None,
        region: str = None,
        user_id: str = None,
    ):
        self.policy_id = policy_id
        self.policy_name = policy_name
        self.policy_type = policy_type
        self.region = region
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_id is not None:
            result['policyId'] = self.policy_id
        if self.policy_name is not None:
            result['policyName'] = self.policy_name
        if self.policy_type is not None:
            result['policyType'] = self.policy_type
        if self.region is not None:
            result['region'] = self.region
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('policyId') is not None:
            self.policy_id = m.get('policyId')
        if m.get('policyName') is not None:
            self.policy_name = m.get('policyName')
        if m.get('policyType') is not None:
            self.policy_type = m.get('policyType')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class CreatePolicyResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: CreatePolicyResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            temp_model = CreatePolicyResponseBodyData()
            self.data = temp_model.from_map(m['data'])
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreatePolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePrometheusInstanceRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class CreatePrometheusInstanceRequest(TeaModel):
    def __init__(
        self,
        archive_duration: int = None,
        auth_free_read_policy: str = None,
        auth_free_write_policy: str = None,
        enable_auth_free_read: bool = None,
        enable_auth_free_write: bool = None,
        enable_auth_token: bool = None,
        payment_type: str = None,
        prometheus_instance_name: str = None,
        resource_group_id: str = None,
        status: str = None,
        storage_duration: int = None,
        tags: List[CreatePrometheusInstanceRequestTags] = None,
        workspace: str = None,
    ):
        self.archive_duration = archive_duration
        self.auth_free_read_policy = auth_free_read_policy
        self.auth_free_write_policy = auth_free_write_policy
        self.enable_auth_free_read = enable_auth_free_read
        self.enable_auth_free_write = enable_auth_free_write
        self.enable_auth_token = enable_auth_token
        self.payment_type = payment_type
        # This parameter is required.
        self.prometheus_instance_name = prometheus_instance_name
        self.resource_group_id = resource_group_id
        self.status = status
        self.storage_duration = storage_duration
        self.tags = tags
        self.workspace = workspace

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.archive_duration is not None:
            result['archiveDuration'] = self.archive_duration
        if self.auth_free_read_policy is not None:
            result['authFreeReadPolicy'] = self.auth_free_read_policy
        if self.auth_free_write_policy is not None:
            result['authFreeWritePolicy'] = self.auth_free_write_policy
        if self.enable_auth_free_read is not None:
            result['enableAuthFreeRead'] = self.enable_auth_free_read
        if self.enable_auth_free_write is not None:
            result['enableAuthFreeWrite'] = self.enable_auth_free_write
        if self.enable_auth_token is not None:
            result['enableAuthToken'] = self.enable_auth_token
        if self.payment_type is not None:
            result['paymentType'] = self.payment_type
        if self.prometheus_instance_name is not None:
            result['prometheusInstanceName'] = self.prometheus_instance_name
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.status is not None:
            result['status'] = self.status
        if self.storage_duration is not None:
            result['storageDuration'] = self.storage_duration
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('archiveDuration') is not None:
            self.archive_duration = m.get('archiveDuration')
        if m.get('authFreeReadPolicy') is not None:
            self.auth_free_read_policy = m.get('authFreeReadPolicy')
        if m.get('authFreeWritePolicy') is not None:
            self.auth_free_write_policy = m.get('authFreeWritePolicy')
        if m.get('enableAuthFreeRead') is not None:
            self.enable_auth_free_read = m.get('enableAuthFreeRead')
        if m.get('enableAuthFreeWrite') is not None:
            self.enable_auth_free_write = m.get('enableAuthFreeWrite')
        if m.get('enableAuthToken') is not None:
            self.enable_auth_token = m.get('enableAuthToken')
        if m.get('paymentType') is not None:
            self.payment_type = m.get('paymentType')
        if m.get('prometheusInstanceName') is not None:
            self.prometheus_instance_name = m.get('prometheusInstanceName')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('storageDuration') is not None:
            self.storage_duration = m.get('storageDuration')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = CreatePrometheusInstanceRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreatePrometheusInstanceResponseBody(TeaModel):
    def __init__(
        self,
        prometheus_instance_id: str = None,
        request_id: str = None,
    ):
        self.prometheus_instance_id = prometheus_instance_id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_instance_id is not None:
            result['prometheusInstanceId'] = self.prometheus_instance_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('prometheusInstanceId') is not None:
            self.prometheus_instance_id = m.get('prometheusInstanceId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreatePrometheusInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePrometheusInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePrometheusInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePrometheusViewRequestPrometheusInstances(TeaModel):
    def __init__(
        self,
        prometheus_instance_id: str = None,
        region_id: str = None,
        user_id: str = None,
    ):
        self.prometheus_instance_id = prometheus_instance_id
        self.region_id = region_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_instance_id is not None:
            result['prometheusInstanceId'] = self.prometheus_instance_id
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('prometheusInstanceId') is not None:
            self.prometheus_instance_id = m.get('prometheusInstanceId')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class CreatePrometheusViewRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class CreatePrometheusViewRequest(TeaModel):
    def __init__(
        self,
        auth_free_read_policy: str = None,
        enable_auth_free_read: bool = None,
        enable_auth_token: bool = None,
        prometheus_instances: List[CreatePrometheusViewRequestPrometheusInstances] = None,
        prometheus_view_name: str = None,
        resource_group_id: str = None,
        status: str = None,
        tags: List[CreatePrometheusViewRequestTags] = None,
        version: str = None,
        workspace: str = None,
    ):
        self.auth_free_read_policy = auth_free_read_policy
        self.enable_auth_free_read = enable_auth_free_read
        self.enable_auth_token = enable_auth_token
        # This parameter is required.
        self.prometheus_instances = prometheus_instances
        # This parameter is required.
        self.prometheus_view_name = prometheus_view_name
        self.resource_group_id = resource_group_id
        self.status = status
        self.tags = tags
        # This parameter is required.
        self.version = version
        self.workspace = workspace

    def validate(self):
        if self.prometheus_instances:
            for k in self.prometheus_instances:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_free_read_policy is not None:
            result['authFreeReadPolicy'] = self.auth_free_read_policy
        if self.enable_auth_free_read is not None:
            result['enableAuthFreeRead'] = self.enable_auth_free_read
        if self.enable_auth_token is not None:
            result['enableAuthToken'] = self.enable_auth_token
        result['prometheusInstances'] = []
        if self.prometheus_instances is not None:
            for k in self.prometheus_instances:
                result['prometheusInstances'].append(k.to_map() if k else None)
        if self.prometheus_view_name is not None:
            result['prometheusViewName'] = self.prometheus_view_name
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.status is not None:
            result['status'] = self.status
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.version is not None:
            result['version'] = self.version
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authFreeReadPolicy') is not None:
            self.auth_free_read_policy = m.get('authFreeReadPolicy')
        if m.get('enableAuthFreeRead') is not None:
            self.enable_auth_free_read = m.get('enableAuthFreeRead')
        if m.get('enableAuthToken') is not None:
            self.enable_auth_token = m.get('enableAuthToken')
        self.prometheus_instances = []
        if m.get('prometheusInstances') is not None:
            for k in m.get('prometheusInstances'):
                temp_model = CreatePrometheusViewRequestPrometheusInstances()
                self.prometheus_instances.append(temp_model.from_map(k))
        if m.get('prometheusViewName') is not None:
            self.prometheus_view_name = m.get('prometheusViewName')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('status') is not None:
            self.status = m.get('status')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = CreatePrometheusViewRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreatePrometheusViewResponseBody(TeaModel):
    def __init__(
        self,
        prometheus_view_id: str = None,
        request_id: str = None,
    ):
        self.prometheus_view_id = prometheus_view_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_view_id is not None:
            result['prometheusViewId'] = self.prometheus_view_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('prometheusViewId') is not None:
            self.prometheus_view_id = m.get('prometheusViewId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class CreatePrometheusViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePrometheusViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePrometheusViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRumInstanceRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        rum_instance_id: str = None,
        rum_instance_name: str = None,
    ):
        self.region_id = region_id
        self.rum_instance_id = rum_instance_id
        self.rum_instance_name = rum_instance_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.rum_instance_id is not None:
            result['rumInstanceId'] = self.rum_instance_id
        if self.rum_instance_name is not None:
            result['rumInstanceName'] = self.rum_instance_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('rumInstanceId') is not None:
            self.rum_instance_id = m.get('rumInstanceId')
        if m.get('rumInstanceName') is not None:
            self.rum_instance_name = m.get('rumInstanceName')
        return self


class CreateRumInstanceResponseBody(TeaModel):
    def __init__(
        self,
        entity_store: str = None,
        prometheus_instance: PrometheusManagedInstance = None,
        request_id: str = None,
        rum_endpoint: RumDnsResponse = None,
        rum_instance_id: str = None,
        rum_instance_name: str = None,
        storages: List[DataStorageItem] = None,
        topo_store: str = None,
        workspace_name: str = None,
        workspace_project: str = None,
        workspace_region_id: str = None,
    ):
        self.entity_store = entity_store
        self.prometheus_instance = prometheus_instance
        self.request_id = request_id
        self.rum_endpoint = rum_endpoint
        self.rum_instance_id = rum_instance_id
        self.rum_instance_name = rum_instance_name
        self.storages = storages
        self.topo_store = topo_store
        self.workspace_name = workspace_name
        self.workspace_project = workspace_project
        self.workspace_region_id = workspace_region_id

    def validate(self):
        if self.prometheus_instance:
            self.prometheus_instance.validate()
        if self.rum_endpoint:
            self.rum_endpoint.validate()
        if self.storages:
            for k in self.storages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_store is not None:
            result['entityStore'] = self.entity_store
        if self.prometheus_instance is not None:
            result['prometheusInstance'] = self.prometheus_instance.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.rum_endpoint is not None:
            result['rumEndpoint'] = self.rum_endpoint.to_map()
        if self.rum_instance_id is not None:
            result['rumInstanceId'] = self.rum_instance_id
        if self.rum_instance_name is not None:
            result['rumInstanceName'] = self.rum_instance_name
        result['storages'] = []
        if self.storages is not None:
            for k in self.storages:
                result['storages'].append(k.to_map() if k else None)
        if self.topo_store is not None:
            result['topoStore'] = self.topo_store
        if self.workspace_name is not None:
            result['workspaceName'] = self.workspace_name
        if self.workspace_project is not None:
            result['workspaceProject'] = self.workspace_project
        if self.workspace_region_id is not None:
            result['workspaceRegionId'] = self.workspace_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('entityStore') is not None:
            self.entity_store = m.get('entityStore')
        if m.get('prometheusInstance') is not None:
            temp_model = PrometheusManagedInstance()
            self.prometheus_instance = temp_model.from_map(m['prometheusInstance'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('rumEndpoint') is not None:
            temp_model = RumDnsResponse()
            self.rum_endpoint = temp_model.from_map(m['rumEndpoint'])
        if m.get('rumInstanceId') is not None:
            self.rum_instance_id = m.get('rumInstanceId')
        if m.get('rumInstanceName') is not None:
            self.rum_instance_name = m.get('rumInstanceName')
        self.storages = []
        if m.get('storages') is not None:
            for k in m.get('storages'):
                temp_model = DataStorageItem()
                self.storages.append(temp_model.from_map(k))
        if m.get('topoStore') is not None:
            self.topo_store = m.get('topoStore')
        if m.get('workspaceName') is not None:
            self.workspace_name = m.get('workspaceName')
        if m.get('workspaceProject') is not None:
            self.workspace_project = m.get('workspaceProject')
        if m.get('workspaceRegionId') is not None:
            self.workspace_region_id = m.get('workspaceRegionId')
        return self


class CreateRumInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRumInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRumInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSubscriptionRequest(TeaModel):
    def __init__(
        self,
        body: SubscriptionForModify = None,
        client_token: str = None,
        workspace: str = None,
    ):
        self.body = body
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body.to_map()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            temp_model = SubscriptionForModify()
            self.body = temp_model.from_map(m['body'])
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateSubscriptionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        subscription_id: str = None,
    ):
        self.request_id = request_id
        self.subscription_id = subscription_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.subscription_id is not None:
            result['subscriptionId'] = self.subscription_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('subscriptionId') is not None:
            self.subscription_id = m.get('subscriptionId')
        return self


class CreateSubscriptionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSubscriptionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSubscriptionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTransformerRequest(TeaModel):
    def __init__(
        self,
        body: TransformerForModify = None,
        client_token: str = None,
        workspace: str = None,
    ):
        self.body = body
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body.to_map()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            temp_model = TransformerForModify()
            self.body = temp_model.from_map(m['body'])
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateTransformerResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        transformer_id: str = None,
    ):
        self.request_id = request_id
        self.transformer_id = transformer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.transformer_id is not None:
            result['transformerId'] = self.transformer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('transformerId') is not None:
            self.transformer_id = m.get('transformerId')
        return self


class CreateTransformerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateTransformerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTransformerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUmodelRequestCommonSchemaRef(TeaModel):
    def __init__(
        self,
        group: str = None,
        items: List[str] = None,
        version: str = None,
    ):
        self.group = group
        self.items = items
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group is not None:
            result['group'] = self.group
        if self.items is not None:
            result['items'] = self.items
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('group') is not None:
            self.group = m.get('group')
        if m.get('items') is not None:
            self.items = m.get('items')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class CreateUmodelRequest(TeaModel):
    def __init__(
        self,
        common_schema_ref: List[CreateUmodelRequestCommonSchemaRef] = None,
        description: str = None,
    ):
        self.common_schema_ref = common_schema_ref
        self.description = description

    def validate(self):
        if self.common_schema_ref:
            for k in self.common_schema_ref:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['commonSchemaRef'] = []
        if self.common_schema_ref is not None:
            for k in self.common_schema_ref:
                result['commonSchemaRef'].append(k.to_map() if k else None)
        if self.description is not None:
            result['description'] = self.description
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.common_schema_ref = []
        if m.get('commonSchemaRef') is not None:
            for k in m.get('commonSchemaRef'):
                temp_model = CreateUmodelRequestCommonSchemaRef()
                self.common_schema_ref.append(temp_model.from_map(k))
        if m.get('description') is not None:
            self.description = m.get('description')
        return self


class CreateUmodelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        workspace: str = None,
    ):
        self.request_id = request_id
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateUmodelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateUmodelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUmodelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAddonReleaseRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        force: bool = None,
        release_name: str = None,
    ):
        self.addon_name = addon_name
        self.force = force
        self.release_name = release_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.force is not None:
            result['force'] = self.force
        if self.release_name is not None:
            result['releaseName'] = self.release_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('force') is not None:
            self.force = m.get('force')
        if m.get('releaseName') is not None:
            self.release_name = m.get('releaseName')
        return self


class DeleteAddonReleaseResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteAddonReleaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAddonReleaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAddonReleaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAggTaskGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteAggTaskGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAggTaskGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAggTaskGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAlertActionRequest(TeaModel):
    def __init__(
        self,
        alert_action_id: str = None,
    ):
        # This parameter is required.
        self.alert_action_id = alert_action_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_action_id is not None:
            result['alertActionId'] = self.alert_action_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertActionId') is not None:
            self.alert_action_id = m.get('alertActionId')
        return self


class DeleteAlertActionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteAlertActionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAlertActionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAlertActionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAlertActionsRequest(TeaModel):
    def __init__(
        self,
        alert_action_ids: List[str] = None,
        source: str = None,
    ):
        # This parameter is required.
        self.alert_action_ids = alert_action_ids
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_action_ids is not None:
            result['alertActionIds'] = self.alert_action_ids
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertActionIds') is not None:
            self.alert_action_ids = m.get('alertActionIds')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class DeleteAlertActionsShrinkRequest(TeaModel):
    def __init__(
        self,
        alert_action_ids_shrink: str = None,
        source: str = None,
    ):
        # This parameter is required.
        self.alert_action_ids_shrink = alert_action_ids_shrink
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_action_ids_shrink is not None:
            result['alertActionIds'] = self.alert_action_ids_shrink
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertActionIds') is not None:
            self.alert_action_ids_shrink = m.get('alertActionIds')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class DeleteAlertActionsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteAlertActionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAlertActionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAlertActionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAlertEventIntegrationPolicyRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DeleteAlertEventIntegrationPolicyResponseBody(TeaModel):
    def __init__(
        self,
        alert_event_integration_policy_id: str = None,
        request_id: str = None,
    ):
        self.alert_event_integration_policy_id = alert_event_integration_policy_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_event_integration_policy_id is not None:
            result['alertEventIntegrationPolicyId'] = self.alert_event_integration_policy_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertEventIntegrationPolicyId') is not None:
            self.alert_event_integration_policy_id = m.get('alertEventIntegrationPolicyId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteAlertEventIntegrationPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAlertEventIntegrationPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAlertEventIntegrationPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAlertNotifyTemplatesRequest(TeaModel):
    def __init__(
        self,
        alert_notify_template_ids: List[str] = None,
    ):
        # This parameter is required.
        self.alert_notify_template_ids = alert_notify_template_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_notify_template_ids is not None:
            result['alertNotifyTemplateIds'] = self.alert_notify_template_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertNotifyTemplateIds') is not None:
            self.alert_notify_template_ids = m.get('alertNotifyTemplateIds')
        return self


class DeleteAlertNotifyTemplatesShrinkRequest(TeaModel):
    def __init__(
        self,
        alert_notify_template_ids_shrink: str = None,
    ):
        # This parameter is required.
        self.alert_notify_template_ids_shrink = alert_notify_template_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_notify_template_ids_shrink is not None:
            result['alertNotifyTemplateIds'] = self.alert_notify_template_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertNotifyTemplateIds') is not None:
            self.alert_notify_template_ids_shrink = m.get('alertNotifyTemplateIds')
        return self


class DeleteAlertNotifyTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteAlertNotifyTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAlertNotifyTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAlertNotifyTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAlertRobotsRequest(TeaModel):
    def __init__(
        self,
        is_custom: str = None,
        robot_ids: List[str] = None,
        source: str = None,
        type: str = None,
    ):
        self.is_custom = is_custom
        # This parameter is required.
        self.robot_ids = robot_ids
        self.source = source
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_custom is not None:
            result['isCustom'] = self.is_custom
        if self.robot_ids is not None:
            result['robotIds'] = self.robot_ids
        if self.source is not None:
            result['source'] = self.source
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isCustom') is not None:
            self.is_custom = m.get('isCustom')
        if m.get('robotIds') is not None:
            self.robot_ids = m.get('robotIds')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DeleteAlertRobotsShrinkRequest(TeaModel):
    def __init__(
        self,
        is_custom: str = None,
        robot_ids_shrink: str = None,
        source: str = None,
        type: str = None,
    ):
        self.is_custom = is_custom
        # This parameter is required.
        self.robot_ids_shrink = robot_ids_shrink
        self.source = source
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_custom is not None:
            result['isCustom'] = self.is_custom
        if self.robot_ids_shrink is not None:
            result['robotIds'] = self.robot_ids_shrink
        if self.source is not None:
            result['source'] = self.source
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isCustom') is not None:
            self.is_custom = m.get('isCustom')
        if m.get('robotIds') is not None:
            self.robot_ids_shrink = m.get('robotIds')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DeleteAlertRobotsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteAlertRobotsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAlertRobotsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAlertRobotsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAlertRulesRequest(TeaModel):
    def __init__(
        self,
        alert_rule_ids: List[str] = None,
    ):
        # This parameter is required.
        self.alert_rule_ids = alert_rule_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_ids is not None:
            result['alertRuleIds'] = self.alert_rule_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleIds') is not None:
            self.alert_rule_ids = m.get('alertRuleIds')
        return self


class DeleteAlertRulesShrinkRequest(TeaModel):
    def __init__(
        self,
        alert_rule_ids_shrink: str = None,
    ):
        # This parameter is required.
        self.alert_rule_ids_shrink = alert_rule_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_ids_shrink is not None:
            result['alertRuleIds'] = self.alert_rule_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleIds') is not None:
            self.alert_rule_ids_shrink = m.get('alertRuleIds')
        return self


class DeleteAlertRulesResponseBody(TeaModel):
    def __init__(
        self,
        data: int = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteAlertRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAlertRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAlertRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAlertWebhookRequest(TeaModel):
    def __init__(
        self,
        source: str = None,
        type: str = None,
        webhook_ids: List[str] = None,
    ):
        self.source = source
        # This parameter is required.
        self.type = type
        # This parameter is required.
        self.webhook_ids = webhook_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source is not None:
            result['source'] = self.source
        if self.type is not None:
            result['type'] = self.type
        if self.webhook_ids is not None:
            result['webhookIds'] = self.webhook_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('webhookIds') is not None:
            self.webhook_ids = m.get('webhookIds')
        return self


class DeleteAlertWebhookShrinkRequest(TeaModel):
    def __init__(
        self,
        source: str = None,
        type: str = None,
        webhook_ids_shrink: str = None,
    ):
        self.source = source
        # This parameter is required.
        self.type = type
        # This parameter is required.
        self.webhook_ids_shrink = webhook_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source is not None:
            result['source'] = self.source
        if self.type is not None:
            result['type'] = self.type
        if self.webhook_ids_shrink is not None:
            result['webhookIds'] = self.webhook_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('webhookIds') is not None:
            self.webhook_ids_shrink = m.get('webhookIds')
        return self


class DeleteAlertWebhookResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteAlertWebhookResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAlertWebhookResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAlertWebhookResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAlertWebhooksRequest(TeaModel):
    def __init__(
        self,
        is_custom: str = None,
        source: str = None,
        webhook_ids: List[str] = None,
    ):
        self.is_custom = is_custom
        self.source = source
        # This parameter is required.
        self.webhook_ids = webhook_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_custom is not None:
            result['isCustom'] = self.is_custom
        if self.source is not None:
            result['source'] = self.source
        if self.webhook_ids is not None:
            result['webhookIds'] = self.webhook_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isCustom') is not None:
            self.is_custom = m.get('isCustom')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('webhookIds') is not None:
            self.webhook_ids = m.get('webhookIds')
        return self


class DeleteAlertWebhooksShrinkRequest(TeaModel):
    def __init__(
        self,
        is_custom: str = None,
        source: str = None,
        webhook_ids_shrink: str = None,
    ):
        self.is_custom = is_custom
        self.source = source
        # This parameter is required.
        self.webhook_ids_shrink = webhook_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_custom is not None:
            result['isCustom'] = self.is_custom
        if self.source is not None:
            result['source'] = self.source
        if self.webhook_ids_shrink is not None:
            result['webhookIds'] = self.webhook_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isCustom') is not None:
            self.is_custom = m.get('isCustom')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('webhookIds') is not None:
            self.webhook_ids_shrink = m.get('webhookIds')
        return self


class DeleteAlertWebhooksResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteAlertWebhooksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAlertWebhooksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAlertWebhooksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteBizTraceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteBizTraceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteBizTraceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteBizTraceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCloudResourceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteCloudResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCloudResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCloudResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteContactRequest(TeaModel):
    def __init__(
        self,
        contact_ids: List[str] = None,
        source: str = None,
    ):
        self.contact_ids = contact_ids
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_ids is not None:
            result['contactIds'] = self.contact_ids
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactIds') is not None:
            self.contact_ids = m.get('contactIds')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class DeleteContactShrinkRequest(TeaModel):
    def __init__(
        self,
        contact_ids_shrink: str = None,
        source: str = None,
    ):
        self.contact_ids_shrink = contact_ids_shrink
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_ids_shrink is not None:
            result['contactIds'] = self.contact_ids_shrink
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactIds') is not None:
            self.contact_ids_shrink = m.get('contactIds')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class DeleteContactResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        request_id: str = None,
        success: str = None,
    ):
        self.code = code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteContactResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteContactResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteContactResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteContactGroupRequest(TeaModel):
    def __init__(
        self,
        contact_group_ids: List[str] = None,
        source: str = None,
    ):
        # This parameter is required.
        self.contact_group_ids = contact_group_ids
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_ids is not None:
            result['contactGroupIds'] = self.contact_group_ids
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactGroupIds') is not None:
            self.contact_group_ids = m.get('contactGroupIds')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class DeleteContactGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        contact_group_ids_shrink: str = None,
        source: str = None,
    ):
        # This parameter is required.
        self.contact_group_ids_shrink = contact_group_ids_shrink
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_ids_shrink is not None:
            result['contactGroupIds'] = self.contact_group_ids_shrink
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactGroupIds') is not None:
            self.contact_group_ids_shrink = m.get('contactGroupIds')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class DeleteContactGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        request_id: str = None,
        success: str = None,
    ):
        self.code = code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteContactGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteContactGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteContactGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteContactGroupsRequest(TeaModel):
    def __init__(
        self,
        contact_group_ids: List[str] = None,
        source: str = None,
    ):
        # This parameter is required.
        self.contact_group_ids = contact_group_ids
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_ids is not None:
            result['contactGroupIds'] = self.contact_group_ids
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactGroupIds') is not None:
            self.contact_group_ids = m.get('contactGroupIds')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class DeleteContactGroupsShrinkRequest(TeaModel):
    def __init__(
        self,
        contact_group_ids_shrink: str = None,
        source: str = None,
    ):
        # This parameter is required.
        self.contact_group_ids_shrink = contact_group_ids_shrink
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_ids_shrink is not None:
            result['contactGroupIds'] = self.contact_group_ids_shrink
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactGroupIds') is not None:
            self.contact_group_ids_shrink = m.get('contactGroupIds')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class DeleteContactGroupsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteContactGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteContactGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteContactGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteContactsRequest(TeaModel):
    def __init__(
        self,
        contact_ids: List[str] = None,
        source: str = None,
    ):
        self.contact_ids = contact_ids
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_ids is not None:
            result['contactIds'] = self.contact_ids
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactIds') is not None:
            self.contact_ids = m.get('contactIds')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class DeleteContactsShrinkRequest(TeaModel):
    def __init__(
        self,
        contact_ids_shrink: str = None,
        source: str = None,
    ):
        self.contact_ids_shrink = contact_ids_shrink
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_ids_shrink is not None:
            result['contactIds'] = self.contact_ids_shrink
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactIds') is not None:
            self.contact_ids_shrink = m.get('contactIds')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class DeleteContactsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteContactsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteContactsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteContactsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEntityGroupRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DeleteEntityGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteEntityGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEntityGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEntityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEntityStoreResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteEntityStoreResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEntityStoreResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEntityStoreResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEnvironmentRequest(TeaModel):
    def __init__(
        self,
        delete_prom_instance: bool = None,
        region_id: str = None,
    ):
        self.delete_prom_instance = delete_prom_instance
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_prom_instance is not None:
            result['DeletePromInstance'] = self.delete_prom_instance
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeletePromInstance') is not None:
            self.delete_prom_instance = m.get('DeletePromInstance')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteEnvironmentResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEnvironmentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEnvironmentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEnvironmentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEnvironmentFeatureRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
    ):
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteEnvironmentFeatureResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteEnvironmentFeatureResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEnvironmentFeatureResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEnvironmentFeatureResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEscalationRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DeleteEscalationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        uuid: str = None,
    ):
        self.request_id = request_id
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class DeleteEscalationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEscalationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEscalationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteIncidentEscalationRequest(TeaModel):
    def __init__(
        self,
        incident_escalation_id: str = None,
    ):
        self.incident_escalation_id = incident_escalation_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.incident_escalation_id is not None:
            result['incidentEscalationId'] = self.incident_escalation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('incidentEscalationId') is not None:
            self.incident_escalation_id = m.get('incidentEscalationId')
        return self


class DeleteIncidentEscalationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteIncidentEscalationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteIncidentEscalationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteIncidentEscalationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteIncidentPlanRequest(TeaModel):
    def __init__(
        self,
        incident_plan_id: str = None,
    ):
        self.incident_plan_id = incident_plan_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.incident_plan_id is not None:
            result['incidentPlanId'] = self.incident_plan_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('incidentPlanId') is not None:
            self.incident_plan_id = m.get('incidentPlanId')
        return self


class DeleteIncidentPlanResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteIncidentPlanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteIncidentPlanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteIncidentPlanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteIntegrationRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DeleteIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        integration_id: str = None,
        request_id: str = None,
    ):
        self.integration_id = integration_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integration_id is not None:
            result['integrationId'] = self.integration_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('integrationId') is not None:
            self.integration_id = m.get('integrationId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteIntegrationPolicyRequest(TeaModel):
    def __init__(
        self,
        force: bool = None,
    ):
        self.force = force

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.force is not None:
            result['force'] = self.force
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('force') is not None:
            self.force = m.get('force')
        return self


class DeleteIntegrationPolicyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteIntegrationPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteIntegrationPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteIntegrationPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMaintainWindowRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DeleteMaintainWindowResponseBody(TeaModel):
    def __init__(
        self,
        maintain_window_id: str = None,
        request_id: str = None,
    ):
        self.maintain_window_id = maintain_window_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.maintain_window_id is not None:
            result['maintainWindowId'] = self.maintain_window_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maintainWindowId') is not None:
            self.maintain_window_id = m.get('maintainWindowId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteMaintainWindowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMaintainWindowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMaintainWindowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNotifyStrategyRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DeleteNotifyStrategyResponseBody(TeaModel):
    def __init__(
        self,
        notify_strategy_id: str = None,
        request_id: str = None,
    ):
        self.notify_strategy_id = notify_strategy_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify_strategy_id is not None:
            result['notifyStrategyId'] = self.notify_strategy_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('notifyStrategyId') is not None:
            self.notify_strategy_id = m.get('notifyStrategyId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteNotifyStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteNotifyStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNotifyStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteOncallSchedulesRequest(TeaModel):
    def __init__(
        self,
        oncall_schedule_ids: List[str] = None,
        source: str = None,
    ):
        self.oncall_schedule_ids = oncall_schedule_ids
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.oncall_schedule_ids is not None:
            result['oncallScheduleIds'] = self.oncall_schedule_ids
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('oncallScheduleIds') is not None:
            self.oncall_schedule_ids = m.get('oncallScheduleIds')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class DeleteOncallSchedulesShrinkRequest(TeaModel):
    def __init__(
        self,
        oncall_schedule_ids_shrink: str = None,
        source: str = None,
    ):
        self.oncall_schedule_ids_shrink = oncall_schedule_ids_shrink
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.oncall_schedule_ids_shrink is not None:
            result['oncallScheduleIds'] = self.oncall_schedule_ids_shrink
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('oncallScheduleIds') is not None:
            self.oncall_schedule_ids_shrink = m.get('oncallScheduleIds')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class DeleteOncallSchedulesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteOncallSchedulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteOncallSchedulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteOncallSchedulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePolicyRequest(TeaModel):
    def __init__(
        self,
        force: bool = None,
    ):
        self.force = force

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.force is not None:
            result['force'] = self.force
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('force') is not None:
            self.force = m.get('force')
        return self


class DeletePolicyResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeletePolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePrometheusInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeletePrometheusInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePrometheusInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePrometheusInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePrometheusViewResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeletePrometheusViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePrometheusViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePrometheusViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRumInstanceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteRumInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRumInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRumInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSiteMonitorRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        site_monitor_id: str = None,
    ):
        self.client_token = client_token
        # This parameter is required.
        self.site_monitor_id = site_monitor_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.site_monitor_id is not None:
            result['siteMonitorId'] = self.site_monitor_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('siteMonitorId') is not None:
            self.site_monitor_id = m.get('siteMonitorId')
        return self


class DeleteSiteMonitorResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteSiteMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSiteMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSiteMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSubscriptionRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DeleteSubscriptionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        subscription_id: str = None,
    ):
        self.request_id = request_id
        self.subscription_id = subscription_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.subscription_id is not None:
            result['subscriptionId'] = self.subscription_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('subscriptionId') is not None:
            self.subscription_id = m.get('subscriptionId')
        return self


class DeleteSubscriptionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSubscriptionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSubscriptionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTransformerRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DeleteTransformerResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        transformer_id: str = None,
    ):
        self.request_id = request_id
        self.transformer_id = transformer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.transformer_id is not None:
            result['transformerId'] = self.transformer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('transformerId') is not None:
            self.transformer_id = m.get('transformerId')
        return self


class DeleteTransformerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTransformerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTransformerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteUmodelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteUmodelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteUmodelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteUmodelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteUmodelDataHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        x_logapiversion: str = None,
    ):
        self.common_headers = common_headers
        self.x_logapiversion = x_logapiversion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.x_logapiversion is not None:
            result['X-LOG-APIVERSION'] = self.x_logapiversion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('X-LOG-APIVERSION') is not None:
            self.x_logapiversion = m.get('X-LOG-APIVERSION')
        return self


class DeleteUmodelDataRequest(TeaModel):
    def __init__(
        self,
        domain: str = None,
        kind: str = None,
        name: str = None,
    ):
        self.domain = domain
        self.kind = kind
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['domain'] = self.domain
        if self.kind is not None:
            result['kind'] = self.kind
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain') is not None:
            self.domain = m.get('domain')
        if m.get('kind') is not None:
            self.kind = m.get('kind')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DeleteUmodelDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteUmodelDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteUmodelDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteUmodelDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteUmodelDataTestHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        x_logapiversion: str = None,
    ):
        self.common_headers = common_headers
        self.x_logapiversion = x_logapiversion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.x_logapiversion is not None:
            result['X-LOG-APIVERSION'] = self.x_logapiversion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('X-LOG-APIVERSION') is not None:
            self.x_logapiversion = m.get('X-LOG-APIVERSION')
        return self


class DeleteUmodelDataTestRequest(TeaModel):
    def __init__(
        self,
        domain: str = None,
        kind: str = None,
        name: str = None,
    ):
        self.domain = domain
        self.kind = kind
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['domain'] = self.domain
        if self.kind is not None:
            result['kind'] = self.kind
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain') is not None:
            self.domain = m.get('domain')
        if m.get('kind') is not None:
            self.kind = m.get('kind')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DeleteUmodelDataTestResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteUmodelDataTestResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteUmodelDataTestResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteUmodelDataTestResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteWorkspaceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DeleteWorkspaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteWorkspaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteWorkspaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAddonRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        version: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeAddonResponseBodyDataDashboards(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        url: str = None,
    ):
        self.description = description
        self.name = name
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class DescribeAddonResponseBodyDataEnvironmentsDependencies(TeaModel):
    def __init__(
        self,
        cluster_types: List[str] = None,
        features: Dict[str, bool] = None,
        services: List[str] = None,
    ):
        self.cluster_types = cluster_types
        self.features = features
        self.services = services

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_types is not None:
            result['clusterTypes'] = self.cluster_types
        if self.features is not None:
            result['features'] = self.features
        if self.services is not None:
            result['services'] = self.services
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterTypes') is not None:
            self.cluster_types = m.get('clusterTypes')
        if m.get('features') is not None:
            self.features = m.get('features')
        if m.get('services') is not None:
            self.services = m.get('services')
        return self


class DescribeAddonResponseBodyDataEnvironmentsPoliciesMetricCheckRule(TeaModel):
    def __init__(
        self,
        prom_ql: List[str] = None,
    ):
        self.prom_ql = prom_ql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prom_ql is not None:
            result['promQL'] = self.prom_ql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('promQL') is not None:
            self.prom_ql = m.get('promQL')
        return self


class DescribeAddonResponseBodyDataEnvironmentsPoliciesProtocols(TeaModel):
    def __init__(
        self,
        description: str = None,
        icon: str = None,
        label: str = None,
        name: str = None,
    ):
        self.description = description
        self.icon = icon
        self.label = label
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.icon is not None:
            result['icon'] = self.icon
        if self.label is not None:
            result['label'] = self.label
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DescribeAddonResponseBodyDataEnvironmentsPolicies(TeaModel):
    def __init__(
        self,
        alert_default_status: str = None,
        default_install: bool = None,
        enable_service_account: bool = None,
        metric_check_rule: DescribeAddonResponseBodyDataEnvironmentsPoliciesMetricCheckRule = None,
        need_restart_after_integration: bool = None,
        protocols: List[DescribeAddonResponseBodyDataEnvironmentsPoliciesProtocols] = None,
        target_addon_name: str = None,
    ):
        self.alert_default_status = alert_default_status
        self.default_install = default_install
        self.enable_service_account = enable_service_account
        self.metric_check_rule = metric_check_rule
        self.need_restart_after_integration = need_restart_after_integration
        self.protocols = protocols
        self.target_addon_name = target_addon_name

    def validate(self):
        if self.metric_check_rule:
            self.metric_check_rule.validate()
        if self.protocols:
            for k in self.protocols:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_default_status is not None:
            result['alertDefaultStatus'] = self.alert_default_status
        if self.default_install is not None:
            result['defaultInstall'] = self.default_install
        if self.enable_service_account is not None:
            result['enableServiceAccount'] = self.enable_service_account
        if self.metric_check_rule is not None:
            result['metricCheckRule'] = self.metric_check_rule.to_map()
        if self.need_restart_after_integration is not None:
            result['needRestartAfterIntegration'] = self.need_restart_after_integration
        result['protocols'] = []
        if self.protocols is not None:
            for k in self.protocols:
                result['protocols'].append(k.to_map() if k else None)
        if self.target_addon_name is not None:
            result['targetAddonName'] = self.target_addon_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertDefaultStatus') is not None:
            self.alert_default_status = m.get('alertDefaultStatus')
        if m.get('defaultInstall') is not None:
            self.default_install = m.get('defaultInstall')
        if m.get('enableServiceAccount') is not None:
            self.enable_service_account = m.get('enableServiceAccount')
        if m.get('metricCheckRule') is not None:
            temp_model = DescribeAddonResponseBodyDataEnvironmentsPoliciesMetricCheckRule()
            self.metric_check_rule = temp_model.from_map(m['metricCheckRule'])
        if m.get('needRestartAfterIntegration') is not None:
            self.need_restart_after_integration = m.get('needRestartAfterIntegration')
        self.protocols = []
        if m.get('protocols') is not None:
            for k in m.get('protocols'):
                temp_model = DescribeAddonResponseBodyDataEnvironmentsPoliciesProtocols()
                self.protocols.append(temp_model.from_map(k))
        if m.get('targetAddonName') is not None:
            self.target_addon_name = m.get('targetAddonName')
        return self


class DescribeAddonResponseBodyDataEnvironments(TeaModel):
    def __init__(
        self,
        enable: bool = None,
        label: str = None,
        dependencies: DescribeAddonResponseBodyDataEnvironmentsDependencies = None,
        description: str = None,
        name: str = None,
        policies: DescribeAddonResponseBodyDataEnvironmentsPolicies = None,
    ):
        self.enable = enable
        self.label = label
        self.dependencies = dependencies
        self.description = description
        self.name = name
        self.policies = policies

    def validate(self):
        if self.dependencies:
            self.dependencies.validate()
        if self.policies:
            self.policies.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.label is not None:
            result['Label'] = self.label
        if self.dependencies is not None:
            result['dependencies'] = self.dependencies.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.policies is not None:
            result['policies'] = self.policies.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('dependencies') is not None:
            temp_model = DescribeAddonResponseBodyDataEnvironmentsDependencies()
            self.dependencies = temp_model.from_map(m['dependencies'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('policies') is not None:
            temp_model = DescribeAddonResponseBodyDataEnvironmentsPolicies()
            self.policies = temp_model.from_map(m['policies'])
        return self


class DescribeAddonResponseBodyData(TeaModel):
    def __init__(
        self,
        alias: str = None,
        categories: List[str] = None,
        dashboards: List[DescribeAddonResponseBodyDataDashboards] = None,
        description: str = None,
        environments: List[DescribeAddonResponseBodyDataEnvironments] = None,
        icon: str = None,
        keywords: List[str] = None,
        language: str = None,
        latest_release_create_time: str = None,
        name: str = None,
        once: bool = None,
        scene: str = None,
        version: str = None,
        weight: str = None,
    ):
        self.alias = alias
        self.categories = categories
        self.dashboards = dashboards
        self.description = description
        self.environments = environments
        self.icon = icon
        self.keywords = keywords
        self.language = language
        self.latest_release_create_time = latest_release_create_time
        self.name = name
        self.once = once
        self.scene = scene
        self.version = version
        self.weight = weight

    def validate(self):
        if self.dashboards:
            for k in self.dashboards:
                if k:
                    k.validate()
        if self.environments:
            for k in self.environments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['alias'] = self.alias
        if self.categories is not None:
            result['categories'] = self.categories
        result['dashboards'] = []
        if self.dashboards is not None:
            for k in self.dashboards:
                result['dashboards'].append(k.to_map() if k else None)
        if self.description is not None:
            result['description'] = self.description
        result['environments'] = []
        if self.environments is not None:
            for k in self.environments:
                result['environments'].append(k.to_map() if k else None)
        if self.icon is not None:
            result['icon'] = self.icon
        if self.keywords is not None:
            result['keywords'] = self.keywords
        if self.language is not None:
            result['language'] = self.language
        if self.latest_release_create_time is not None:
            result['latestReleaseCreateTime'] = self.latest_release_create_time
        if self.name is not None:
            result['name'] = self.name
        if self.once is not None:
            result['once'] = self.once
        if self.scene is not None:
            result['scene'] = self.scene
        if self.version is not None:
            result['version'] = self.version
        if self.weight is not None:
            result['weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alias') is not None:
            self.alias = m.get('alias')
        if m.get('categories') is not None:
            self.categories = m.get('categories')
        self.dashboards = []
        if m.get('dashboards') is not None:
            for k in m.get('dashboards'):
                temp_model = DescribeAddonResponseBodyDataDashboards()
                self.dashboards.append(temp_model.from_map(k))
        if m.get('description') is not None:
            self.description = m.get('description')
        self.environments = []
        if m.get('environments') is not None:
            for k in m.get('environments'):
                temp_model = DescribeAddonResponseBodyDataEnvironments()
                self.environments.append(temp_model.from_map(k))
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('keywords') is not None:
            self.keywords = m.get('keywords')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('latestReleaseCreateTime') is not None:
            self.latest_release_create_time = m.get('latestReleaseCreateTime')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('once') is not None:
            self.once = m.get('once')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        return self


class DescribeAddonResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: DescribeAddonResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            temp_model = DescribeAddonResponseBodyData()
            self.data = temp_model.from_map(m['data'])
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeAddonResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAddonResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAddonResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAddonAlertRulesRequest(TeaModel):
    def __init__(
        self,
        addon_version: str = None,
        aliyun_lang: str = None,
        environment_type: str = None,
    ):
        self.addon_version = addon_version
        self.aliyun_lang = aliyun_lang
        self.environment_type = environment_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_version is not None:
            result['addonVersion'] = self.addon_version
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.environment_type is not None:
            result['environmentType'] = self.environment_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonVersion') is not None:
            self.addon_version = m.get('addonVersion')
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('environmentType') is not None:
            self.environment_type = m.get('environmentType')
        return self


class DescribeAddonAlertRulesResponseBodyRules(TeaModel):
    def __init__(
        self,
        annotations: Dict[str, str] = None,
        duration: str = None,
        group: str = None,
        labels: Dict[str, str] = None,
        level: str = None,
        message: str = None,
        name: str = None,
        prom_ql: str = None,
    ):
        self.annotations = annotations
        self.duration = duration
        self.group = group
        self.labels = labels
        self.level = level
        self.message = message
        self.name = name
        self.prom_ql = prom_ql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotations is not None:
            result['annotations'] = self.annotations
        if self.duration is not None:
            result['duration'] = self.duration
        if self.group is not None:
            result['group'] = self.group
        if self.labels is not None:
            result['labels'] = self.labels
        if self.level is not None:
            result['level'] = self.level
        if self.message is not None:
            result['message'] = self.message
        if self.name is not None:
            result['name'] = self.name
        if self.prom_ql is not None:
            result['promQL'] = self.prom_ql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('annotations') is not None:
            self.annotations = m.get('annotations')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('group') is not None:
            self.group = m.get('group')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('promQL') is not None:
            self.prom_ql = m.get('promQL')
        return self


class DescribeAddonAlertRulesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        rules: List[DescribeAddonAlertRulesResponseBodyRules] = None,
        success: bool = None,
    ):
        self.code = code
        self.message = message
        self.request_id = request_id
        self.rules = rules
        self.success = success

    def validate(self):
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['rules'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.rules = []
        if m.get('rules') is not None:
            for k in m.get('rules'):
                temp_model = DescribeAddonAlertRulesResponseBodyRules()
                self.rules.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeAddonAlertRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAddonAlertRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAddonAlertRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAddonCodesRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        environment_type: str = None,
        version: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.environment_type = environment_type
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.environment_type is not None:
            result['environmentType'] = self.environment_type
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('environmentType') is not None:
            self.environment_type = m.get('environmentType')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeAddonCodesResponseBodyCodes(TeaModel):
    def __init__(
        self,
        code_template: str = None,
        name: str = None,
    ):
        self.code_template = code_template
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code_template is not None:
            result['codeTemplate'] = self.code_template
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('codeTemplate') is not None:
            self.code_template = m.get('codeTemplate')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DescribeAddonCodesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        codes: List[DescribeAddonCodesResponseBodyCodes] = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.codes = codes
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.codes:
            for k in self.codes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        result['codes'] = []
        if self.codes is not None:
            for k in self.codes:
                result['codes'].append(k.to_map() if k else None)
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        self.codes = []
        if m.get('codes') is not None:
            for k in m.get('codes'):
                temp_model = DescribeAddonCodesResponseBodyCodes()
                self.codes.append(temp_model.from_map(k))
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DescribeAddonCodesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAddonCodesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAddonCodesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAddonMetricsRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        environment_type: str = None,
        version: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.environment_type = environment_type
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.environment_type is not None:
            result['environmentType'] = self.environment_type
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('environmentType') is not None:
            self.environment_type = m.get('environmentType')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeAddonMetricsResponseBodyGroupsLabels(TeaModel):
    def __init__(
        self,
        description: str = None,
        key: str = None,
        source: str = None,
    ):
        self.description = description
        self.key = key
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.key is not None:
            result['key'] = self.key
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class DescribeAddonMetricsResponseBodyGroupsMetricsLabels(TeaModel):
    def __init__(
        self,
        description: str = None,
        key: str = None,
        source: str = None,
    ):
        self.description = description
        self.key = key
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.key is not None:
            result['key'] = self.key
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class DescribeAddonMetricsResponseBodyGroupsMetrics(TeaModel):
    def __init__(
        self,
        description: str = None,
        labels: List[DescribeAddonMetricsResponseBodyGroupsMetricsLabels] = None,
        metric: str = None,
        type: str = None,
        unit: str = None,
    ):
        self.description = description
        self.labels = labels
        self.metric = metric
        self.type = type
        self.unit = unit

    def validate(self):
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.metric is not None:
            result['metric'] = self.metric
        if self.type is not None:
            result['type'] = self.type
        if self.unit is not None:
            result['unit'] = self.unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = DescribeAddonMetricsResponseBodyGroupsMetricsLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('metric') is not None:
            self.metric = m.get('metric')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('unit') is not None:
            self.unit = m.get('unit')
        return self


class DescribeAddonMetricsResponseBodyGroups(TeaModel):
    def __init__(
        self,
        group: str = None,
        labels: List[DescribeAddonMetricsResponseBodyGroupsLabels] = None,
        metrics: List[DescribeAddonMetricsResponseBodyGroupsMetrics] = None,
    ):
        self.group = group
        self.labels = labels
        self.metrics = metrics

    def validate(self):
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group is not None:
            result['group'] = self.group
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        result['metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['metrics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('group') is not None:
            self.group = m.get('group')
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = DescribeAddonMetricsResponseBodyGroupsLabels()
                self.labels.append(temp_model.from_map(k))
        self.metrics = []
        if m.get('metrics') is not None:
            for k in m.get('metrics'):
                temp_model = DescribeAddonMetricsResponseBodyGroupsMetrics()
                self.metrics.append(temp_model.from_map(k))
        return self


class DescribeAddonMetricsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        groups: List[DescribeAddonMetricsResponseBodyGroups] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.groups = groups
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.groups:
            for k in self.groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        result['groups'] = []
        if self.groups is not None:
            for k in self.groups:
                result['groups'].append(k.to_map() if k else None)
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        self.groups = []
        if m.get('groups') is not None:
            for k in m.get('groups'):
                temp_model = DescribeAddonMetricsResponseBodyGroups()
                self.groups.append(temp_model.from_map(k))
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeAddonMetricsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAddonMetricsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAddonMetricsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAddonReleaseResponseBodyReleaseConditions(TeaModel):
    def __init__(
        self,
        first_transition_time: str = None,
        last_transition_time: str = None,
        message: str = None,
        reason: str = None,
        status: str = None,
        type: str = None,
    ):
        self.first_transition_time = first_transition_time
        self.last_transition_time = last_transition_time
        self.message = message
        self.reason = reason
        self.status = status
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_transition_time is not None:
            result['firstTransitionTime'] = self.first_transition_time
        if self.last_transition_time is not None:
            result['lastTransitionTime'] = self.last_transition_time
        if self.message is not None:
            result['message'] = self.message
        if self.reason is not None:
            result['reason'] = self.reason
        if self.status is not None:
            result['status'] = self.status
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('firstTransitionTime') is not None:
            self.first_transition_time = m.get('firstTransitionTime')
        if m.get('lastTransitionTime') is not None:
            self.last_transition_time = m.get('lastTransitionTime')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeAddonReleaseResponseBodyRelease(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        alert_rule_count: int = None,
        conditions: List[DescribeAddonReleaseResponseBodyReleaseConditions] = None,
        config: str = None,
        create_time: str = None,
        dashboard_count: int = None,
        environment_id: str = None,
        exporter_count: int = None,
        have_config: bool = None,
        install_user_id: str = None,
        language: str = None,
        managed: bool = None,
        region_id: str = None,
        release_id: str = None,
        release_name: str = None,
        scene: str = None,
        status: str = None,
        update_time: str = None,
        user_id: str = None,
        version: str = None,
    ):
        self.addon_name = addon_name
        self.alert_rule_count = alert_rule_count
        self.conditions = conditions
        self.config = config
        self.create_time = create_time
        self.dashboard_count = dashboard_count
        self.environment_id = environment_id
        self.exporter_count = exporter_count
        self.have_config = have_config
        self.install_user_id = install_user_id
        self.language = language
        self.managed = managed
        self.region_id = region_id
        self.release_id = release_id
        self.release_name = release_name
        self.scene = scene
        self.status = status
        self.update_time = update_time
        self.user_id = user_id
        self.version = version

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.alert_rule_count is not None:
            result['alertRuleCount'] = self.alert_rule_count
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.config is not None:
            result['config'] = self.config
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.dashboard_count is not None:
            result['dashboardCount'] = self.dashboard_count
        if self.environment_id is not None:
            result['environmentId'] = self.environment_id
        if self.exporter_count is not None:
            result['exporterCount'] = self.exporter_count
        if self.have_config is not None:
            result['haveConfig'] = self.have_config
        if self.install_user_id is not None:
            result['installUserId'] = self.install_user_id
        if self.language is not None:
            result['language'] = self.language
        if self.managed is not None:
            result['managed'] = self.managed
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.release_id is not None:
            result['releaseId'] = self.release_id
        if self.release_name is not None:
            result['releaseName'] = self.release_name
        if self.scene is not None:
            result['scene'] = self.scene
        if self.status is not None:
            result['status'] = self.status
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.user_id is not None:
            result['userID'] = self.user_id
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('alertRuleCount') is not None:
            self.alert_rule_count = m.get('alertRuleCount')
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = DescribeAddonReleaseResponseBodyReleaseConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('config') is not None:
            self.config = m.get('config')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('dashboardCount') is not None:
            self.dashboard_count = m.get('dashboardCount')
        if m.get('environmentId') is not None:
            self.environment_id = m.get('environmentId')
        if m.get('exporterCount') is not None:
            self.exporter_count = m.get('exporterCount')
        if m.get('haveConfig') is not None:
            self.have_config = m.get('haveConfig')
        if m.get('installUserId') is not None:
            self.install_user_id = m.get('installUserId')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('managed') is not None:
            self.managed = m.get('managed')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('releaseId') is not None:
            self.release_id = m.get('releaseId')
        if m.get('releaseName') is not None:
            self.release_name = m.get('releaseName')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('userID') is not None:
            self.user_id = m.get('userID')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeAddonReleaseResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        config: str = None,
        message: str = None,
        release: DescribeAddonReleaseResponseBodyRelease = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.config = config
        self.message = message
        self.release = release
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.release:
            self.release.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.config is not None:
            result['config'] = self.config
        if self.message is not None:
            result['message'] = self.message
        if self.release is not None:
            result['release'] = self.release.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('config') is not None:
            self.config = m.get('config')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('release') is not None:
            temp_model = DescribeAddonReleaseResponseBodyRelease()
            self.release = temp_model.from_map(m['release'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeAddonReleaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAddonReleaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAddonReleaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAddonSchemaRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        environment_type: str = None,
        version: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.environment_type = environment_type
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.environment_type is not None:
            result['environmentType'] = self.environment_type
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('environmentType') is not None:
            self.environment_type = m.get('environmentType')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class DescribeAddonSchemaResponseBodyFieldsConditions(TeaModel):
    def __init__(
        self,
        action: str = None,
        field: str = None,
        op: str = None,
        value: Any = None,
    ):
        self.action = action
        self.field = field
        self.op = op
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['action'] = self.action
        if self.field is not None:
            result['field'] = self.field
        if self.op is not None:
            result['op'] = self.op
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action') is not None:
            self.action = m.get('action')
        if m.get('field') is not None:
            self.field = m.get('field')
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeAddonSchemaResponseBodyFieldsPropsDataSource(TeaModel):
    def __init__(
        self,
        label: str = None,
        value: str = None,
    ):
        self.label = label
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['label'] = self.label
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeAddonSchemaResponseBodyFieldsProps(TeaModel):
    def __init__(
        self,
        data_source: List[DescribeAddonSchemaResponseBodyFieldsPropsDataSource] = None,
        related: List[str] = None,
        select_mode: str = None,
    ):
        self.data_source = data_source
        self.related = related
        self.select_mode = select_mode

    def validate(self):
        if self.data_source:
            for k in self.data_source:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['dataSource'] = []
        if self.data_source is not None:
            for k in self.data_source:
                result['dataSource'].append(k.to_map() if k else None)
        if self.related is not None:
            result['related'] = self.related
        if self.select_mode is not None:
            result['selectMode'] = self.select_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_source = []
        if m.get('dataSource') is not None:
            for k in m.get('dataSource'):
                temp_model = DescribeAddonSchemaResponseBodyFieldsPropsDataSource()
                self.data_source.append(temp_model.from_map(k))
        if m.get('related') is not None:
            self.related = m.get('related')
        if m.get('selectMode') is not None:
            self.select_mode = m.get('selectMode')
        return self


class DescribeAddonSchemaResponseBodyFieldsValidation(TeaModel):
    def __init__(
        self,
        max: int = None,
        max_length: int = None,
        message: str = None,
        min: int = None,
        min_length: int = None,
        regular: str = None,
        required: bool = None,
    ):
        self.max = max
        self.max_length = max_length
        self.message = message
        self.min = min
        self.min_length = min_length
        self.regular = regular
        self.required = required

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['max'] = self.max
        if self.max_length is not None:
            result['maxLength'] = self.max_length
        if self.message is not None:
            result['message'] = self.message
        if self.min is not None:
            result['min'] = self.min
        if self.min_length is not None:
            result['minLength'] = self.min_length
        if self.regular is not None:
            result['regular'] = self.regular
        if self.required is not None:
            result['required'] = self.required
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('max') is not None:
            self.max = m.get('max')
        if m.get('maxLength') is not None:
            self.max_length = m.get('maxLength')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('min') is not None:
            self.min = m.get('min')
        if m.get('minLength') is not None:
            self.min_length = m.get('minLength')
        if m.get('regular') is not None:
            self.regular = m.get('regular')
        if m.get('required') is not None:
            self.required = m.get('required')
        return self


class DescribeAddonSchemaResponseBodyFields(TeaModel):
    def __init__(
        self,
        conditions: List[DescribeAddonSchemaResponseBodyFieldsConditions] = None,
        default_value: Any = None,
        description: str = None,
        disabled: bool = None,
        element: str = None,
        field_path: str = None,
        label: str = None,
        name: str = None,
        placeholder: str = None,
        props: DescribeAddonSchemaResponseBodyFieldsProps = None,
        type: str = None,
        validation: DescribeAddonSchemaResponseBodyFieldsValidation = None,
    ):
        self.conditions = conditions
        self.default_value = default_value
        self.description = description
        self.disabled = disabled
        self.element = element
        self.field_path = field_path
        self.label = label
        self.name = name
        self.placeholder = placeholder
        self.props = props
        self.type = type
        self.validation = validation

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()
        if self.props:
            self.props.validate()
        if self.validation:
            self.validation.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.default_value is not None:
            result['defaultValue'] = self.default_value
        if self.description is not None:
            result['description'] = self.description
        if self.disabled is not None:
            result['disabled'] = self.disabled
        if self.element is not None:
            result['element'] = self.element
        if self.field_path is not None:
            result['fieldPath'] = self.field_path
        if self.label is not None:
            result['label'] = self.label
        if self.name is not None:
            result['name'] = self.name
        if self.placeholder is not None:
            result['placeholder'] = self.placeholder
        if self.props is not None:
            result['props'] = self.props.to_map()
        if self.type is not None:
            result['type'] = self.type
        if self.validation is not None:
            result['validation'] = self.validation.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = DescribeAddonSchemaResponseBodyFieldsConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('defaultValue') is not None:
            self.default_value = m.get('defaultValue')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('disabled') is not None:
            self.disabled = m.get('disabled')
        if m.get('element') is not None:
            self.element = m.get('element')
        if m.get('fieldPath') is not None:
            self.field_path = m.get('fieldPath')
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('placeholder') is not None:
            self.placeholder = m.get('placeholder')
        if m.get('props') is not None:
            temp_model = DescribeAddonSchemaResponseBodyFieldsProps()
            self.props = temp_model.from_map(m['props'])
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('validation') is not None:
            temp_model = DescribeAddonSchemaResponseBodyFieldsValidation()
            self.validation = temp_model.from_map(m['validation'])
        return self


class DescribeAddonSchemaResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        component_name: str = None,
        fields: List[DescribeAddonSchemaResponseBodyFields] = None,
        message: str = None,
        messages: List[str] = None,
        request_id: str = None,
        success: str = None,
        type: str = None,
    ):
        self.code = code
        self.component_name = component_name
        self.fields = fields
        self.message = message
        self.messages = messages
        self.request_id = request_id
        self.success = success
        self.type = type

    def validate(self):
        if self.fields:
            for k in self.fields:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.component_name is not None:
            result['componentName'] = self.component_name
        result['fields'] = []
        if self.fields is not None:
            for k in self.fields:
                result['fields'].append(k.to_map() if k else None)
        if self.message is not None:
            result['message'] = self.message
        if self.messages is not None:
            result['messages'] = self.messages
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('componentName') is not None:
            self.component_name = m.get('componentName')
        self.fields = []
        if m.get('fields') is not None:
            for k in m.get('fields'):
                temp_model = DescribeAddonSchemaResponseBodyFields()
                self.fields.append(temp_model.from_map(k))
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('messages') is not None:
            self.messages = m.get('messages')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeAddonSchemaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAddonSchemaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAddonSchemaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCommonIncidentInfoRequestAggregate(TeaModel):
    def __init__(
        self,
        aggregate: str = None,
        alias: str = None,
        column: str = None,
    ):
        self.aggregate = aggregate
        self.alias = alias
        self.column = column

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aggregate is not None:
            result['aggregate'] = self.aggregate
        if self.alias is not None:
            result['alias'] = self.alias
        if self.column is not None:
            result['column'] = self.column
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aggregate') is not None:
            self.aggregate = m.get('aggregate')
        if m.get('alias') is not None:
            self.alias = m.get('alias')
        if m.get('column') is not None:
            self.column = m.get('column')
        return self


class DescribeCommonIncidentInfoRequestAndFilter(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeCommonIncidentInfoRequestOrFilter(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribeCommonIncidentInfoRequest(TeaModel):
    def __init__(
        self,
        aggregate: List[DescribeCommonIncidentInfoRequestAggregate] = None,
        and_filter: List[DescribeCommonIncidentInfoRequestAndFilter] = None,
        end_time: int = None,
        group_by: List[str] = None,
        max_results: str = None,
        next_token: str = None,
        or_filter: List[DescribeCommonIncidentInfoRequestOrFilter] = None,
        query_table: str = None,
        query_type: str = None,
        start_time: int = None,
    ):
        self.aggregate = aggregate
        self.and_filter = and_filter
        self.end_time = end_time
        self.group_by = group_by
        self.max_results = max_results
        self.next_token = next_token
        self.or_filter = or_filter
        self.query_table = query_table
        self.query_type = query_type
        self.start_time = start_time

    def validate(self):
        if self.aggregate:
            for k in self.aggregate:
                if k:
                    k.validate()
        if self.and_filter:
            for k in self.and_filter:
                if k:
                    k.validate()
        if self.or_filter:
            for k in self.or_filter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['aggregate'] = []
        if self.aggregate is not None:
            for k in self.aggregate:
                result['aggregate'].append(k.to_map() if k else None)
        result['andFilter'] = []
        if self.and_filter is not None:
            for k in self.and_filter:
                result['andFilter'].append(k.to_map() if k else None)
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.group_by is not None:
            result['groupBy'] = self.group_by
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['orFilter'] = []
        if self.or_filter is not None:
            for k in self.or_filter:
                result['orFilter'].append(k.to_map() if k else None)
        if self.query_table is not None:
            result['queryTable'] = self.query_table
        if self.query_type is not None:
            result['queryType'] = self.query_type
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.aggregate = []
        if m.get('aggregate') is not None:
            for k in m.get('aggregate'):
                temp_model = DescribeCommonIncidentInfoRequestAggregate()
                self.aggregate.append(temp_model.from_map(k))
        self.and_filter = []
        if m.get('andFilter') is not None:
            for k in m.get('andFilter'):
                temp_model = DescribeCommonIncidentInfoRequestAndFilter()
                self.and_filter.append(temp_model.from_map(k))
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('groupBy') is not None:
            self.group_by = m.get('groupBy')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.or_filter = []
        if m.get('orFilter') is not None:
            for k in m.get('orFilter'):
                temp_model = DescribeCommonIncidentInfoRequestOrFilter()
                self.or_filter.append(temp_model.from_map(k))
        if m.get('queryTable') is not None:
            self.query_table = m.get('queryTable')
        if m.get('queryType') is not None:
            self.query_type = m.get('queryType')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class DescribeCommonIncidentInfoResponseBody(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        request_id: str = None,
        result: Any = None,
    ):
        self.next_token = next_token
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class DescribeCommonIncidentInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCommonIncidentInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCommonIncidentInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnvDropMetricsRuleRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        region_id: str = None,
    ):
        # This parameter is required.
        self.environment_id = environment_id
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeEnvDropMetricsRuleResponseBodyData(TeaModel):
    def __init__(
        self,
        drop_metrics: str = None,
        rule_name: str = None,
    ):
        self.drop_metrics = drop_metrics
        self.rule_name = rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drop_metrics is not None:
            result['DropMetrics'] = self.drop_metrics
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DropMetrics') is not None:
            self.drop_metrics = m.get('DropMetrics')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class DescribeEnvDropMetricsRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: DescribeEnvDropMetricsRuleResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeEnvDropMetricsRuleResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEnvDropMetricsRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnvDropMetricsRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnvDropMetricsRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnvironmentRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
    ):
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeEnvironmentResponseBodyDataTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeEnvironmentResponseBodyData(TeaModel):
    def __init__(
        self,
        bind_resource_id: str = None,
        bind_resource_profile: str = None,
        bind_resource_status: str = None,
        bind_resource_store_duration: str = None,
        bind_resource_type: str = None,
        bind_vpc_cidr: str = None,
        db_instance_status: str = None,
        environment_id: str = None,
        environment_name: str = None,
        environment_sub_type: str = None,
        environment_type: str = None,
        fee_package: str = None,
        grafa_data_source_name: str = None,
        grafana_datasource_uid: str = None,
        grafana_folder_title: str = None,
        grafana_folder_uid: str = None,
        grafana_folder_url: str = None,
        grafana_workspace_id: str = None,
        managed_type: str = None,
        product: str = None,
        prometheus_instance_id: str = None,
        prometheus_instance_name: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        security_group_id: str = None,
        tags: List[DescribeEnvironmentResponseBodyDataTags] = None,
        user_id: str = None,
        vpc_id: str = None,
        vswitch_id: str = None,
        workspace: str = None,
    ):
        self.bind_resource_id = bind_resource_id
        self.bind_resource_profile = bind_resource_profile
        self.bind_resource_status = bind_resource_status
        self.bind_resource_store_duration = bind_resource_store_duration
        self.bind_resource_type = bind_resource_type
        self.bind_vpc_cidr = bind_vpc_cidr
        self.db_instance_status = db_instance_status
        self.environment_id = environment_id
        self.environment_name = environment_name
        self.environment_sub_type = environment_sub_type
        self.environment_type = environment_type
        self.fee_package = fee_package
        self.grafa_data_source_name = grafa_data_source_name
        self.grafana_datasource_uid = grafana_datasource_uid
        self.grafana_folder_title = grafana_folder_title
        self.grafana_folder_uid = grafana_folder_uid
        self.grafana_folder_url = grafana_folder_url
        self.grafana_workspace_id = grafana_workspace_id
        self.managed_type = managed_type
        self.product = product
        self.prometheus_instance_id = prometheus_instance_id
        self.prometheus_instance_name = prometheus_instance_name
        self.region_id = region_id
        self.resource_group_id = resource_group_id
        self.security_group_id = security_group_id
        self.tags = tags
        self.user_id = user_id
        self.vpc_id = vpc_id
        self.vswitch_id = vswitch_id
        self.workspace = workspace

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_resource_id is not None:
            result['BindResourceId'] = self.bind_resource_id
        if self.bind_resource_profile is not None:
            result['BindResourceProfile'] = self.bind_resource_profile
        if self.bind_resource_status is not None:
            result['BindResourceStatus'] = self.bind_resource_status
        if self.bind_resource_store_duration is not None:
            result['BindResourceStoreDuration'] = self.bind_resource_store_duration
        if self.bind_resource_type is not None:
            result['BindResourceType'] = self.bind_resource_type
        if self.bind_vpc_cidr is not None:
            result['BindVpcCidr'] = self.bind_vpc_cidr
        if self.db_instance_status is not None:
            result['DbInstanceStatus'] = self.db_instance_status
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.environment_name is not None:
            result['EnvironmentName'] = self.environment_name
        if self.environment_sub_type is not None:
            result['EnvironmentSubType'] = self.environment_sub_type
        if self.environment_type is not None:
            result['EnvironmentType'] = self.environment_type
        if self.fee_package is not None:
            result['FeePackage'] = self.fee_package
        if self.grafa_data_source_name is not None:
            result['GrafaDataSourceName'] = self.grafa_data_source_name
        if self.grafana_datasource_uid is not None:
            result['GrafanaDatasourceUid'] = self.grafana_datasource_uid
        if self.grafana_folder_title is not None:
            result['GrafanaFolderTitle'] = self.grafana_folder_title
        if self.grafana_folder_uid is not None:
            result['GrafanaFolderUid'] = self.grafana_folder_uid
        if self.grafana_folder_url is not None:
            result['GrafanaFolderUrl'] = self.grafana_folder_url
        if self.grafana_workspace_id is not None:
            result['GrafanaWorkspaceId'] = self.grafana_workspace_id
        if self.managed_type is not None:
            result['ManagedType'] = self.managed_type
        if self.product is not None:
            result['Product'] = self.product
        if self.prometheus_instance_id is not None:
            result['PrometheusInstanceId'] = self.prometheus_instance_id
        if self.prometheus_instance_name is not None:
            result['PrometheusInstanceName'] = self.prometheus_instance_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vswitch_id is not None:
            result['VswitchId'] = self.vswitch_id
        if self.workspace is not None:
            result['Workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BindResourceId') is not None:
            self.bind_resource_id = m.get('BindResourceId')
        if m.get('BindResourceProfile') is not None:
            self.bind_resource_profile = m.get('BindResourceProfile')
        if m.get('BindResourceStatus') is not None:
            self.bind_resource_status = m.get('BindResourceStatus')
        if m.get('BindResourceStoreDuration') is not None:
            self.bind_resource_store_duration = m.get('BindResourceStoreDuration')
        if m.get('BindResourceType') is not None:
            self.bind_resource_type = m.get('BindResourceType')
        if m.get('BindVpcCidr') is not None:
            self.bind_vpc_cidr = m.get('BindVpcCidr')
        if m.get('DbInstanceStatus') is not None:
            self.db_instance_status = m.get('DbInstanceStatus')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('EnvironmentName') is not None:
            self.environment_name = m.get('EnvironmentName')
        if m.get('EnvironmentSubType') is not None:
            self.environment_sub_type = m.get('EnvironmentSubType')
        if m.get('EnvironmentType') is not None:
            self.environment_type = m.get('EnvironmentType')
        if m.get('FeePackage') is not None:
            self.fee_package = m.get('FeePackage')
        if m.get('GrafaDataSourceName') is not None:
            self.grafa_data_source_name = m.get('GrafaDataSourceName')
        if m.get('GrafanaDatasourceUid') is not None:
            self.grafana_datasource_uid = m.get('GrafanaDatasourceUid')
        if m.get('GrafanaFolderTitle') is not None:
            self.grafana_folder_title = m.get('GrafanaFolderTitle')
        if m.get('GrafanaFolderUid') is not None:
            self.grafana_folder_uid = m.get('GrafanaFolderUid')
        if m.get('GrafanaFolderUrl') is not None:
            self.grafana_folder_url = m.get('GrafanaFolderUrl')
        if m.get('GrafanaWorkspaceId') is not None:
            self.grafana_workspace_id = m.get('GrafanaWorkspaceId')
        if m.get('ManagedType') is not None:
            self.managed_type = m.get('ManagedType')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('PrometheusInstanceId') is not None:
            self.prometheus_instance_id = m.get('PrometheusInstanceId')
        if m.get('PrometheusInstanceName') is not None:
            self.prometheus_instance_name = m.get('PrometheusInstanceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeEnvironmentResponseBodyDataTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VswitchId') is not None:
            self.vswitch_id = m.get('VswitchId')
        if m.get('Workspace') is not None:
            self.workspace = m.get('Workspace')
        return self


class DescribeEnvironmentResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: DescribeEnvironmentResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeEnvironmentResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEnvironmentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnvironmentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnvironmentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnvironmentFeatureRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        region_id: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeEnvironmentFeatureResponseBodyDataFeature(TeaModel):
    def __init__(
        self,
        alias: str = None,
        config: Dict[str, str] = None,
        description: str = None,
        environment_id: str = None,
        icon: str = None,
        language: str = None,
        latest_version: str = None,
        managed: bool = None,
        name: str = None,
        status: str = None,
        version: str = None,
    ):
        self.alias = alias
        self.config = config
        self.description = description
        self.environment_id = environment_id
        self.icon = icon
        self.language = language
        self.latest_version = latest_version
        self.managed = managed
        self.name = name
        self.status = status
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.config is not None:
            result['Config'] = self.config
        if self.description is not None:
            result['Description'] = self.description
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.language is not None:
            result['Language'] = self.language
        if self.latest_version is not None:
            result['LatestVersion'] = self.latest_version
        if self.managed is not None:
            result['Managed'] = self.managed
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('LatestVersion') is not None:
            self.latest_version = m.get('LatestVersion')
        if m.get('Managed') is not None:
            self.managed = m.get('Managed')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers(TeaModel):
    def __init__(
        self,
        args: List[str] = None,
        image: str = None,
        name: str = None,
    ):
        self.args = args
        self.image = image
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.args is not None:
            result['Args'] = self.args
        if self.image is not None:
            result['Image'] = self.image
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Args') is not None:
            self.args = m.get('Args')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeEnvironmentFeatureResponseBodyDataFeatureStatus(TeaModel):
    def __init__(
        self,
        bind_resource_id: str = None,
        feature_containers: List[DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers] = None,
        ips: List[str] = None,
        name: str = None,
        namespace: str = None,
        security_group_id: str = None,
        status: str = None,
        v_switch_id: str = None,
    ):
        self.bind_resource_id = bind_resource_id
        self.feature_containers = feature_containers
        self.ips = ips
        self.name = name
        self.namespace = namespace
        self.security_group_id = security_group_id
        self.status = status
        self.v_switch_id = v_switch_id

    def validate(self):
        if self.feature_containers:
            for k in self.feature_containers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_resource_id is not None:
            result['BindResourceId'] = self.bind_resource_id
        result['FeatureContainers'] = []
        if self.feature_containers is not None:
            for k in self.feature_containers:
                result['FeatureContainers'].append(k.to_map() if k else None)
        if self.ips is not None:
            result['Ips'] = self.ips
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.status is not None:
            result['Status'] = self.status
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BindResourceId') is not None:
            self.bind_resource_id = m.get('BindResourceId')
        self.feature_containers = []
        if m.get('FeatureContainers') is not None:
            for k in m.get('FeatureContainers'):
                temp_model = DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers()
                self.feature_containers.append(temp_model.from_map(k))
        if m.get('Ips') is not None:
            self.ips = m.get('Ips')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeEnvironmentFeatureResponseBodyData(TeaModel):
    def __init__(
        self,
        feature: DescribeEnvironmentFeatureResponseBodyDataFeature = None,
        feature_status: DescribeEnvironmentFeatureResponseBodyDataFeatureStatus = None,
    ):
        self.feature = feature
        self.feature_status = feature_status

    def validate(self):
        if self.feature:
            self.feature.validate()
        if self.feature_status:
            self.feature_status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.feature is not None:
            result['Feature'] = self.feature.to_map()
        if self.feature_status is not None:
            result['FeatureStatus'] = self.feature_status.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Feature') is not None:
            temp_model = DescribeEnvironmentFeatureResponseBodyDataFeature()
            self.feature = temp_model.from_map(m['Feature'])
        if m.get('FeatureStatus') is not None:
            temp_model = DescribeEnvironmentFeatureResponseBodyDataFeatureStatus()
            self.feature_status = temp_model.from_map(m['FeatureStatus'])
        return self


class DescribeEnvironmentFeatureResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: DescribeEnvironmentFeatureResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeEnvironmentFeatureResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeEnvironmentFeatureResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnvironmentFeatureResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnvironmentFeatureResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIncidentRequest(TeaModel):
    def __init__(
        self,
        and_filter: str = None,
        end_time: int = None,
        incident_id: str = None,
        incident_status: str = None,
        keyword: str = None,
        max_results: int = None,
        next_token: str = None,
        or_filter: str = None,
        order: bool = None,
        start_time: int = None,
    ):
        self.and_filter = and_filter
        self.end_time = end_time
        self.incident_id = incident_id
        self.incident_status = incident_status
        self.keyword = keyword
        self.max_results = max_results
        self.next_token = next_token
        self.or_filter = or_filter
        self.order = order
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.and_filter is not None:
            result['andFilter'] = self.and_filter
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        if self.incident_status is not None:
            result['incidentStatus'] = self.incident_status
        if self.keyword is not None:
            result['keyword'] = self.keyword
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.or_filter is not None:
            result['orFilter'] = self.or_filter
        if self.order is not None:
            result['order'] = self.order
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('andFilter') is not None:
            self.and_filter = m.get('andFilter')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        if m.get('incidentStatus') is not None:
            self.incident_status = m.get('incidentStatus')
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('orFilter') is not None:
            self.or_filter = m.get('orFilter')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class DescribeIncidentResponseBody(TeaModel):
    def __init__(
        self,
        incident_list: List[IncidentStruct] = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.incident_list = incident_list
        self.next_token = next_token
        self.request_id = request_id

    def validate(self):
        if self.incident_list:
            for k in self.incident_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['incidentList'] = []
        if self.incident_list is not None:
            for k in self.incident_list:
                result['incidentList'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.incident_list = []
        if m.get('incidentList') is not None:
            for k in m.get('incidentList'):
                temp_model = IncidentStruct()
                self.incident_list.append(temp_model.from_map(k))
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DescribeIncidentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeIncidentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIncidentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIncidentEscalationRequest(TeaModel):
    def __init__(
        self,
        incident_escalation_id: str = None,
        keyword: str = None,
        page_number: int = None,
        page_size: int = None,
        workspace: str = None,
    ):
        self.incident_escalation_id = incident_escalation_id
        self.keyword = keyword
        self.page_number = page_number
        self.page_size = page_size
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.incident_escalation_id is not None:
            result['incidentEscalationId'] = self.incident_escalation_id
        if self.keyword is not None:
            result['keyword'] = self.keyword
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('incidentEscalationId') is not None:
            self.incident_escalation_id = m.get('incidentEscalationId')
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DescribeIncidentEscalationResponseBody(TeaModel):
    def __init__(
        self,
        incident_escalations: List[IncidentEscalationStruct] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total: int = None,
    ):
        self.incident_escalations = incident_escalations
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total = total

    def validate(self):
        if self.incident_escalations:
            for k in self.incident_escalations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['incidentEscalations'] = []
        if self.incident_escalations is not None:
            for k in self.incident_escalations:
                result['incidentEscalations'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.incident_escalations = []
        if m.get('incidentEscalations') is not None:
            for k in m.get('incidentEscalations'):
                temp_model = IncidentEscalationStruct()
                self.incident_escalations.append(temp_model.from_map(k))
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class DescribeIncidentEscalationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeIncidentEscalationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIncidentEscalationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIncidentEventRequest(TeaModel):
    def __init__(
        self,
        incident_id: str = None,
        max_result: int = None,
        next_token: str = None,
        order: bool = None,
    ):
        self.incident_id = incident_id
        self.max_result = max_result
        self.next_token = next_token
        self.order = order

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        if self.max_result is not None:
            result['maxResult'] = self.max_result
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.order is not None:
            result['order'] = self.order
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        if m.get('maxResult') is not None:
            self.max_result = m.get('maxResult')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('order') is not None:
            self.order = m.get('order')
        return self


class DescribeIncidentEventResponseBody(TeaModel):
    def __init__(
        self,
        incident_event: List[IncidentEventStruct] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.incident_event = incident_event
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id

    def validate(self):
        if self.incident_event:
            for k in self.incident_event:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['incidentEvent'] = []
        if self.incident_event is not None:
            for k in self.incident_event:
                result['incidentEvent'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.incident_event = []
        if m.get('incidentEvent') is not None:
            for k in m.get('incidentEvent'):
                temp_model = IncidentEventStruct()
                self.incident_event.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DescribeIncidentEventResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeIncidentEventResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIncidentEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIncidentMemberRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        incident_id: str = None,
        max_results: int = None,
        next_token: str = None,
        order: bool = None,
        start_time: int = None,
    ):
        self.end_time = end_time
        self.incident_id = incident_id
        self.max_results = max_results
        self.next_token = next_token
        self.order = order
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.order is not None:
            result['order'] = self.order
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class DescribeIncidentMemberResponseBody(TeaModel):
    def __init__(
        self,
        incident_member: List[IncidentMemberStruct] = None,
        max_results: str = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.incident_member = incident_member
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id

    def validate(self):
        if self.incident_member:
            for k in self.incident_member:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['incidentMember'] = []
        if self.incident_member is not None:
            for k in self.incident_member:
                result['incidentMember'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.incident_member = []
        if m.get('incidentMember') is not None:
            for k in m.get('incidentMember'):
                temp_model = IncidentMemberStruct()
                self.incident_member.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DescribeIncidentMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeIncidentMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIncidentMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIncidentNoteListRequest(TeaModel):
    def __init__(
        self,
        incident_id: str = None,
        max_results: str = None,
        next_token: str = None,
    ):
        self.incident_id = incident_id
        self.max_results = max_results
        self.next_token = next_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        return self


class DescribeIncidentNoteListResponseBody(TeaModel):
    def __init__(
        self,
        list: List[IncidentNoteStruct] = None,
        request_id: str = None,
    ):
        self.list = list
        self.request_id = request_id

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['list'] = []
        if self.list is not None:
            for k in self.list:
                result['list'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('list') is not None:
            for k in m.get('list'):
                temp_model = IncidentNoteStruct()
                self.list.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DescribeIncidentNoteListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeIncidentNoteListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIncidentNoteListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIncidentPlanRequest(TeaModel):
    def __init__(
        self,
        incident_plan_id: str = None,
        keyword: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        self.incident_plan_id = incident_plan_id
        self.keyword = keyword
        self.page_number = page_number
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.incident_plan_id is not None:
            result['incidentPlanId'] = self.incident_plan_id
        if self.keyword is not None:
            result['keyword'] = self.keyword
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('incidentPlanId') is not None:
            self.incident_plan_id = m.get('incidentPlanId')
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        return self


class DescribeIncidentPlanResponseBody(TeaModel):
    def __init__(
        self,
        list: List[IncidentPlanStruct] = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total: int = None,
    ):
        self.list = list
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total = total

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['list'] = []
        if self.list is not None:
            for k in self.list:
                result['list'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('list') is not None:
            for k in m.get('list'):
                temp_model = IncidentPlanStruct()
                self.list.append(temp_model.from_map(k))
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class DescribeIncidentPlanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeIncidentPlanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIncidentPlanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIncidentResourceRequest(TeaModel):
    def __init__(
        self,
        incident_id: str = None,
        max_results: int = None,
        next_token: str = None,
        order: bool = None,
    ):
        self.incident_id = incident_id
        self.max_results = max_results
        self.next_token = next_token
        self.order = order

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.order is not None:
            result['order'] = self.order
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('order') is not None:
            self.order = m.get('order')
        return self


class DescribeIncidentResourceResponseBody(TeaModel):
    def __init__(
        self,
        incident_resource: List[IncidentResourceStruct] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.incident_resource = incident_resource
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id

    def validate(self):
        if self.incident_resource:
            for k in self.incident_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['incidentResource'] = []
        if self.incident_resource is not None:
            for k in self.incident_resource:
                result['incidentResource'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.incident_resource = []
        if m.get('incidentResource') is not None:
            for k in m.get('incidentResource'):
                temp_model = IncidentResourceStruct()
                self.incident_resource.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DescribeIncidentResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeIncidentResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIncidentResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIncidentTimelineRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        incident_id: str = None,
        max_results: int = None,
        next_token: str = None,
        order: bool = None,
        start_time: int = None,
        type: BinaryIO = None,
    ):
        self.end_time = end_time
        self.incident_id = incident_id
        self.max_results = max_results
        self.next_token = next_token
        self.order = order
        self.start_time = start_time
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.order is not None:
            result['order'] = self.order
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeIncidentTimelineResponseBody(TeaModel):
    def __init__(
        self,
        incident_timeline: List[IncidentTimeline] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.incident_timeline = incident_timeline
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id

    def validate(self):
        if self.incident_timeline:
            for k in self.incident_timeline:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['incidentTimeline'] = []
        if self.incident_timeline is not None:
            for k in self.incident_timeline:
                result['incidentTimeline'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.incident_timeline = []
        if m.get('incidentTimeline') is not None:
            for k in m.get('incidentTimeline'):
                temp_model = IncidentTimeline()
                self.incident_timeline.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DescribeIncidentTimelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeIncidentTimelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIncidentTimelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLayoutRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        bind_resource_id: str = None,
        environment_id: str = None,
        region_id: str = None,
        resource_type: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.bind_resource_id = bind_resource_id
        self.environment_id = environment_id
        self.region_id = region_id
        self.resource_type = resource_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.bind_resource_id is not None:
            result['BindResourceId'] = self.bind_resource_id
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('BindResourceId') is not None:
            self.bind_resource_id = m.get('BindResourceId')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class DescribeLayoutResponseBodyDataCategoriesDashboards(TeaModel):
    def __init__(
        self,
        conditions: Dict[str, str] = None,
        description: str = None,
        index: int = None,
        name: str = None,
        title: str = None,
        type: str = None,
    ):
        self.conditions = conditions
        self.description = description
        self.index = index
        self.name = name
        self.title = title
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conditions is not None:
            result['Conditions'] = self.conditions
        if self.description is not None:
            result['Description'] = self.description
        if self.index is not None:
            result['Index'] = self.index
        if self.name is not None:
            result['Name'] = self.name
        if self.title is not None:
            result['Title'] = self.title
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Conditions') is not None:
            self.conditions = m.get('Conditions')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeLayoutResponseBodyDataCategories(TeaModel):
    def __init__(
        self,
        dashboards: List[DescribeLayoutResponseBodyDataCategoriesDashboards] = None,
        index: int = None,
        name: str = None,
    ):
        self.dashboards = dashboards
        self.index = index
        self.name = name

    def validate(self):
        if self.dashboards:
            for k in self.dashboards:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Dashboards'] = []
        if self.dashboards is not None:
            for k in self.dashboards:
                result['Dashboards'].append(k.to_map() if k else None)
        if self.index is not None:
            result['Index'] = self.index
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dashboards = []
        if m.get('Dashboards') is not None:
            for k in m.get('Dashboards'):
                temp_model = DescribeLayoutResponseBodyDataCategoriesDashboards()
                self.dashboards.append(temp_model.from_map(k))
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeLayoutResponseBodyDataItems(TeaModel):
    def __init__(
        self,
        alias: str = None,
        description: str = None,
        id: str = None,
        name: str = None,
        tags: List[str] = None,
    ):
        self.alias = alias
        self.description = description
        self.id = id
        self.name = name
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class DescribeLayoutResponseBodyDataMetadata(TeaModel):
    def __init__(
        self,
        alias: str = None,
        description: str = None,
        id: str = None,
        name: str = None,
        tags: List[str] = None,
    ):
        self.alias = alias
        self.description = description
        self.id = id
        self.name = name
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class DescribeLayoutResponseBodyData(TeaModel):
    def __init__(
        self,
        categories: List[DescribeLayoutResponseBodyDataCategories] = None,
        items: List[DescribeLayoutResponseBodyDataItems] = None,
        metadata: DescribeLayoutResponseBodyDataMetadata = None,
    ):
        self.categories = categories
        self.items = items
        self.metadata = metadata

    def validate(self):
        if self.categories:
            for k in self.categories:
                if k:
                    k.validate()
        if self.items:
            for k in self.items:
                if k:
                    k.validate()
        if self.metadata:
            self.metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Categories'] = []
        if self.categories is not None:
            for k in self.categories:
                result['Categories'].append(k.to_map() if k else None)
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        if self.metadata is not None:
            result['Metadata'] = self.metadata.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.categories = []
        if m.get('Categories') is not None:
            for k in m.get('Categories'):
                temp_model = DescribeLayoutResponseBodyDataCategories()
                self.categories.append(temp_model.from_map(k))
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = DescribeLayoutResponseBodyDataItems()
                self.items.append(temp_model.from_map(k))
        if m.get('Metadata') is not None:
            temp_model = DescribeLayoutResponseBodyDataMetadata()
            self.metadata = temp_model.from_map(m['Metadata'])
        return self


class DescribeLayoutResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: DescribeLayoutResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeLayoutResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeLayoutResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLayoutResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLayoutResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLayoutViewRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        scene: str = None,
    ):
        self.region_id = region_id
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scene is not None:
            result['Scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        return self


class DescribeLayoutViewResponseBodyData(TeaModel):
    def __init__(
        self,
        global_view_id: str = None,
        region: str = None,
        scene: str = None,
        user_id: str = None,
    ):
        self.global_view_id = global_view_id
        self.region = region
        self.scene = scene
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.global_view_id is not None:
            result['GlobalViewId'] = self.global_view_id
        if self.region is not None:
            result['Region'] = self.region
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GlobalViewId') is not None:
            self.global_view_id = m.get('GlobalViewId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeLayoutViewResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[DescribeLayoutViewResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeLayoutViewResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeLayoutViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeLayoutViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLayoutViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMetricDataForAlertPreviewRequest(TeaModel):
    def __init__(
        self,
        datasource: str = None,
        end_time: int = None,
        limit: int = None,
        query: str = None,
        start_time: int = None,
    ):
        # This parameter is required.
        self.datasource = datasource
        # This parameter is required.
        self.end_time = end_time
        self.limit = limit
        # This parameter is required.
        self.query = query
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.datasource is not None:
            result['datasource'] = self.datasource
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.limit is not None:
            result['limit'] = self.limit
        if self.query is not None:
            result['query'] = self.query
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('datasource') is not None:
            self.datasource = m.get('datasource')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('limit') is not None:
            self.limit = m.get('limit')
        if m.get('query') is not None:
            self.query = m.get('query')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class DescribeMetricDataForAlertPreviewResponseBodyMetricListPoints(TeaModel):
    def __init__(
        self,
        t: str = None,
        v: str = None,
    ):
        self.t = t
        self.v = v

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.t is not None:
            result['t'] = self.t
        if self.v is not None:
            result['v'] = self.v
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('t') is not None:
            self.t = m.get('t')
        if m.get('v') is not None:
            self.v = m.get('v')
        return self


class DescribeMetricDataForAlertPreviewResponseBodyMetricList(TeaModel):
    def __init__(
        self,
        labels: Dict[str, Any] = None,
        points: List[DescribeMetricDataForAlertPreviewResponseBodyMetricListPoints] = None,
    ):
        self.labels = labels
        self.points = points

    def validate(self):
        if self.points:
            for k in self.points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.labels is not None:
            result['labels'] = self.labels
        result['points'] = []
        if self.points is not None:
            for k in self.points:
                result['points'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        self.points = []
        if m.get('points') is not None:
            for k in m.get('points'):
                temp_model = DescribeMetricDataForAlertPreviewResponseBodyMetricListPoints()
                self.points.append(temp_model.from_map(k))
        return self


class DescribeMetricDataForAlertPreviewResponseBody(TeaModel):
    def __init__(
        self,
        metric_list: List[DescribeMetricDataForAlertPreviewResponseBodyMetricList] = None,
        request_id: str = None,
    ):
        self.metric_list = metric_list
        self.request_id = request_id

    def validate(self):
        if self.metric_list:
            for k in self.metric_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['metricList'] = []
        if self.metric_list is not None:
            for k in self.metric_list:
                result['metricList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.metric_list = []
        if m.get('metricList') is not None:
            for k in m.get('metricList'):
                temp_model = DescribeMetricDataForAlertPreviewResponseBodyMetricList()
                self.metric_list.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DescribeMetricDataForAlertPreviewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeMetricDataForAlertPreviewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMetricDataForAlertPreviewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePolicyRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        filter_region_ids: str = None,
        page_number: int = None,
        page_size: int = None,
        policy_id: str = None,
        policy_name: str = None,
        policy_type: str = None,
    ):
        self.addon_name = addon_name
        self.filter_region_ids = filter_region_ids
        self.page_number = page_number
        self.page_size = page_size
        self.policy_id = policy_id
        self.policy_name = policy_name
        self.policy_type = policy_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.filter_region_ids is not None:
            result['filterRegionIDs'] = self.filter_region_ids
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.policy_id is not None:
            result['policyId'] = self.policy_id
        if self.policy_name is not None:
            result['policyName'] = self.policy_name
        if self.policy_type is not None:
            result['policyType'] = self.policy_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('filterRegionIDs') is not None:
            self.filter_region_ids = m.get('filterRegionIDs')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('policyId') is not None:
            self.policy_id = m.get('policyId')
        if m.get('policyName') is not None:
            self.policy_name = m.get('policyName')
        if m.get('policyType') is not None:
            self.policy_type = m.get('policyType')
        return self


class DescribePolicyResponseBodyPoliciesFilter(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        filter_conditions: Dict[str, str] = None,
        instance_ids: str = None,
        provider: str = None,
        taint_conditions: Dict[str, str] = None,
    ):
        self.cluster_id = cluster_id
        self.filter_conditions = filter_conditions
        self.instance_ids = instance_ids
        self.provider = provider
        self.taint_conditions = taint_conditions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['clusterId'] = self.cluster_id
        if self.filter_conditions is not None:
            result['filterConditions'] = self.filter_conditions
        if self.instance_ids is not None:
            result['instanceIds'] = self.instance_ids
        if self.provider is not None:
            result['provider'] = self.provider
        if self.taint_conditions is not None:
            result['taintConditions'] = self.taint_conditions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterId') is not None:
            self.cluster_id = m.get('clusterId')
        if m.get('filterConditions') is not None:
            self.filter_conditions = m.get('filterConditions')
        if m.get('instanceIds') is not None:
            self.instance_ids = m.get('instanceIds')
        if m.get('provider') is not None:
            self.provider = m.get('provider')
        if m.get('taintConditions') is not None:
            self.taint_conditions = m.get('taintConditions')
        return self


class DescribePolicyResponseBodyPoliciesManagedInfo(TeaModel):
    def __init__(
        self,
        security_group_id: str = None,
        vswitch_id: str = None,
    ):
        self.security_group_id = security_group_id
        self.vswitch_id = vswitch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group_id is not None:
            result['SecurityGroupID'] = self.security_group_id
        if self.vswitch_id is not None:
            result['VswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SecurityGroupID') is not None:
            self.security_group_id = m.get('SecurityGroupID')
        if m.get('VswitchId') is not None:
            self.vswitch_id = m.get('VswitchId')
        return self


class DescribePolicyResponseBodyPolicies(TeaModel):
    def __init__(
        self,
        filter: DescribePolicyResponseBodyPoliciesFilter = None,
        managed_info: DescribePolicyResponseBodyPoliciesManagedInfo = None,
        policy_id: str = None,
        policy_name: str = None,
        policy_type: str = None,
        region: str = None,
        user_id: str = None,
    ):
        self.filter = filter
        self.managed_info = managed_info
        self.policy_id = policy_id
        self.policy_name = policy_name
        self.policy_type = policy_type
        self.region = region
        self.user_id = user_id

    def validate(self):
        if self.filter:
            self.filter.validate()
        if self.managed_info:
            self.managed_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter is not None:
            result['filter'] = self.filter.to_map()
        if self.managed_info is not None:
            result['managedInfo'] = self.managed_info.to_map()
        if self.policy_id is not None:
            result['policyId'] = self.policy_id
        if self.policy_name is not None:
            result['policyName'] = self.policy_name
        if self.policy_type is not None:
            result['policyType'] = self.policy_type
        if self.region is not None:
            result['region'] = self.region
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('filter') is not None:
            temp_model = DescribePolicyResponseBodyPoliciesFilter()
            self.filter = temp_model.from_map(m['filter'])
        if m.get('managedInfo') is not None:
            temp_model = DescribePolicyResponseBodyPoliciesManagedInfo()
            self.managed_info = temp_model.from_map(m['managedInfo'])
        if m.get('policyId') is not None:
            self.policy_id = m.get('policyId')
        if m.get('policyName') is not None:
            self.policy_name = m.get('policyName')
        if m.get('policyType') is not None:
            self.policy_type = m.get('policyType')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class DescribePolicyResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        page_number: int = None,
        page_size: int = None,
        policies: List[DescribePolicyResponseBodyPolicies] = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.code = code
        self.message = message
        self.page_number = page_number
        self.page_size = page_size
        self.policies = policies
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.policies:
            for k in self.policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.message is not None:
            result['message'] = self.message
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        result['policies'] = []
        if self.policies is not None:
            for k in self.policies:
                result['policies'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        self.policies = []
        if m.get('policies') is not None:
            for k in m.get('policies'):
                temp_model = DescribePolicyResponseBodyPolicies()
                self.policies.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class DescribePolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePrometheusInstanceRequest(TeaModel):
    def __init__(
        self,
        resource_group_id: str = None,
    ):
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        return self


class DescribePrometheusInstanceResponseBodyPrometheusInstanceTags(TeaModel):
    def __init__(
        self,
        tag_key: str = None,
        tag_value: str = None,
    ):
        self.tag_key = tag_key
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_value is not None:
            result['tagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValue') is not None:
            self.tag_value = m.get('tagValue')
        return self


class DescribePrometheusInstanceResponseBodyPrometheusInstance(TeaModel):
    def __init__(
        self,
        access_type: str = None,
        archive_duration: int = None,
        auth_free_read_policy: str = None,
        auth_free_write_policy: str = None,
        auth_token: str = None,
        commercial_config: Dict[str, str] = None,
        create_time: str = None,
        enable_auth_free_read: bool = None,
        enable_auth_free_write: bool = None,
        enable_auth_token: bool = None,
        extra_info: Dict[str, str] = None,
        http_api_inter_url: str = None,
        http_api_intra_url: str = None,
        instance_type: str = None,
        payment_type: str = None,
        product: str = None,
        prometheus_instance_id: str = None,
        prometheus_instance_name: str = None,
        push_gateway_inter_url: str = None,
        push_gateway_intra_url: str = None,
        region_id: str = None,
        remote_read_inter_url: str = None,
        remote_read_intra_url: str = None,
        remote_write_inter_url: str = None,
        remote_write_intra_url: str = None,
        resource_group_id: str = None,
        resource_type: str = None,
        status: str = None,
        status_config: Dict[str, dict] = None,
        storage_duration: int = None,
        support_auth_types: List[str] = None,
        tags: List[DescribePrometheusInstanceResponseBodyPrometheusInstanceTags] = None,
        user_id: str = None,
        workspace: str = None,
    ):
        self.access_type = access_type
        self.archive_duration = archive_duration
        self.auth_free_read_policy = auth_free_read_policy
        self.auth_free_write_policy = auth_free_write_policy
        self.auth_token = auth_token
        self.commercial_config = commercial_config
        self.create_time = create_time
        self.enable_auth_free_read = enable_auth_free_read
        self.enable_auth_free_write = enable_auth_free_write
        self.enable_auth_token = enable_auth_token
        self.extra_info = extra_info
        self.http_api_inter_url = http_api_inter_url
        self.http_api_intra_url = http_api_intra_url
        self.instance_type = instance_type
        self.payment_type = payment_type
        self.product = product
        self.prometheus_instance_id = prometheus_instance_id
        self.prometheus_instance_name = prometheus_instance_name
        self.push_gateway_inter_url = push_gateway_inter_url
        self.push_gateway_intra_url = push_gateway_intra_url
        self.region_id = region_id
        self.remote_read_inter_url = remote_read_inter_url
        self.remote_read_intra_url = remote_read_intra_url
        self.remote_write_inter_url = remote_write_inter_url
        self.remote_write_intra_url = remote_write_intra_url
        self.resource_group_id = resource_group_id
        self.resource_type = resource_type
        self.status = status
        self.status_config = status_config
        self.storage_duration = storage_duration
        self.support_auth_types = support_auth_types
        self.tags = tags
        self.user_id = user_id
        self.workspace = workspace

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_type is not None:
            result['accessType'] = self.access_type
        if self.archive_duration is not None:
            result['archiveDuration'] = self.archive_duration
        if self.auth_free_read_policy is not None:
            result['authFreeReadPolicy'] = self.auth_free_read_policy
        if self.auth_free_write_policy is not None:
            result['authFreeWritePolicy'] = self.auth_free_write_policy
        if self.auth_token is not None:
            result['authToken'] = self.auth_token
        if self.commercial_config is not None:
            result['commercialConfig'] = self.commercial_config
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.enable_auth_free_read is not None:
            result['enableAuthFreeRead'] = self.enable_auth_free_read
        if self.enable_auth_free_write is not None:
            result['enableAuthFreeWrite'] = self.enable_auth_free_write
        if self.enable_auth_token is not None:
            result['enableAuthToken'] = self.enable_auth_token
        if self.extra_info is not None:
            result['extraInfo'] = self.extra_info
        if self.http_api_inter_url is not None:
            result['httpApiInterUrl'] = self.http_api_inter_url
        if self.http_api_intra_url is not None:
            result['httpApiIntraUrl'] = self.http_api_intra_url
        if self.instance_type is not None:
            result['instanceType'] = self.instance_type
        if self.payment_type is not None:
            result['paymentType'] = self.payment_type
        if self.product is not None:
            result['product'] = self.product
        if self.prometheus_instance_id is not None:
            result['prometheusInstanceId'] = self.prometheus_instance_id
        if self.prometheus_instance_name is not None:
            result['prometheusInstanceName'] = self.prometheus_instance_name
        if self.push_gateway_inter_url is not None:
            result['pushGatewayInterUrl'] = self.push_gateway_inter_url
        if self.push_gateway_intra_url is not None:
            result['pushGatewayIntraUrl'] = self.push_gateway_intra_url
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.remote_read_inter_url is not None:
            result['remoteReadInterUrl'] = self.remote_read_inter_url
        if self.remote_read_intra_url is not None:
            result['remoteReadIntraUrl'] = self.remote_read_intra_url
        if self.remote_write_inter_url is not None:
            result['remoteWriteInterUrl'] = self.remote_write_inter_url
        if self.remote_write_intra_url is not None:
            result['remoteWriteIntraUrl'] = self.remote_write_intra_url
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        if self.status is not None:
            result['status'] = self.status
        if self.status_config is not None:
            result['statusConfig'] = self.status_config
        if self.storage_duration is not None:
            result['storageDuration'] = self.storage_duration
        if self.support_auth_types is not None:
            result['supportAuthTypes'] = self.support_auth_types
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessType') is not None:
            self.access_type = m.get('accessType')
        if m.get('archiveDuration') is not None:
            self.archive_duration = m.get('archiveDuration')
        if m.get('authFreeReadPolicy') is not None:
            self.auth_free_read_policy = m.get('authFreeReadPolicy')
        if m.get('authFreeWritePolicy') is not None:
            self.auth_free_write_policy = m.get('authFreeWritePolicy')
        if m.get('authToken') is not None:
            self.auth_token = m.get('authToken')
        if m.get('commercialConfig') is not None:
            self.commercial_config = m.get('commercialConfig')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('enableAuthFreeRead') is not None:
            self.enable_auth_free_read = m.get('enableAuthFreeRead')
        if m.get('enableAuthFreeWrite') is not None:
            self.enable_auth_free_write = m.get('enableAuthFreeWrite')
        if m.get('enableAuthToken') is not None:
            self.enable_auth_token = m.get('enableAuthToken')
        if m.get('extraInfo') is not None:
            self.extra_info = m.get('extraInfo')
        if m.get('httpApiInterUrl') is not None:
            self.http_api_inter_url = m.get('httpApiInterUrl')
        if m.get('httpApiIntraUrl') is not None:
            self.http_api_intra_url = m.get('httpApiIntraUrl')
        if m.get('instanceType') is not None:
            self.instance_type = m.get('instanceType')
        if m.get('paymentType') is not None:
            self.payment_type = m.get('paymentType')
        if m.get('product') is not None:
            self.product = m.get('product')
        if m.get('prometheusInstanceId') is not None:
            self.prometheus_instance_id = m.get('prometheusInstanceId')
        if m.get('prometheusInstanceName') is not None:
            self.prometheus_instance_name = m.get('prometheusInstanceName')
        if m.get('pushGatewayInterUrl') is not None:
            self.push_gateway_inter_url = m.get('pushGatewayInterUrl')
        if m.get('pushGatewayIntraUrl') is not None:
            self.push_gateway_intra_url = m.get('pushGatewayIntraUrl')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('remoteReadInterUrl') is not None:
            self.remote_read_inter_url = m.get('remoteReadInterUrl')
        if m.get('remoteReadIntraUrl') is not None:
            self.remote_read_intra_url = m.get('remoteReadIntraUrl')
        if m.get('remoteWriteInterUrl') is not None:
            self.remote_write_inter_url = m.get('remoteWriteInterUrl')
        if m.get('remoteWriteIntraUrl') is not None:
            self.remote_write_intra_url = m.get('remoteWriteIntraUrl')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('statusConfig') is not None:
            self.status_config = m.get('statusConfig')
        if m.get('storageDuration') is not None:
            self.storage_duration = m.get('storageDuration')
        if m.get('supportAuthTypes') is not None:
            self.support_auth_types = m.get('supportAuthTypes')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = DescribePrometheusInstanceResponseBodyPrometheusInstanceTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DescribePrometheusInstanceResponseBody(TeaModel):
    def __init__(
        self,
        prometheus_instance: DescribePrometheusInstanceResponseBodyPrometheusInstance = None,
        request_id: str = None,
    ):
        self.prometheus_instance = prometheus_instance
        self.request_id = request_id

    def validate(self):
        if self.prometheus_instance:
            self.prometheus_instance.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_instance is not None:
            result['prometheusInstance'] = self.prometheus_instance.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('prometheusInstance') is not None:
            temp_model = DescribePrometheusInstanceResponseBodyPrometheusInstance()
            self.prometheus_instance = temp_model.from_map(m['prometheusInstance'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DescribePrometheusInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePrometheusInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePrometheusInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePrometheusViewRequest(TeaModel):
    def __init__(
        self,
        resource_group_id: str = None,
    ):
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        return self


class DescribePrometheusViewResponseBodyPrometheusViewPrometheusInstances(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        region_id: str = None,
        user_id: str = None,
    ):
        self.instance_id = instance_id
        self.region_id = region_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['instanceId'] = self.instance_id
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('instanceId') is not None:
            self.instance_id = m.get('instanceId')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class DescribePrometheusViewResponseBodyPrometheusViewTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DescribePrometheusViewResponseBodyPrometheusView(TeaModel):
    def __init__(
        self,
        auth_free_read_policy: str = None,
        create_time: str = None,
        enable_auth_free_read: bool = None,
        http_api_inter_url: str = None,
        http_api_intra_url: str = None,
        prometheus_instances: List[DescribePrometheusViewResponseBodyPrometheusViewPrometheusInstances] = None,
        prometheus_view_id: str = None,
        prometheus_view_name: str = None,
        region_id: str = None,
        remote_read_inter_url: str = None,
        remote_read_intra_url: str = None,
        resource_group_id: str = None,
        resource_type: str = None,
        status: str = None,
        support_auth_types: List[str] = None,
        tags: List[DescribePrometheusViewResponseBodyPrometheusViewTags] = None,
        user_id: str = None,
        workspace: str = None,
    ):
        self.auth_free_read_policy = auth_free_read_policy
        self.create_time = create_time
        self.enable_auth_free_read = enable_auth_free_read
        self.http_api_inter_url = http_api_inter_url
        self.http_api_intra_url = http_api_intra_url
        self.prometheus_instances = prometheus_instances
        self.prometheus_view_id = prometheus_view_id
        self.prometheus_view_name = prometheus_view_name
        self.region_id = region_id
        self.remote_read_inter_url = remote_read_inter_url
        self.remote_read_intra_url = remote_read_intra_url
        self.resource_group_id = resource_group_id
        self.resource_type = resource_type
        self.status = status
        self.support_auth_types = support_auth_types
        self.tags = tags
        self.user_id = user_id
        self.workspace = workspace

    def validate(self):
        if self.prometheus_instances:
            for k in self.prometheus_instances:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_free_read_policy is not None:
            result['authFreeReadPolicy'] = self.auth_free_read_policy
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.enable_auth_free_read is not None:
            result['enableAuthFreeRead'] = self.enable_auth_free_read
        if self.http_api_inter_url is not None:
            result['httpApiInterUrl'] = self.http_api_inter_url
        if self.http_api_intra_url is not None:
            result['httpApiIntraUrl'] = self.http_api_intra_url
        result['prometheusInstances'] = []
        if self.prometheus_instances is not None:
            for k in self.prometheus_instances:
                result['prometheusInstances'].append(k.to_map() if k else None)
        if self.prometheus_view_id is not None:
            result['prometheusViewId'] = self.prometheus_view_id
        if self.prometheus_view_name is not None:
            result['prometheusViewName'] = self.prometheus_view_name
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.remote_read_inter_url is not None:
            result['remoteReadInterUrl'] = self.remote_read_inter_url
        if self.remote_read_intra_url is not None:
            result['remoteReadIntraUrl'] = self.remote_read_intra_url
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        if self.status is not None:
            result['status'] = self.status
        if self.support_auth_types is not None:
            result['supportAuthTypes'] = self.support_auth_types
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authFreeReadPolicy') is not None:
            self.auth_free_read_policy = m.get('authFreeReadPolicy')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('enableAuthFreeRead') is not None:
            self.enable_auth_free_read = m.get('enableAuthFreeRead')
        if m.get('httpApiInterUrl') is not None:
            self.http_api_inter_url = m.get('httpApiInterUrl')
        if m.get('httpApiIntraUrl') is not None:
            self.http_api_intra_url = m.get('httpApiIntraUrl')
        self.prometheus_instances = []
        if m.get('prometheusInstances') is not None:
            for k in m.get('prometheusInstances'):
                temp_model = DescribePrometheusViewResponseBodyPrometheusViewPrometheusInstances()
                self.prometheus_instances.append(temp_model.from_map(k))
        if m.get('prometheusViewId') is not None:
            self.prometheus_view_id = m.get('prometheusViewId')
        if m.get('prometheusViewName') is not None:
            self.prometheus_view_name = m.get('prometheusViewName')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('remoteReadInterUrl') is not None:
            self.remote_read_inter_url = m.get('remoteReadInterUrl')
        if m.get('remoteReadIntraUrl') is not None:
            self.remote_read_intra_url = m.get('remoteReadIntraUrl')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('supportAuthTypes') is not None:
            self.support_auth_types = m.get('supportAuthTypes')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = DescribePrometheusViewResponseBodyPrometheusViewTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DescribePrometheusViewResponseBody(TeaModel):
    def __init__(
        self,
        prometheus_view: DescribePrometheusViewResponseBodyPrometheusView = None,
        request_id: str = None,
    ):
        self.prometheus_view = prometheus_view
        self.request_id = request_id

    def validate(self):
        if self.prometheus_view:
            self.prometheus_view.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_view is not None:
            result['prometheusView'] = self.prometheus_view.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('prometheusView') is not None:
            temp_model = DescribePrometheusViewResponseBodyPrometheusView()
            self.prometheus_view = temp_model.from_map(m['prometheusView'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DescribePrometheusViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePrometheusViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePrometheusViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DetailMetricTargetRequest(TeaModel):
    def __init__(
        self,
        job_name: str = None,
        target_url: str = None,
    ):
        self.job_name = job_name
        # This parameter is required.
        self.target_url = target_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_name is not None:
            result['jobName'] = self.job_name
        if self.target_url is not None:
            result['targetUrl'] = self.target_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('jobName') is not None:
            self.job_name = m.get('jobName')
        if m.get('targetUrl') is not None:
            self.target_url = m.get('targetUrl')
        return self


class DetailMetricTargetResponseBodyData(TeaModel):
    def __init__(
        self,
        check_result: str = None,
    ):
        self.check_result = check_result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_result is not None:
            result['checkResult'] = self.check_result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('checkResult') is not None:
            self.check_result = m.get('checkResult')
        return self


class DetailMetricTargetResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: DetailMetricTargetResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            temp_model = DetailMetricTargetResponseBodyData()
            self.data = temp_model.from_map(m['data'])
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DetailMetricTargetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DetailMetricTargetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DetailMetricTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableAlertEventIntegrationPolicyRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DisableAlertEventIntegrationPolicyResponseBody(TeaModel):
    def __init__(
        self,
        alert_event_integration_policy_id: str = None,
        request_id: str = None,
    ):
        self.alert_event_integration_policy_id = alert_event_integration_policy_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_event_integration_policy_id is not None:
            result['alertEventIntegrationPolicyId'] = self.alert_event_integration_policy_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertEventIntegrationPolicyId') is not None:
            self.alert_event_integration_policy_id = m.get('alertEventIntegrationPolicyId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DisableAlertEventIntegrationPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableAlertEventIntegrationPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableAlertEventIntegrationPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableAlertRuleRequest(TeaModel):
    def __init__(
        self,
        alert_rule_ids: List[str] = None,
    ):
        # This parameter is required.
        self.alert_rule_ids = alert_rule_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_ids is not None:
            result['alertRuleIds'] = self.alert_rule_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleIds') is not None:
            self.alert_rule_ids = m.get('alertRuleIds')
        return self


class DisableAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: int = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DisableAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableAlertRulesRequest(TeaModel):
    def __init__(
        self,
        alert_rule_ids: List[str] = None,
    ):
        # This parameter is required.
        self.alert_rule_ids = alert_rule_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_ids is not None:
            result['alertRuleIds'] = self.alert_rule_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleIds') is not None:
            self.alert_rule_ids = m.get('alertRuleIds')
        return self


class DisableAlertRulesShrinkRequest(TeaModel):
    def __init__(
        self,
        alert_rule_ids_shrink: str = None,
    ):
        # This parameter is required.
        self.alert_rule_ids_shrink = alert_rule_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_ids_shrink is not None:
            result['alertRuleIds'] = self.alert_rule_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleIds') is not None:
            self.alert_rule_ids_shrink = m.get('alertRuleIds')
        return self


class DisableAlertRulesResponseBody(TeaModel):
    def __init__(
        self,
        data: int = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DisableAlertRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableAlertRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableAlertRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableIntegrationRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DisableIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        integration_id: str = None,
        request_id: str = None,
    ):
        self.integration_id = integration_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integration_id is not None:
            result['integrationId'] = self.integration_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('integrationId') is not None:
            self.integration_id = m.get('integrationId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DisableIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableMaintainWindowRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        workspace: str = None,
    ):
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DisableMaintainWindowResponseBody(TeaModel):
    def __init__(
        self,
        maintain_window_id: str = None,
        request_id: str = None,
    ):
        self.maintain_window_id = maintain_window_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.maintain_window_id is not None:
            result['maintainWindowId'] = self.maintain_window_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maintainWindowId') is not None:
            self.maintain_window_id = m.get('maintainWindowId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DisableMaintainWindowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableMaintainWindowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableMaintainWindowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableNotifyStrategyRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        workspace: str = None,
    ):
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DisableNotifyStrategyResponseBody(TeaModel):
    def __init__(
        self,
        notify_strategy_id: str = None,
        request_id: str = None,
    ):
        self.notify_strategy_id = notify_strategy_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify_strategy_id is not None:
            result['notifyStrategyId'] = self.notify_strategy_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('notifyStrategyId') is not None:
            self.notify_strategy_id = m.get('notifyStrategyId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class DisableNotifyStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableNotifyStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableNotifyStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableSubscriptionRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DisableSubscriptionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        subscription_id: str = None,
    ):
        self.request_id = request_id
        self.subscription_id = subscription_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.subscription_id is not None:
            result['subscriptionId'] = self.subscription_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('subscriptionId') is not None:
            self.subscription_id = m.get('subscriptionId')
        return self


class DisableSubscriptionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableSubscriptionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableSubscriptionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableTransformerRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        workspace: str = None,
    ):
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DisableTransformerResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        transformer_id: str = None,
    ):
        self.request_id = request_id
        self.transformer_id = transformer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.transformer_id is not None:
            result['transformerId'] = self.transformer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('transformerId') is not None:
            self.transformer_id = m.get('transformerId')
        return self


class DisableTransformerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableTransformerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableTransformerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableAlertEventIntegrationPolicyRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        workspace: str = None,
    ):
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class EnableAlertEventIntegrationPolicyResponseBody(TeaModel):
    def __init__(
        self,
        alert_event_integration_policy_id: str = None,
        request_id: str = None,
    ):
        self.alert_event_integration_policy_id = alert_event_integration_policy_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_event_integration_policy_id is not None:
            result['alertEventIntegrationPolicyId'] = self.alert_event_integration_policy_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertEventIntegrationPolicyId') is not None:
            self.alert_event_integration_policy_id = m.get('alertEventIntegrationPolicyId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class EnableAlertEventIntegrationPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableAlertEventIntegrationPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableAlertEventIntegrationPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableAlertRuleRequest(TeaModel):
    def __init__(
        self,
        alert_rule_ids: List[str] = None,
    ):
        # This parameter is required.
        self.alert_rule_ids = alert_rule_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_ids is not None:
            result['alertRuleIds'] = self.alert_rule_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleIds') is not None:
            self.alert_rule_ids = m.get('alertRuleIds')
        return self


class EnableAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class EnableAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableAlertRulesRequest(TeaModel):
    def __init__(
        self,
        alert_rule_ids: List[str] = None,
    ):
        # This parameter is required.
        self.alert_rule_ids = alert_rule_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_ids is not None:
            result['alertRuleIds'] = self.alert_rule_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleIds') is not None:
            self.alert_rule_ids = m.get('alertRuleIds')
        return self


class EnableAlertRulesShrinkRequest(TeaModel):
    def __init__(
        self,
        alert_rule_ids_shrink: str = None,
    ):
        # This parameter is required.
        self.alert_rule_ids_shrink = alert_rule_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_ids_shrink is not None:
            result['alertRuleIds'] = self.alert_rule_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleIds') is not None:
            self.alert_rule_ids_shrink = m.get('alertRuleIds')
        return self


class EnableAlertRulesResponseBody(TeaModel):
    def __init__(
        self,
        data: int = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class EnableAlertRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableAlertRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableAlertRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableIntegrationRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        workspace: str = None,
    ):
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class EnableIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        integration_id: str = None,
        request_id: str = None,
    ):
        self.integration_id = integration_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integration_id is not None:
            result['integrationId'] = self.integration_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('integrationId') is not None:
            self.integration_id = m.get('integrationId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class EnableIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableMaintainWindowRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        workspace: str = None,
    ):
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class EnableMaintainWindowResponseBody(TeaModel):
    def __init__(
        self,
        maintain_window_id: str = None,
        request_id: str = None,
    ):
        self.maintain_window_id = maintain_window_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.maintain_window_id is not None:
            result['maintainWindowId'] = self.maintain_window_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maintainWindowId') is not None:
            self.maintain_window_id = m.get('maintainWindowId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class EnableMaintainWindowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableMaintainWindowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableMaintainWindowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableNotifyStrategyRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class EnableNotifyStrategyResponseBody(TeaModel):
    def __init__(
        self,
        notify_strategy_id: str = None,
        request_id: str = None,
    ):
        self.notify_strategy_id = notify_strategy_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify_strategy_id is not None:
            result['notifyStrategyId'] = self.notify_strategy_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('notifyStrategyId') is not None:
            self.notify_strategy_id = m.get('notifyStrategyId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class EnableNotifyStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableNotifyStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableNotifyStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableSubscriptionRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class EnableSubscriptionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        subscription_id: str = None,
    ):
        self.request_id = request_id
        self.subscription_id = subscription_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.subscription_id is not None:
            result['subscriptionId'] = self.subscription_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('subscriptionId') is not None:
            self.subscription_id = m.get('subscriptionId')
        return self


class EnableSubscriptionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableSubscriptionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableSubscriptionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableTransformerRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        workspace: str = None,
    ):
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class EnableTransformerResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        transformer_id: str = None,
    ):
        self.request_id = request_id
        self.transformer_id = transformer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.transformer_id is not None:
            result['transformerId'] = self.transformer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('transformerId') is not None:
            self.transformer_id = m.get('transformerId')
        return self


class EnableTransformerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableTransformerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableTransformerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAddonRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        version: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class GetAddonResponseBodyDataDashboards(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        url: str = None,
    ):
        self.description = description
        self.name = name
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class GetAddonResponseBodyDataEnvironmentsDependencies(TeaModel):
    def __init__(
        self,
        cluster_types: List[str] = None,
        features: Dict[str, bool] = None,
        services: List[str] = None,
    ):
        self.cluster_types = cluster_types
        self.features = features
        self.services = services

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_types is not None:
            result['clusterTypes'] = self.cluster_types
        if self.features is not None:
            result['features'] = self.features
        if self.services is not None:
            result['services'] = self.services
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterTypes') is not None:
            self.cluster_types = m.get('clusterTypes')
        if m.get('features') is not None:
            self.features = m.get('features')
        if m.get('services') is not None:
            self.services = m.get('services')
        return self


class GetAddonResponseBodyDataEnvironmentsPoliciesMetricCheckRule(TeaModel):
    def __init__(
        self,
        prom_ql: List[str] = None,
    ):
        self.prom_ql = prom_ql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prom_ql is not None:
            result['promQL'] = self.prom_ql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('promQL') is not None:
            self.prom_ql = m.get('promQL')
        return self


class GetAddonResponseBodyDataEnvironmentsPoliciesProtocols(TeaModel):
    def __init__(
        self,
        description: str = None,
        icon: str = None,
        label: str = None,
        name: str = None,
    ):
        self.description = description
        self.icon = icon
        self.label = label
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.icon is not None:
            result['icon'] = self.icon
        if self.label is not None:
            result['label'] = self.label
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetAddonResponseBodyDataEnvironmentsPolicies(TeaModel):
    def __init__(
        self,
        alert_default_status: str = None,
        default_install: bool = None,
        enable_service_account: bool = None,
        metric_check_rule: GetAddonResponseBodyDataEnvironmentsPoliciesMetricCheckRule = None,
        need_restart_after_integration: bool = None,
        protocols: List[GetAddonResponseBodyDataEnvironmentsPoliciesProtocols] = None,
        target_addon_name: str = None,
    ):
        self.alert_default_status = alert_default_status
        self.default_install = default_install
        self.enable_service_account = enable_service_account
        self.metric_check_rule = metric_check_rule
        self.need_restart_after_integration = need_restart_after_integration
        self.protocols = protocols
        self.target_addon_name = target_addon_name

    def validate(self):
        if self.metric_check_rule:
            self.metric_check_rule.validate()
        if self.protocols:
            for k in self.protocols:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_default_status is not None:
            result['alertDefaultStatus'] = self.alert_default_status
        if self.default_install is not None:
            result['defaultInstall'] = self.default_install
        if self.enable_service_account is not None:
            result['enableServiceAccount'] = self.enable_service_account
        if self.metric_check_rule is not None:
            result['metricCheckRule'] = self.metric_check_rule.to_map()
        if self.need_restart_after_integration is not None:
            result['needRestartAfterIntegration'] = self.need_restart_after_integration
        result['protocols'] = []
        if self.protocols is not None:
            for k in self.protocols:
                result['protocols'].append(k.to_map() if k else None)
        if self.target_addon_name is not None:
            result['targetAddonName'] = self.target_addon_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertDefaultStatus') is not None:
            self.alert_default_status = m.get('alertDefaultStatus')
        if m.get('defaultInstall') is not None:
            self.default_install = m.get('defaultInstall')
        if m.get('enableServiceAccount') is not None:
            self.enable_service_account = m.get('enableServiceAccount')
        if m.get('metricCheckRule') is not None:
            temp_model = GetAddonResponseBodyDataEnvironmentsPoliciesMetricCheckRule()
            self.metric_check_rule = temp_model.from_map(m['metricCheckRule'])
        if m.get('needRestartAfterIntegration') is not None:
            self.need_restart_after_integration = m.get('needRestartAfterIntegration')
        self.protocols = []
        if m.get('protocols') is not None:
            for k in m.get('protocols'):
                temp_model = GetAddonResponseBodyDataEnvironmentsPoliciesProtocols()
                self.protocols.append(temp_model.from_map(k))
        if m.get('targetAddonName') is not None:
            self.target_addon_name = m.get('targetAddonName')
        return self


class GetAddonResponseBodyDataEnvironments(TeaModel):
    def __init__(
        self,
        dependencies: GetAddonResponseBodyDataEnvironmentsDependencies = None,
        description: str = None,
        enable: bool = None,
        label: str = None,
        name: str = None,
        policies: GetAddonResponseBodyDataEnvironmentsPolicies = None,
        policy_type: str = None,
    ):
        self.dependencies = dependencies
        self.description = description
        self.enable = enable
        self.label = label
        self.name = name
        self.policies = policies
        self.policy_type = policy_type

    def validate(self):
        if self.dependencies:
            self.dependencies.validate()
        if self.policies:
            self.policies.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dependencies is not None:
            result['dependencies'] = self.dependencies.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.enable is not None:
            result['enable'] = self.enable
        if self.label is not None:
            result['label'] = self.label
        if self.name is not None:
            result['name'] = self.name
        if self.policies is not None:
            result['policies'] = self.policies.to_map()
        if self.policy_type is not None:
            result['policyType'] = self.policy_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dependencies') is not None:
            temp_model = GetAddonResponseBodyDataEnvironmentsDependencies()
            self.dependencies = temp_model.from_map(m['dependencies'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('policies') is not None:
            temp_model = GetAddonResponseBodyDataEnvironmentsPolicies()
            self.policies = temp_model.from_map(m['policies'])
        if m.get('policyType') is not None:
            self.policy_type = m.get('policyType')
        return self


class GetAddonResponseBodyData(TeaModel):
    def __init__(
        self,
        alias: str = None,
        categories: List[str] = None,
        dashboards: List[GetAddonResponseBodyDataDashboards] = None,
        description: str = None,
        environments: List[GetAddonResponseBodyDataEnvironments] = None,
        icon: str = None,
        keywords: List[str] = None,
        language: str = None,
        latest_release_create_time: str = None,
        name: str = None,
        once: bool = None,
        scene: str = None,
        version: str = None,
        weight: str = None,
    ):
        self.alias = alias
        self.categories = categories
        self.dashboards = dashboards
        self.description = description
        self.environments = environments
        self.icon = icon
        self.keywords = keywords
        self.language = language
        self.latest_release_create_time = latest_release_create_time
        self.name = name
        self.once = once
        self.scene = scene
        self.version = version
        self.weight = weight

    def validate(self):
        if self.dashboards:
            for k in self.dashboards:
                if k:
                    k.validate()
        if self.environments:
            for k in self.environments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['alias'] = self.alias
        if self.categories is not None:
            result['categories'] = self.categories
        result['dashboards'] = []
        if self.dashboards is not None:
            for k in self.dashboards:
                result['dashboards'].append(k.to_map() if k else None)
        if self.description is not None:
            result['description'] = self.description
        result['environments'] = []
        if self.environments is not None:
            for k in self.environments:
                result['environments'].append(k.to_map() if k else None)
        if self.icon is not None:
            result['icon'] = self.icon
        if self.keywords is not None:
            result['keywords'] = self.keywords
        if self.language is not None:
            result['language'] = self.language
        if self.latest_release_create_time is not None:
            result['latestReleaseCreateTime'] = self.latest_release_create_time
        if self.name is not None:
            result['name'] = self.name
        if self.once is not None:
            result['once'] = self.once
        if self.scene is not None:
            result['scene'] = self.scene
        if self.version is not None:
            result['version'] = self.version
        if self.weight is not None:
            result['weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alias') is not None:
            self.alias = m.get('alias')
        if m.get('categories') is not None:
            self.categories = m.get('categories')
        self.dashboards = []
        if m.get('dashboards') is not None:
            for k in m.get('dashboards'):
                temp_model = GetAddonResponseBodyDataDashboards()
                self.dashboards.append(temp_model.from_map(k))
        if m.get('description') is not None:
            self.description = m.get('description')
        self.environments = []
        if m.get('environments') is not None:
            for k in m.get('environments'):
                temp_model = GetAddonResponseBodyDataEnvironments()
                self.environments.append(temp_model.from_map(k))
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('keywords') is not None:
            self.keywords = m.get('keywords')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('latestReleaseCreateTime') is not None:
            self.latest_release_create_time = m.get('latestReleaseCreateTime')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('once') is not None:
            self.once = m.get('once')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        return self


class GetAddonResponseBody(TeaModel):
    def __init__(
        self,
        data: GetAddonResponseBodyData = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            temp_model = GetAddonResponseBodyData()
            self.data = temp_model.from_map(m['data'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetAddonResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAddonResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAddonResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAddonAlertTemplatesRequest(TeaModel):
    def __init__(
        self,
        addon_version: str = None,
        aliyun_lang: str = None,
        environment_type: str = None,
    ):
        self.addon_version = addon_version
        self.aliyun_lang = aliyun_lang
        self.environment_type = environment_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_version is not None:
            result['addonVersion'] = self.addon_version
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.environment_type is not None:
            result['environmentType'] = self.environment_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonVersion') is not None:
            self.addon_version = m.get('addonVersion')
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('environmentType') is not None:
            self.environment_type = m.get('environmentType')
        return self


class GetAddonAlertTemplatesResponseBodyRules(TeaModel):
    def __init__(
        self,
        annotations: Dict[str, str] = None,
        duration: str = None,
        group: str = None,
        labels: Dict[str, str] = None,
        level: str = None,
        message: str = None,
        name: str = None,
        prom_ql: str = None,
    ):
        self.annotations = annotations
        self.duration = duration
        self.group = group
        self.labels = labels
        self.level = level
        self.message = message
        self.name = name
        self.prom_ql = prom_ql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotations is not None:
            result['annotations'] = self.annotations
        if self.duration is not None:
            result['duration'] = self.duration
        if self.group is not None:
            result['group'] = self.group
        if self.labels is not None:
            result['labels'] = self.labels
        if self.level is not None:
            result['level'] = self.level
        if self.message is not None:
            result['message'] = self.message
        if self.name is not None:
            result['name'] = self.name
        if self.prom_ql is not None:
            result['promQL'] = self.prom_ql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('annotations') is not None:
            self.annotations = m.get('annotations')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('group') is not None:
            self.group = m.get('group')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('promQL') is not None:
            self.prom_ql = m.get('promQL')
        return self


class GetAddonAlertTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        rules: List[GetAddonAlertTemplatesResponseBodyRules] = None,
    ):
        self.request_id = request_id
        self.rules = rules

    def validate(self):
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.rules = []
        if m.get('rules') is not None:
            for k in m.get('rules'):
                temp_model = GetAddonAlertTemplatesResponseBodyRules()
                self.rules.append(temp_model.from_map(k))
        return self


class GetAddonAlertTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAddonAlertTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAddonAlertTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAddonCodeTemplateRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        environment_type: str = None,
        version: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.environment_type = environment_type
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.environment_type is not None:
            result['environmentType'] = self.environment_type
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('environmentType') is not None:
            self.environment_type = m.get('environmentType')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class GetAddonCodeTemplateResponseBodyCodes(TeaModel):
    def __init__(
        self,
        code_template: str = None,
        name: str = None,
    ):
        self.code_template = code_template
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code_template is not None:
            result['codeTemplate'] = self.code_template
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('codeTemplate') is not None:
            self.code_template = m.get('codeTemplate')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetAddonCodeTemplateResponseBody(TeaModel):
    def __init__(
        self,
        codes: List[GetAddonCodeTemplateResponseBodyCodes] = None,
        request_id: str = None,
    ):
        self.codes = codes
        self.request_id = request_id

    def validate(self):
        if self.codes:
            for k in self.codes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['codes'] = []
        if self.codes is not None:
            for k in self.codes:
                result['codes'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.codes = []
        if m.get('codes') is not None:
            for k in m.get('codes'):
                temp_model = GetAddonCodeTemplateResponseBodyCodes()
                self.codes.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetAddonCodeTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAddonCodeTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAddonCodeTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAddonMetricsRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        environment_type: str = None,
        version: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.environment_type = environment_type
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.environment_type is not None:
            result['environmentType'] = self.environment_type
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('environmentType') is not None:
            self.environment_type = m.get('environmentType')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class GetAddonMetricsResponseBodyGroupsLabels(TeaModel):
    def __init__(
        self,
        description: str = None,
        key: str = None,
        source: str = None,
    ):
        self.description = description
        self.key = key
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.key is not None:
            result['key'] = self.key
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class GetAddonMetricsResponseBodyGroupsMetricsLabels(TeaModel):
    def __init__(
        self,
        description: str = None,
        key: str = None,
        source: str = None,
    ):
        self.description = description
        self.key = key
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.key is not None:
            result['key'] = self.key
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class GetAddonMetricsResponseBodyGroupsMetrics(TeaModel):
    def __init__(
        self,
        description: str = None,
        labels: List[GetAddonMetricsResponseBodyGroupsMetricsLabels] = None,
        metric: str = None,
        type: str = None,
        unit: str = None,
    ):
        self.description = description
        self.labels = labels
        self.metric = metric
        self.type = type
        self.unit = unit

    def validate(self):
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.metric is not None:
            result['metric'] = self.metric
        if self.type is not None:
            result['type'] = self.type
        if self.unit is not None:
            result['unit'] = self.unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = GetAddonMetricsResponseBodyGroupsMetricsLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('metric') is not None:
            self.metric = m.get('metric')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('unit') is not None:
            self.unit = m.get('unit')
        return self


class GetAddonMetricsResponseBodyGroups(TeaModel):
    def __init__(
        self,
        group: str = None,
        labels: List[GetAddonMetricsResponseBodyGroupsLabels] = None,
        metrics: List[GetAddonMetricsResponseBodyGroupsMetrics] = None,
    ):
        self.group = group
        self.labels = labels
        self.metrics = metrics

    def validate(self):
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group is not None:
            result['group'] = self.group
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        result['metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['metrics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('group') is not None:
            self.group = m.get('group')
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = GetAddonMetricsResponseBodyGroupsLabels()
                self.labels.append(temp_model.from_map(k))
        self.metrics = []
        if m.get('metrics') is not None:
            for k in m.get('metrics'):
                temp_model = GetAddonMetricsResponseBodyGroupsMetrics()
                self.metrics.append(temp_model.from_map(k))
        return self


class GetAddonMetricsResponseBody(TeaModel):
    def __init__(
        self,
        groups: List[GetAddonMetricsResponseBodyGroups] = None,
        request_id: str = None,
    ):
        self.groups = groups
        self.request_id = request_id

    def validate(self):
        if self.groups:
            for k in self.groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['groups'] = []
        if self.groups is not None:
            for k in self.groups:
                result['groups'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.groups = []
        if m.get('groups') is not None:
            for k in m.get('groups'):
                temp_model = GetAddonMetricsResponseBodyGroups()
                self.groups.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetAddonMetricsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAddonMetricsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAddonMetricsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAddonReleaseResponseBodyReleaseConditions(TeaModel):
    def __init__(
        self,
        first_transition_time: str = None,
        last_transition_time: str = None,
        message: str = None,
        status: str = None,
        type: str = None,
    ):
        self.first_transition_time = first_transition_time
        self.last_transition_time = last_transition_time
        self.message = message
        self.status = status
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_transition_time is not None:
            result['firstTransitionTime'] = self.first_transition_time
        if self.last_transition_time is not None:
            result['lastTransitionTime'] = self.last_transition_time
        if self.message is not None:
            result['message'] = self.message
        if self.status is not None:
            result['status'] = self.status
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('firstTransitionTime') is not None:
            self.first_transition_time = m.get('firstTransitionTime')
        if m.get('lastTransitionTime') is not None:
            self.last_transition_time = m.get('lastTransitionTime')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetAddonReleaseResponseBodyRelease(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        alert_rule_count: int = None,
        conditions: List[GetAddonReleaseResponseBodyReleaseConditions] = None,
        config: str = None,
        create_time: str = None,
        dashboard_count: int = None,
        env_type: str = None,
        environment_id: str = None,
        exporter_count: int = None,
        have_config: bool = None,
        install_user_id: str = None,
        language: str = None,
        managed: bool = None,
        parent_addon_release_id: str = None,
        policy_id: str = None,
        region_id: str = None,
        release_id: str = None,
        release_name: str = None,
        scene: str = None,
        status: str = None,
        update_time: str = None,
        user_id: str = None,
        version: str = None,
        workspace: str = None,
    ):
        self.addon_name = addon_name
        self.alert_rule_count = alert_rule_count
        self.conditions = conditions
        self.config = config
        self.create_time = create_time
        self.dashboard_count = dashboard_count
        self.env_type = env_type
        self.environment_id = environment_id
        self.exporter_count = exporter_count
        self.have_config = have_config
        self.install_user_id = install_user_id
        self.language = language
        self.managed = managed
        self.parent_addon_release_id = parent_addon_release_id
        self.policy_id = policy_id
        self.region_id = region_id
        # Release ID。
        self.release_id = release_id
        self.release_name = release_name
        self.scene = scene
        self.status = status
        self.update_time = update_time
        self.user_id = user_id
        self.version = version
        self.workspace = workspace

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.alert_rule_count is not None:
            result['alertRuleCount'] = self.alert_rule_count
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.config is not None:
            result['config'] = self.config
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.dashboard_count is not None:
            result['dashboardCount'] = self.dashboard_count
        if self.env_type is not None:
            result['envType'] = self.env_type
        if self.environment_id is not None:
            result['environmentId'] = self.environment_id
        if self.exporter_count is not None:
            result['exporterCount'] = self.exporter_count
        if self.have_config is not None:
            result['haveConfig'] = self.have_config
        if self.install_user_id is not None:
            result['installUserId'] = self.install_user_id
        if self.language is not None:
            result['language'] = self.language
        if self.managed is not None:
            result['managed'] = self.managed
        if self.parent_addon_release_id is not None:
            result['parentAddonReleaseId'] = self.parent_addon_release_id
        if self.policy_id is not None:
            result['policyId'] = self.policy_id
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.release_id is not None:
            result['releaseId'] = self.release_id
        if self.release_name is not None:
            result['releaseName'] = self.release_name
        if self.scene is not None:
            result['scene'] = self.scene
        if self.status is not None:
            result['status'] = self.status
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.version is not None:
            result['version'] = self.version
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('alertRuleCount') is not None:
            self.alert_rule_count = m.get('alertRuleCount')
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = GetAddonReleaseResponseBodyReleaseConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('config') is not None:
            self.config = m.get('config')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('dashboardCount') is not None:
            self.dashboard_count = m.get('dashboardCount')
        if m.get('envType') is not None:
            self.env_type = m.get('envType')
        if m.get('environmentId') is not None:
            self.environment_id = m.get('environmentId')
        if m.get('exporterCount') is not None:
            self.exporter_count = m.get('exporterCount')
        if m.get('haveConfig') is not None:
            self.have_config = m.get('haveConfig')
        if m.get('installUserId') is not None:
            self.install_user_id = m.get('installUserId')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('managed') is not None:
            self.managed = m.get('managed')
        if m.get('parentAddonReleaseId') is not None:
            self.parent_addon_release_id = m.get('parentAddonReleaseId')
        if m.get('policyId') is not None:
            self.policy_id = m.get('policyId')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('releaseId') is not None:
            self.release_id = m.get('releaseId')
        if m.get('releaseName') is not None:
            self.release_name = m.get('releaseName')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class GetAddonReleaseResponseBody(TeaModel):
    def __init__(
        self,
        config: str = None,
        release: GetAddonReleaseResponseBodyRelease = None,
        request_id: str = None,
    ):
        self.config = config
        self.release = release
        self.request_id = request_id

    def validate(self):
        if self.release:
            self.release.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['config'] = self.config
        if self.release is not None:
            result['release'] = self.release.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('config') is not None:
            self.config = m.get('config')
        if m.get('release') is not None:
            temp_model = GetAddonReleaseResponseBodyRelease()
            self.release = temp_model.from_map(m['release'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetAddonReleaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAddonReleaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAddonReleaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAddonSchemaRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        environment_type: str = None,
        version: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.environment_type = environment_type
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.environment_type is not None:
            result['environmentType'] = self.environment_type
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('environmentType') is not None:
            self.environment_type = m.get('environmentType')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class GetAddonSchemaResponseBodyFieldsConditions(TeaModel):
    def __init__(
        self,
        action: str = None,
        field: str = None,
        op: str = None,
        value: Any = None,
    ):
        self.action = action
        self.field = field
        self.op = op
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['action'] = self.action
        if self.field is not None:
            result['field'] = self.field
        if self.op is not None:
            result['op'] = self.op
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action') is not None:
            self.action = m.get('action')
        if m.get('field') is not None:
            self.field = m.get('field')
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class GetAddonSchemaResponseBodyFieldsPropsDataSource(TeaModel):
    def __init__(
        self,
        label: str = None,
        value: str = None,
    ):
        self.label = label
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['label'] = self.label
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class GetAddonSchemaResponseBodyFieldsProps(TeaModel):
    def __init__(
        self,
        data_source: List[GetAddonSchemaResponseBodyFieldsPropsDataSource] = None,
        related: List[str] = None,
        select_mode: str = None,
    ):
        self.data_source = data_source
        self.related = related
        self.select_mode = select_mode

    def validate(self):
        if self.data_source:
            for k in self.data_source:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['dataSource'] = []
        if self.data_source is not None:
            for k in self.data_source:
                result['dataSource'].append(k.to_map() if k else None)
        if self.related is not None:
            result['related'] = self.related
        if self.select_mode is not None:
            result['selectMode'] = self.select_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_source = []
        if m.get('dataSource') is not None:
            for k in m.get('dataSource'):
                temp_model = GetAddonSchemaResponseBodyFieldsPropsDataSource()
                self.data_source.append(temp_model.from_map(k))
        if m.get('related') is not None:
            self.related = m.get('related')
        if m.get('selectMode') is not None:
            self.select_mode = m.get('selectMode')
        return self


class GetAddonSchemaResponseBodyFieldsValidation(TeaModel):
    def __init__(
        self,
        max: int = None,
        max_length: int = None,
        message: str = None,
        min: int = None,
        min_length: int = None,
        regular: str = None,
        required: bool = None,
    ):
        self.max = max
        self.max_length = max_length
        self.message = message
        self.min = min
        self.min_length = min_length
        self.regular = regular
        self.required = required

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['max'] = self.max
        if self.max_length is not None:
            result['maxLength'] = self.max_length
        if self.message is not None:
            result['message'] = self.message
        if self.min is not None:
            result['min'] = self.min
        if self.min_length is not None:
            result['minLength'] = self.min_length
        if self.regular is not None:
            result['regular'] = self.regular
        if self.required is not None:
            result['required'] = self.required
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('max') is not None:
            self.max = m.get('max')
        if m.get('maxLength') is not None:
            self.max_length = m.get('maxLength')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('min') is not None:
            self.min = m.get('min')
        if m.get('minLength') is not None:
            self.min_length = m.get('minLength')
        if m.get('regular') is not None:
            self.regular = m.get('regular')
        if m.get('required') is not None:
            self.required = m.get('required')
        return self


class GetAddonSchemaResponseBodyFields(TeaModel):
    def __init__(
        self,
        conditions: List[GetAddonSchemaResponseBodyFieldsConditions] = None,
        default_value: Any = None,
        description: str = None,
        disabled: bool = None,
        element: str = None,
        field_path: str = None,
        label: str = None,
        name: str = None,
        placeholder: str = None,
        props: GetAddonSchemaResponseBodyFieldsProps = None,
        type: str = None,
        validation: GetAddonSchemaResponseBodyFieldsValidation = None,
    ):
        self.conditions = conditions
        self.default_value = default_value
        self.description = description
        self.disabled = disabled
        self.element = element
        self.field_path = field_path
        self.label = label
        self.name = name
        self.placeholder = placeholder
        self.props = props
        self.type = type
        self.validation = validation

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()
        if self.props:
            self.props.validate()
        if self.validation:
            self.validation.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.default_value is not None:
            result['defaultValue'] = self.default_value
        if self.description is not None:
            result['description'] = self.description
        if self.disabled is not None:
            result['disabled'] = self.disabled
        if self.element is not None:
            result['element'] = self.element
        if self.field_path is not None:
            result['fieldPath'] = self.field_path
        if self.label is not None:
            result['label'] = self.label
        if self.name is not None:
            result['name'] = self.name
        if self.placeholder is not None:
            result['placeholder'] = self.placeholder
        if self.props is not None:
            result['props'] = self.props.to_map()
        if self.type is not None:
            result['type'] = self.type
        if self.validation is not None:
            result['validation'] = self.validation.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = GetAddonSchemaResponseBodyFieldsConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('defaultValue') is not None:
            self.default_value = m.get('defaultValue')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('disabled') is not None:
            self.disabled = m.get('disabled')
        if m.get('element') is not None:
            self.element = m.get('element')
        if m.get('fieldPath') is not None:
            self.field_path = m.get('fieldPath')
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('placeholder') is not None:
            self.placeholder = m.get('placeholder')
        if m.get('props') is not None:
            temp_model = GetAddonSchemaResponseBodyFieldsProps()
            self.props = temp_model.from_map(m['props'])
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('validation') is not None:
            temp_model = GetAddonSchemaResponseBodyFieldsValidation()
            self.validation = temp_model.from_map(m['validation'])
        return self


class GetAddonSchemaResponseBody(TeaModel):
    def __init__(
        self,
        fields: List[GetAddonSchemaResponseBodyFields] = None,
        request_id: str = None,
        type: str = None,
    ):
        self.fields = fields
        self.request_id = request_id
        self.type = type

    def validate(self):
        if self.fields:
            for k in self.fields:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['fields'] = []
        if self.fields is not None:
            for k in self.fields:
                result['fields'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.fields = []
        if m.get('fields') is not None:
            for k in m.get('fields'):
                temp_model = GetAddonSchemaResponseBodyFields()
                self.fields.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetAddonSchemaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAddonSchemaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAddonSchemaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAggTaskGroupResponseBodyAggTaskGroupTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class GetAggTaskGroupResponseBodyAggTaskGroup(TeaModel):
    def __init__(
        self,
        agg_task_group_config: str = None,
        agg_task_group_config_hash: str = None,
        agg_task_group_id: str = None,
        agg_task_group_name: str = None,
        cron_expr: str = None,
        delay: int = None,
        description: str = None,
        from_time: int = None,
        max_retries: int = None,
        max_run_time_in_seconds: int = None,
        precheck_string: str = None,
        region_id: str = None,
        schedule_mode: str = None,
        schedule_time_expr: str = None,
        source_prometheus_id: str = None,
        status: str = None,
        tags: List[GetAggTaskGroupResponseBodyAggTaskGroupTags] = None,
        target_prometheus_id: str = None,
        to_time: int = None,
        update_time: str = None,
        user_id: str = None,
    ):
        self.agg_task_group_config = agg_task_group_config
        self.agg_task_group_config_hash = agg_task_group_config_hash
        self.agg_task_group_id = agg_task_group_id
        self.agg_task_group_name = agg_task_group_name
        self.cron_expr = cron_expr
        self.delay = delay
        self.description = description
        self.from_time = from_time
        self.max_retries = max_retries
        self.max_run_time_in_seconds = max_run_time_in_seconds
        self.precheck_string = precheck_string
        self.region_id = region_id
        self.schedule_mode = schedule_mode
        self.schedule_time_expr = schedule_time_expr
        self.source_prometheus_id = source_prometheus_id
        self.status = status
        self.tags = tags
        self.target_prometheus_id = target_prometheus_id
        self.to_time = to_time
        self.update_time = update_time
        self.user_id = user_id

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agg_task_group_config is not None:
            result['aggTaskGroupConfig'] = self.agg_task_group_config
        if self.agg_task_group_config_hash is not None:
            result['aggTaskGroupConfigHash'] = self.agg_task_group_config_hash
        if self.agg_task_group_id is not None:
            result['aggTaskGroupId'] = self.agg_task_group_id
        if self.agg_task_group_name is not None:
            result['aggTaskGroupName'] = self.agg_task_group_name
        if self.cron_expr is not None:
            result['cronExpr'] = self.cron_expr
        if self.delay is not None:
            result['delay'] = self.delay
        if self.description is not None:
            result['description'] = self.description
        if self.from_time is not None:
            result['fromTime'] = self.from_time
        if self.max_retries is not None:
            result['maxRetries'] = self.max_retries
        if self.max_run_time_in_seconds is not None:
            result['maxRunTimeInSeconds'] = self.max_run_time_in_seconds
        if self.precheck_string is not None:
            result['precheckString'] = self.precheck_string
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.schedule_mode is not None:
            result['scheduleMode'] = self.schedule_mode
        if self.schedule_time_expr is not None:
            result['scheduleTimeExpr'] = self.schedule_time_expr
        if self.source_prometheus_id is not None:
            result['sourcePrometheusId'] = self.source_prometheus_id
        if self.status is not None:
            result['status'] = self.status
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.target_prometheus_id is not None:
            result['targetPrometheusId'] = self.target_prometheus_id
        if self.to_time is not None:
            result['toTime'] = self.to_time
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aggTaskGroupConfig') is not None:
            self.agg_task_group_config = m.get('aggTaskGroupConfig')
        if m.get('aggTaskGroupConfigHash') is not None:
            self.agg_task_group_config_hash = m.get('aggTaskGroupConfigHash')
        if m.get('aggTaskGroupId') is not None:
            self.agg_task_group_id = m.get('aggTaskGroupId')
        if m.get('aggTaskGroupName') is not None:
            self.agg_task_group_name = m.get('aggTaskGroupName')
        if m.get('cronExpr') is not None:
            self.cron_expr = m.get('cronExpr')
        if m.get('delay') is not None:
            self.delay = m.get('delay')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('fromTime') is not None:
            self.from_time = m.get('fromTime')
        if m.get('maxRetries') is not None:
            self.max_retries = m.get('maxRetries')
        if m.get('maxRunTimeInSeconds') is not None:
            self.max_run_time_in_seconds = m.get('maxRunTimeInSeconds')
        if m.get('precheckString') is not None:
            self.precheck_string = m.get('precheckString')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('scheduleMode') is not None:
            self.schedule_mode = m.get('scheduleMode')
        if m.get('scheduleTimeExpr') is not None:
            self.schedule_time_expr = m.get('scheduleTimeExpr')
        if m.get('sourcePrometheusId') is not None:
            self.source_prometheus_id = m.get('sourcePrometheusId')
        if m.get('status') is not None:
            self.status = m.get('status')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = GetAggTaskGroupResponseBodyAggTaskGroupTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('targetPrometheusId') is not None:
            self.target_prometheus_id = m.get('targetPrometheusId')
        if m.get('toTime') is not None:
            self.to_time = m.get('toTime')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class GetAggTaskGroupResponseBody(TeaModel):
    def __init__(
        self,
        agg_task_group: GetAggTaskGroupResponseBodyAggTaskGroup = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.agg_task_group = agg_task_group
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.agg_task_group:
            self.agg_task_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agg_task_group is not None:
            result['aggTaskGroup'] = self.agg_task_group.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aggTaskGroup') is not None:
            temp_model = GetAggTaskGroupResponseBodyAggTaskGroup()
            self.agg_task_group = temp_model.from_map(m['aggTaskGroup'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetAggTaskGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAggTaskGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAggTaskGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAlertActionRequest(TeaModel):
    def __init__(
        self,
        source: str = None,
    ):
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class GetAlertActionResponseBodyAlertActionsEssParam(TeaModel):
    def __init__(
        self,
        ess_group_id: str = None,
        ess_rule_id: str = None,
        region_id: str = None,
    ):
        self.ess_group_id = ess_group_id
        self.ess_rule_id = ess_rule_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ess_group_id is not None:
            result['essGroupId'] = self.ess_group_id
        if self.ess_rule_id is not None:
            result['essRuleId'] = self.ess_rule_id
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('essGroupId') is not None:
            self.ess_group_id = m.get('essGroupId')
        if m.get('essRuleId') is not None:
            self.ess_rule_id = m.get('essRuleId')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class GetAlertActionResponseBodyAlertActionsFcParam(TeaModel):
    def __init__(
        self,
        function: str = None,
        region_id: str = None,
        service: str = None,
    ):
        self.function = function
        self.region_id = region_id
        self.service = service

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function is not None:
            result['function'] = self.function
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.service is not None:
            result['service'] = self.service
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('function') is not None:
            self.function = m.get('function')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('service') is not None:
            self.service = m.get('service')
        return self


class GetAlertActionResponseBodyAlertActionsMnsParam(TeaModel):
    def __init__(
        self,
        mns_type: str = None,
        name: str = None,
        region_id: str = None,
    ):
        self.mns_type = mns_type
        self.name = name
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mns_type is not None:
            result['mnsType'] = self.mns_type
        if self.name is not None:
            result['name'] = self.name
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('mnsType') is not None:
            self.mns_type = m.get('mnsType')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class GetAlertActionResponseBodyAlertActionsPagerDutyParam(TeaModel):
    def __init__(
        self,
        key: str = None,
        url: str = None,
    ):
        self.key = key
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class GetAlertActionResponseBodyAlertActionsSlsParam(TeaModel):
    def __init__(
        self,
        logstore: str = None,
        project: str = None,
        region_id: str = None,
    ):
        self.logstore = logstore
        self.project = project
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logstore is not None:
            result['logstore'] = self.logstore
        if self.project is not None:
            result['project'] = self.project
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('logstore') is not None:
            self.logstore = m.get('logstore')
        if m.get('project') is not None:
            self.project = m.get('project')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class GetAlertActionResponseBodyAlertActionsWebhookParam(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        headers: Dict[str, str] = None,
        method: str = None,
        url: str = None,
    ):
        self.content_type = content_type
        self.headers = headers
        self.method = method
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.headers is not None:
            result['headers'] = self.headers
        if self.method is not None:
            result['method'] = self.method
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('method') is not None:
            self.method = m.get('method')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class GetAlertActionResponseBodyAlertActions(TeaModel):
    def __init__(
        self,
        alert_action_id: str = None,
        alert_action_name: str = None,
        ess_param: GetAlertActionResponseBodyAlertActionsEssParam = None,
        fc_param: GetAlertActionResponseBodyAlertActionsFcParam = None,
        mns_param: GetAlertActionResponseBodyAlertActionsMnsParam = None,
        pager_duty_param: GetAlertActionResponseBodyAlertActionsPagerDutyParam = None,
        sls_param: GetAlertActionResponseBodyAlertActionsSlsParam = None,
        type: str = None,
        webhook_param: GetAlertActionResponseBodyAlertActionsWebhookParam = None,
    ):
        self.alert_action_id = alert_action_id
        self.alert_action_name = alert_action_name
        self.ess_param = ess_param
        self.fc_param = fc_param
        self.mns_param = mns_param
        self.pager_duty_param = pager_duty_param
        self.sls_param = sls_param
        self.type = type
        self.webhook_param = webhook_param

    def validate(self):
        if self.ess_param:
            self.ess_param.validate()
        if self.fc_param:
            self.fc_param.validate()
        if self.mns_param:
            self.mns_param.validate()
        if self.pager_duty_param:
            self.pager_duty_param.validate()
        if self.sls_param:
            self.sls_param.validate()
        if self.webhook_param:
            self.webhook_param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_action_id is not None:
            result['alertActionId'] = self.alert_action_id
        if self.alert_action_name is not None:
            result['alertActionName'] = self.alert_action_name
        if self.ess_param is not None:
            result['essParam'] = self.ess_param.to_map()
        if self.fc_param is not None:
            result['fcParam'] = self.fc_param.to_map()
        if self.mns_param is not None:
            result['mnsParam'] = self.mns_param.to_map()
        if self.pager_duty_param is not None:
            result['pagerDutyParam'] = self.pager_duty_param.to_map()
        if self.sls_param is not None:
            result['slsParam'] = self.sls_param.to_map()
        if self.type is not None:
            result['type'] = self.type
        if self.webhook_param is not None:
            result['webhookParam'] = self.webhook_param.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertActionId') is not None:
            self.alert_action_id = m.get('alertActionId')
        if m.get('alertActionName') is not None:
            self.alert_action_name = m.get('alertActionName')
        if m.get('essParam') is not None:
            temp_model = GetAlertActionResponseBodyAlertActionsEssParam()
            self.ess_param = temp_model.from_map(m['essParam'])
        if m.get('fcParam') is not None:
            temp_model = GetAlertActionResponseBodyAlertActionsFcParam()
            self.fc_param = temp_model.from_map(m['fcParam'])
        if m.get('mnsParam') is not None:
            temp_model = GetAlertActionResponseBodyAlertActionsMnsParam()
            self.mns_param = temp_model.from_map(m['mnsParam'])
        if m.get('pagerDutyParam') is not None:
            temp_model = GetAlertActionResponseBodyAlertActionsPagerDutyParam()
            self.pager_duty_param = temp_model.from_map(m['pagerDutyParam'])
        if m.get('slsParam') is not None:
            temp_model = GetAlertActionResponseBodyAlertActionsSlsParam()
            self.sls_param = temp_model.from_map(m['slsParam'])
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('webhookParam') is not None:
            temp_model = GetAlertActionResponseBodyAlertActionsWebhookParam()
            self.webhook_param = temp_model.from_map(m['webhookParam'])
        return self


class GetAlertActionResponseBody(TeaModel):
    def __init__(
        self,
        alert_actions: GetAlertActionResponseBodyAlertActions = None,
        request_id: str = None,
    ):
        self.alert_actions = alert_actions
        self.request_id = request_id

    def validate(self):
        if self.alert_actions:
            self.alert_actions.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_actions is not None:
            result['alertActions'] = self.alert_actions.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertActions') is not None:
            temp_model = GetAlertActionResponseBodyAlertActions()
            self.alert_actions = temp_model.from_map(m['alertActions'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetAlertActionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAlertActionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAlertActionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAlertEventIntegrationPolicyRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class GetAlertEventIntegrationPolicyResponseBody(TeaModel):
    def __init__(
        self,
        alert_event_integration_policy: AlertEventIntegrationPolicyForView = None,
        request_id: str = None,
    ):
        self.alert_event_integration_policy = alert_event_integration_policy
        self.request_id = request_id

    def validate(self):
        if self.alert_event_integration_policy:
            self.alert_event_integration_policy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_event_integration_policy is not None:
            result['alertEventIntegrationPolicy'] = self.alert_event_integration_policy.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertEventIntegrationPolicy') is not None:
            temp_model = AlertEventIntegrationPolicyForView()
            self.alert_event_integration_policy = temp_model.from_map(m['alertEventIntegrationPolicy'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetAlertEventIntegrationPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAlertEventIntegrationPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAlertEventIntegrationPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetBizTraceResponseBody(TeaModel):
    def __init__(
        self,
        item: BizTraceConfig = None,
        request_id: str = None,
    ):
        self.item = item
        self.request_id = request_id

    def validate(self):
        if self.item:
            self.item.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item is not None:
            result['item'] = self.item.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('item') is not None:
            temp_model = BizTraceConfig()
            self.item = temp_model.from_map(m['item'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetBizTraceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetBizTraceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetBizTraceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCloudEnvironmentIdRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
    ):
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetCloudEnvironmentIdResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetCloudEnvironmentIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCloudEnvironmentIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCloudEnvironmentIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCloudResourceResponseBody(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        request_id: str = None,
    ):
        self.region_id = region_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetCloudResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCloudResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCloudResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCloudResourceDataHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        accept_encoding: str = None,
    ):
        self.common_headers = common_headers
        self.accept_encoding = accept_encoding

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.accept_encoding is not None:
            result['Accept-Encoding'] = self.accept_encoding
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('Accept-Encoding') is not None:
            self.accept_encoding = m.get('Accept-Encoding')
        return self


class GetCloudResourceDataRequest(TeaModel):
    def __init__(
        self,
        from_: int = None,
        query: str = None,
        to: int = None,
    ):
        # This parameter is required.
        self.from_ = from_
        # This parameter is required.
        self.query = query
        # This parameter is required.
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['from'] = self.from_
        if self.query is not None:
            result['query'] = self.query
        if self.to is not None:
            result['to'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('query') is not None:
            self.query = m.get('query')
        if m.get('to') is not None:
            self.to = m.get('to')
        return self


class GetCloudResourceDataResponseBody(TeaModel):
    def __init__(
        self,
        data: List[List[str]] = None,
        header: List[str] = None,
        request_id: str = None,
    ):
        self.data = data
        self.header = header
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.header is not None:
            result['header'] = self.header
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('header') is not None:
            self.header = m.get('header')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetCloudResourceDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCloudResourceDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCloudResourceDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCmsServiceResponseBody(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        request_id: str = None,
    ):
        self.enabled = enabled
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetCmsServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCmsServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCmsServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEntityGroupRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class GetEntityGroupResponseBodyEntityGroupEntityQueries(TeaModel):
    def __init__(
        self,
        entity_type: str = None,
        sql: str = None,
    ):
        self.entity_type = entity_type
        self.sql = sql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_type is not None:
            result['entityType'] = self.entity_type
        if self.sql is not None:
            result['sql'] = self.sql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('entityType') is not None:
            self.entity_type = m.get('entityType')
        if m.get('sql') is not None:
            self.sql = m.get('sql')
        return self


class GetEntityGroupResponseBodyEntityGroupEntityRulesAnnotations(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class GetEntityGroupResponseBodyEntityGroupEntityRulesFieldRules(TeaModel):
    def __init__(
        self,
        field_key: str = None,
        field_values: List[str] = None,
        op: str = None,
    ):
        self.field_key = field_key
        self.field_values = field_values
        self.op = op

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_key is not None:
            result['fieldKey'] = self.field_key
        if self.field_values is not None:
            result['fieldValues'] = self.field_values
        if self.op is not None:
            result['op'] = self.op
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldKey') is not None:
            self.field_key = m.get('fieldKey')
        if m.get('fieldValues') is not None:
            self.field_values = m.get('fieldValues')
        if m.get('op') is not None:
            self.op = m.get('op')
        return self


class GetEntityGroupResponseBodyEntityGroupEntityRulesIpMatchRule(TeaModel):
    def __init__(
        self,
        ip_cidr: str = None,
        ip_field_key: str = None,
    ):
        self.ip_cidr = ip_cidr
        self.ip_field_key = ip_field_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_cidr is not None:
            result['ipCIDR'] = self.ip_cidr
        if self.ip_field_key is not None:
            result['ipFieldKey'] = self.ip_field_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ipCIDR') is not None:
            self.ip_cidr = m.get('ipCIDR')
        if m.get('ipFieldKey') is not None:
            self.ip_field_key = m.get('ipFieldKey')
        return self


class GetEntityGroupResponseBodyEntityGroupEntityRulesLabels(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class GetEntityGroupResponseBodyEntityGroupEntityRulesTags(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class GetEntityGroupResponseBodyEntityGroupEntityRules(TeaModel):
    def __init__(
        self,
        annotations: List[GetEntityGroupResponseBodyEntityGroupEntityRulesAnnotations] = None,
        entity_types: List[str] = None,
        field_rules: List[GetEntityGroupResponseBodyEntityGroupEntityRulesFieldRules] = None,
        instance_ids: List[str] = None,
        ip_match_rule: GetEntityGroupResponseBodyEntityGroupEntityRulesIpMatchRule = None,
        labels: List[GetEntityGroupResponseBodyEntityGroupEntityRulesLabels] = None,
        resource_group_id: str = None,
        tags: List[GetEntityGroupResponseBodyEntityGroupEntityRulesTags] = None,
    ):
        self.annotations = annotations
        self.entity_types = entity_types
        self.field_rules = field_rules
        self.instance_ids = instance_ids
        self.ip_match_rule = ip_match_rule
        self.labels = labels
        self.resource_group_id = resource_group_id
        self.tags = tags

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.field_rules:
            for k in self.field_rules:
                if k:
                    k.validate()
        if self.ip_match_rule:
            self.ip_match_rule.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        if self.entity_types is not None:
            result['entityTypes'] = self.entity_types
        result['fieldRules'] = []
        if self.field_rules is not None:
            for k in self.field_rules:
                result['fieldRules'].append(k.to_map() if k else None)
        if self.instance_ids is not None:
            result['instanceIds'] = self.instance_ids
        if self.ip_match_rule is not None:
            result['ipMatchRule'] = self.ip_match_rule.to_map()
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = GetEntityGroupResponseBodyEntityGroupEntityRulesAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('entityTypes') is not None:
            self.entity_types = m.get('entityTypes')
        self.field_rules = []
        if m.get('fieldRules') is not None:
            for k in m.get('fieldRules'):
                temp_model = GetEntityGroupResponseBodyEntityGroupEntityRulesFieldRules()
                self.field_rules.append(temp_model.from_map(k))
        if m.get('instanceIds') is not None:
            self.instance_ids = m.get('instanceIds')
        if m.get('ipMatchRule') is not None:
            temp_model = GetEntityGroupResponseBodyEntityGroupEntityRulesIpMatchRule()
            self.ip_match_rule = temp_model.from_map(m['ipMatchRule'])
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = GetEntityGroupResponseBodyEntityGroupEntityRulesLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = GetEntityGroupResponseBodyEntityGroupEntityRulesTags()
                self.tags.append(temp_model.from_map(k))
        return self


class GetEntityGroupResponseBodyEntityGroup(TeaModel):
    def __init__(
        self,
        description: str = None,
        entity_group_id: str = None,
        entity_group_name: str = None,
        entity_queries: GetEntityGroupResponseBodyEntityGroupEntityQueries = None,
        entity_rules: GetEntityGroupResponseBodyEntityGroupEntityRules = None,
        query: str = None,
        region_id: str = None,
        user_id: str = None,
        workspace: str = None,
    ):
        self.description = description
        self.entity_group_id = entity_group_id
        self.entity_group_name = entity_group_name
        self.entity_queries = entity_queries
        self.entity_rules = entity_rules
        self.query = query
        self.region_id = region_id
        self.user_id = user_id
        self.workspace = workspace

    def validate(self):
        if self.entity_queries:
            self.entity_queries.validate()
        if self.entity_rules:
            self.entity_rules.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.entity_group_id is not None:
            result['entityGroupId'] = self.entity_group_id
        if self.entity_group_name is not None:
            result['entityGroupName'] = self.entity_group_name
        if self.entity_queries is not None:
            result['entityQueries'] = self.entity_queries.to_map()
        if self.entity_rules is not None:
            result['entityRules'] = self.entity_rules.to_map()
        if self.query is not None:
            result['query'] = self.query
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('entityGroupId') is not None:
            self.entity_group_id = m.get('entityGroupId')
        if m.get('entityGroupName') is not None:
            self.entity_group_name = m.get('entityGroupName')
        if m.get('entityQueries') is not None:
            temp_model = GetEntityGroupResponseBodyEntityGroupEntityQueries()
            self.entity_queries = temp_model.from_map(m['entityQueries'])
        if m.get('entityRules') is not None:
            temp_model = GetEntityGroupResponseBodyEntityGroupEntityRules()
            self.entity_rules = temp_model.from_map(m['entityRules'])
        if m.get('query') is not None:
            self.query = m.get('query')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class GetEntityGroupResponseBody(TeaModel):
    def __init__(
        self,
        entity_group: GetEntityGroupResponseBodyEntityGroup = None,
        request_id: str = None,
    ):
        self.entity_group = entity_group
        self.request_id = request_id

    def validate(self):
        if self.entity_group:
            self.entity_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_group is not None:
            result['entityGroup'] = self.entity_group.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('entityGroup') is not None:
            temp_model = GetEntityGroupResponseBodyEntityGroup()
            self.entity_group = temp_model.from_map(m['entityGroup'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetEntityGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEntityGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEntityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEntityStoreResponseBody(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        request_id: str = None,
        workspace_name: str = None,
    ):
        self.region_id = region_id
        self.request_id = request_id
        self.workspace_name = workspace_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.workspace_name is not None:
            result['workspaceName'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('workspaceName') is not None:
            self.workspace_name = m.get('workspaceName')
        return self


class GetEntityStoreResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEntityStoreResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEntityStoreResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEntityStoreDataHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        accept_encoding: str = None,
    ):
        self.common_headers = common_headers
        self.accept_encoding = accept_encoding

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.accept_encoding is not None:
            result['acceptEncoding'] = self.accept_encoding
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('acceptEncoding') is not None:
            self.accept_encoding = m.get('acceptEncoding')
        return self


class GetEntityStoreDataRequest(TeaModel):
    def __init__(
        self,
        from_: int = None,
        query: str = None,
        to: int = None,
    ):
        # This parameter is required.
        self.from_ = from_
        # This parameter is required.
        self.query = query
        # This parameter is required.
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['from'] = self.from_
        if self.query is not None:
            result['query'] = self.query
        if self.to is not None:
            result['to'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('query') is not None:
            self.query = m.get('query')
        if m.get('to') is not None:
            self.to = m.get('to')
        return self


class GetEntityStoreDataResponseBody(TeaModel):
    def __init__(
        self,
        data: List[List[str]] = None,
        header: List[str] = None,
        request_id: str = None,
    ):
        self.data = data
        self.header = header
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.header is not None:
            result['header'] = self.header
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('header') is not None:
            self.header = m.get('header')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetEntityStoreDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEntityStoreDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEntityStoreDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEnvironmentCountRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        resource_group_id: str = None,
    ):
        self.region_id = region_id
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class GetEnvironmentCountResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: Dict[str, int] = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetEnvironmentCountResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEnvironmentCountResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEnvironmentCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEnvironmentDiscoveryStatusRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        region_id: str = None,
    ):
        # This parameter is required.
        self.environment_id = environment_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetEnvironmentDiscoveryStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: Dict[str, str] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetEnvironmentDiscoveryStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEnvironmentDiscoveryStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEnvironmentDiscoveryStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEscalationRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class GetEscalationResponseBody(TeaModel):
    def __init__(
        self,
        escalation: EscalationForView = None,
        request_id: str = None,
    ):
        self.escalation = escalation
        self.request_id = request_id

    def validate(self):
        if self.escalation:
            self.escalation.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.escalation is not None:
            result['escalation'] = self.escalation.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('escalation') is not None:
            temp_model = EscalationForView()
            self.escalation = temp_model.from_map(m['escalation'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetEscalationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEscalationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEscalationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetIncidentRequest(TeaModel):
    def __init__(
        self,
        incident_id: str = None,
    ):
        self.incident_id = incident_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        return self


class GetIncidentResponseBody(TeaModel):
    def __init__(
        self,
        incident: IncidentStruct = None,
        request_id: str = None,
    ):
        self.incident = incident
        self.request_id = request_id

    def validate(self):
        if self.incident:
            self.incident.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.incident is not None:
            result['incident'] = self.incident.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('incident') is not None:
            temp_model = IncidentStruct()
            self.incident = temp_model.from_map(m['incident'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetIncidentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetIncidentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetIncidentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetIncidentEscalationRequest(TeaModel):
    def __init__(
        self,
        incident_escalation_id: str = None,
    ):
        self.incident_escalation_id = incident_escalation_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.incident_escalation_id is not None:
            result['incidentEscalationId'] = self.incident_escalation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('incidentEscalationId') is not None:
            self.incident_escalation_id = m.get('incidentEscalationId')
        return self


class GetIncidentEscalationResponseBody(TeaModel):
    def __init__(
        self,
        incident_escalation: IncidentEscalationStruct = None,
        request_id: str = None,
    ):
        self.incident_escalation = incident_escalation
        self.request_id = request_id

    def validate(self):
        if self.incident_escalation:
            self.incident_escalation.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.incident_escalation is not None:
            result['incidentEscalation'] = self.incident_escalation.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('incidentEscalation') is not None:
            temp_model = IncidentEscalationStruct()
            self.incident_escalation = temp_model.from_map(m['incidentEscalation'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetIncidentEscalationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetIncidentEscalationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetIncidentEscalationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetIncidentPlanRequest(TeaModel):
    def __init__(
        self,
        incident_plan_id: str = None,
    ):
        self.incident_plan_id = incident_plan_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.incident_plan_id is not None:
            result['incidentPlanId'] = self.incident_plan_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('incidentPlanId') is not None:
            self.incident_plan_id = m.get('incidentPlanId')
        return self


class GetIncidentPlanResponseBody(TeaModel):
    def __init__(
        self,
        incident_plan: IncidentPlanStruct = None,
        request_id: str = None,
    ):
        self.incident_plan = incident_plan
        self.request_id = request_id

    def validate(self):
        if self.incident_plan:
            self.incident_plan.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.incident_plan is not None:
            result['incidentPlan'] = self.incident_plan.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('incidentPlan') is not None:
            temp_model = IncidentPlanStruct()
            self.incident_plan = temp_model.from_map(m['incidentPlan'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetIncidentPlanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetIncidentPlanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetIncidentPlanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetIntegrationRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class GetIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        integration: IntegrationForView = None,
        request_id: str = None,
    ):
        self.integration = integration
        self.request_id = request_id

    def validate(self):
        if self.integration:
            self.integration.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integration is not None:
            result['integration'] = self.integration.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('integration') is not None:
            temp_model = IntegrationForView()
            self.integration = temp_model.from_map(m['integration'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetIntegrationPolicyResponseBodyPolicyBindResource(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_type: str = None,
        vpc_cidr: str = None,
        vpc_id: str = None,
    ):
        self.cluster_id = cluster_id
        self.cluster_type = cluster_type
        self.vpc_cidr = vpc_cidr
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['clusterId'] = self.cluster_id
        if self.cluster_type is not None:
            result['clusterType'] = self.cluster_type
        if self.vpc_cidr is not None:
            result['vpcCidr'] = self.vpc_cidr
        if self.vpc_id is not None:
            result['vpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterId') is not None:
            self.cluster_id = m.get('clusterId')
        if m.get('clusterType') is not None:
            self.cluster_type = m.get('clusterType')
        if m.get('vpcCidr') is not None:
            self.vpc_cidr = m.get('vpcCidr')
        if m.get('vpcId') is not None:
            self.vpc_id = m.get('vpcId')
        return self


class GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRulesAnnotations(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRulesFieldRules(TeaModel):
    def __init__(
        self,
        field_key: str = None,
        field_values: List[str] = None,
        op: str = None,
    ):
        self.field_key = field_key
        self.field_values = field_values
        self.op = op

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_key is not None:
            result['fieldKey'] = self.field_key
        if self.field_values is not None:
            result['fieldValues'] = self.field_values
        if self.op is not None:
            result['op'] = self.op
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldKey') is not None:
            self.field_key = m.get('fieldKey')
        if m.get('fieldValues') is not None:
            self.field_values = m.get('fieldValues')
        if m.get('op') is not None:
            self.op = m.get('op')
        return self


class GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRulesIpMatchRule(TeaModel):
    def __init__(
        self,
        ip_cidr: str = None,
        ip_field_key: str = None,
    ):
        self.ip_cidr = ip_cidr
        self.ip_field_key = ip_field_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_cidr is not None:
            result['ipCidr'] = self.ip_cidr
        if self.ip_field_key is not None:
            result['ipFieldKey'] = self.ip_field_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ipCidr') is not None:
            self.ip_cidr = m.get('ipCidr')
        if m.get('ipFieldKey') is not None:
            self.ip_field_key = m.get('ipFieldKey')
        return self


class GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRulesLabels(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRulesTags(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRules(TeaModel):
    def __init__(
        self,
        annotations: List[GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRulesAnnotations] = None,
        entity_types: List[str] = None,
        field_rules: List[GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRulesFieldRules] = None,
        instance_ids: List[str] = None,
        ip_match_rule: GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRulesIpMatchRule = None,
        labels: List[GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRulesLabels] = None,
        region_ids: List[str] = None,
        resource_group_id: str = None,
        tags: List[GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRulesTags] = None,
    ):
        self.annotations = annotations
        self.entity_types = entity_types
        self.field_rules = field_rules
        self.instance_ids = instance_ids
        self.ip_match_rule = ip_match_rule
        self.labels = labels
        self.region_ids = region_ids
        self.resource_group_id = resource_group_id
        self.tags = tags

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.field_rules:
            for k in self.field_rules:
                if k:
                    k.validate()
        if self.ip_match_rule:
            self.ip_match_rule.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        if self.entity_types is not None:
            result['entityTypes'] = self.entity_types
        result['fieldRules'] = []
        if self.field_rules is not None:
            for k in self.field_rules:
                result['fieldRules'].append(k.to_map() if k else None)
        if self.instance_ids is not None:
            result['instanceIds'] = self.instance_ids
        if self.ip_match_rule is not None:
            result['ipMatchRule'] = self.ip_match_rule.to_map()
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.region_ids is not None:
            result['regionIds'] = self.region_ids
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRulesAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('entityTypes') is not None:
            self.entity_types = m.get('entityTypes')
        self.field_rules = []
        if m.get('fieldRules') is not None:
            for k in m.get('fieldRules'):
                temp_model = GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRulesFieldRules()
                self.field_rules.append(temp_model.from_map(k))
        if m.get('instanceIds') is not None:
            self.instance_ids = m.get('instanceIds')
        if m.get('ipMatchRule') is not None:
            temp_model = GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRulesIpMatchRule()
            self.ip_match_rule = temp_model.from_map(m['ipMatchRule'])
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRulesLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('regionIds') is not None:
            self.region_ids = m.get('regionIds')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRulesTags()
                self.tags.append(temp_model.from_map(k))
        return self


class GetIntegrationPolicyResponseBodyPolicyEntityGroup(TeaModel):
    def __init__(
        self,
        description: str = None,
        entity_group_id: str = None,
        entity_group_name: str = None,
        entity_rules: GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRules = None,
        query: str = None,
        region_id: str = None,
        user_id: str = None,
        workspace: str = None,
    ):
        self.description = description
        self.entity_group_id = entity_group_id
        self.entity_group_name = entity_group_name
        self.entity_rules = entity_rules
        self.query = query
        self.region_id = region_id
        self.user_id = user_id
        self.workspace = workspace

    def validate(self):
        if self.entity_rules:
            self.entity_rules.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.entity_group_id is not None:
            result['entityGroupId'] = self.entity_group_id
        if self.entity_group_name is not None:
            result['entityGroupName'] = self.entity_group_name
        if self.entity_rules is not None:
            result['entityRules'] = self.entity_rules.to_map()
        if self.query is not None:
            result['query'] = self.query
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('entityGroupId') is not None:
            self.entity_group_id = m.get('entityGroupId')
        if m.get('entityGroupName') is not None:
            self.entity_group_name = m.get('entityGroupName')
        if m.get('entityRules') is not None:
            temp_model = GetIntegrationPolicyResponseBodyPolicyEntityGroupEntityRules()
            self.entity_rules = temp_model.from_map(m['entityRules'])
        if m.get('query') is not None:
            self.query = m.get('query')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class GetIntegrationPolicyResponseBodyPolicyManagedInfo(TeaModel):
    def __init__(
        self,
        security_group_id: str = None,
        vswitch_id: str = None,
    ):
        self.security_group_id = security_group_id
        self.vswitch_id = vswitch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group_id is not None:
            result['securityGroupId'] = self.security_group_id
        if self.vswitch_id is not None:
            result['vswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('securityGroupId') is not None:
            self.security_group_id = m.get('securityGroupId')
        if m.get('vswitchId') is not None:
            self.vswitch_id = m.get('vswitchId')
        return self


class GetIntegrationPolicyResponseBodyPolicyTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class GetIntegrationPolicyResponseBodyPolicy(TeaModel):
    def __init__(
        self,
        bind_resource: GetIntegrationPolicyResponseBodyPolicyBindResource = None,
        entity_group: GetIntegrationPolicyResponseBodyPolicyEntityGroup = None,
        managed_info: GetIntegrationPolicyResponseBodyPolicyManagedInfo = None,
        policy_id: str = None,
        policy_name: str = None,
        policy_type: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tags: List[GetIntegrationPolicyResponseBodyPolicyTags] = None,
        user_id: str = None,
        workspace: str = None,
    ):
        self.bind_resource = bind_resource
        self.entity_group = entity_group
        self.managed_info = managed_info
        self.policy_id = policy_id
        self.policy_name = policy_name
        self.policy_type = policy_type
        self.region_id = region_id
        self.resource_group_id = resource_group_id
        self.tags = tags
        self.user_id = user_id
        self.workspace = workspace

    def validate(self):
        if self.bind_resource:
            self.bind_resource.validate()
        if self.entity_group:
            self.entity_group.validate()
        if self.managed_info:
            self.managed_info.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_resource is not None:
            result['bindResource'] = self.bind_resource.to_map()
        if self.entity_group is not None:
            result['entityGroup'] = self.entity_group.to_map()
        if self.managed_info is not None:
            result['managedInfo'] = self.managed_info.to_map()
        if self.policy_id is not None:
            result['policyId'] = self.policy_id
        if self.policy_name is not None:
            result['policyName'] = self.policy_name
        if self.policy_type is not None:
            result['policyType'] = self.policy_type
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bindResource') is not None:
            temp_model = GetIntegrationPolicyResponseBodyPolicyBindResource()
            self.bind_resource = temp_model.from_map(m['bindResource'])
        if m.get('entityGroup') is not None:
            temp_model = GetIntegrationPolicyResponseBodyPolicyEntityGroup()
            self.entity_group = temp_model.from_map(m['entityGroup'])
        if m.get('managedInfo') is not None:
            temp_model = GetIntegrationPolicyResponseBodyPolicyManagedInfo()
            self.managed_info = temp_model.from_map(m['managedInfo'])
        if m.get('policyId') is not None:
            self.policy_id = m.get('policyId')
        if m.get('policyName') is not None:
            self.policy_name = m.get('policyName')
        if m.get('policyType') is not None:
            self.policy_type = m.get('policyType')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = GetIntegrationPolicyResponseBodyPolicyTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class GetIntegrationPolicyResponseBody(TeaModel):
    def __init__(
        self,
        policy: GetIntegrationPolicyResponseBodyPolicy = None,
        request_id: str = None,
    ):
        self.policy = policy
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.policy:
            self.policy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy is not None:
            result['policy'] = self.policy.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('policy') is not None:
            temp_model = GetIntegrationPolicyResponseBodyPolicy()
            self.policy = temp_model.from_map(m['policy'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetIntegrationPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetIntegrationPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetIntegrationPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetIntegrationPolicyTargetRequest(TeaModel):
    def __init__(
        self,
        job_name: str = None,
        target_url: str = None,
    ):
        self.job_name = job_name
        # This parameter is required.
        self.target_url = target_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_name is not None:
            result['jobName'] = self.job_name
        if self.target_url is not None:
            result['targetUrl'] = self.target_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('jobName') is not None:
            self.job_name = m.get('jobName')
        if m.get('targetUrl') is not None:
            self.target_url = m.get('targetUrl')
        return self


class GetIntegrationPolicyTargetResponseBodyData(TeaModel):
    def __init__(
        self,
        check_result: str = None,
    ):
        self.check_result = check_result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_result is not None:
            result['checkResult'] = self.check_result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('checkResult') is not None:
            self.check_result = m.get('checkResult')
        return self


class GetIntegrationPolicyTargetResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GetIntegrationPolicyTargetResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            temp_model = GetIntegrationPolicyTargetResponseBodyData()
            self.data = temp_model.from_map(m['data'])
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetIntegrationPolicyTargetResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetIntegrationPolicyTargetResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetIntegrationPolicyTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMaintainWindowRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class GetMaintainWindowResponseBody(TeaModel):
    def __init__(
        self,
        maintain_window: MaintainWindowForView = None,
        request_id: str = None,
    ):
        self.maintain_window = maintain_window
        self.request_id = request_id

    def validate(self):
        if self.maintain_window:
            self.maintain_window.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.maintain_window is not None:
            result['maintainWindow'] = self.maintain_window.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maintainWindow') is not None:
            temp_model = MaintainWindowForView()
            self.maintain_window = temp_model.from_map(m['maintainWindow'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetMaintainWindowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMaintainWindowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMaintainWindowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetNotifyStrategyRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class GetNotifyStrategyResponseBody(TeaModel):
    def __init__(
        self,
        notify_strategy: NotifyStrategyForView = None,
        request_id: str = None,
    ):
        self.notify_strategy = notify_strategy
        self.request_id = request_id

    def validate(self):
        if self.notify_strategy:
            self.notify_strategy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify_strategy is not None:
            result['notifyStrategy'] = self.notify_strategy.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('notifyStrategy') is not None:
            temp_model = NotifyStrategyForView()
            self.notify_strategy = temp_model.from_map(m['notifyStrategy'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetNotifyStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetNotifyStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetNotifyStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOncallScheduleRequest(TeaModel):
    def __init__(
        self,
        source: str = None,
    ):
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class GetOncallScheduleResponseBodyRotations(TeaModel):
    def __init__(
        self,
        active_days: List[int] = None,
        contacts: List[str] = None,
        rotation_end_time: str = None,
        rotation_name: str = None,
        rotation_start_time: str = None,
        shift_length: int = None,
        shift_recurrence_frequency: str = None,
        start_date: str = None,
        time_zone: str = None,
    ):
        self.active_days = active_days
        self.contacts = contacts
        self.rotation_end_time = rotation_end_time
        self.rotation_name = rotation_name
        self.rotation_start_time = rotation_start_time
        self.shift_length = shift_length
        self.shift_recurrence_frequency = shift_recurrence_frequency
        self.start_date = start_date
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_days is not None:
            result['activeDays'] = self.active_days
        if self.contacts is not None:
            result['contacts'] = self.contacts
        if self.rotation_end_time is not None:
            result['rotationEndTime'] = self.rotation_end_time
        if self.rotation_name is not None:
            result['rotationName'] = self.rotation_name
        if self.rotation_start_time is not None:
            result['rotationStartTime'] = self.rotation_start_time
        if self.shift_length is not None:
            result['shiftLength'] = self.shift_length
        if self.shift_recurrence_frequency is not None:
            result['shiftRecurrenceFrequency'] = self.shift_recurrence_frequency
        if self.start_date is not None:
            result['startDate'] = self.start_date
        if self.time_zone is not None:
            result['timeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('activeDays') is not None:
            self.active_days = m.get('activeDays')
        if m.get('contacts') is not None:
            self.contacts = m.get('contacts')
        if m.get('rotationEndTime') is not None:
            self.rotation_end_time = m.get('rotationEndTime')
        if m.get('rotationName') is not None:
            self.rotation_name = m.get('rotationName')
        if m.get('rotationStartTime') is not None:
            self.rotation_start_time = m.get('rotationStartTime')
        if m.get('shiftLength') is not None:
            self.shift_length = m.get('shiftLength')
        if m.get('shiftRecurrenceFrequency') is not None:
            self.shift_recurrence_frequency = m.get('shiftRecurrenceFrequency')
        if m.get('startDate') is not None:
            self.start_date = m.get('startDate')
        if m.get('timeZone') is not None:
            self.time_zone = m.get('timeZone')
        return self


class GetOncallScheduleResponseBody(TeaModel):
    def __init__(
        self,
        oncall_schedule_id: str = None,
        oncall_schedule_name: str = None,
        request_id: str = None,
        rotations: List[GetOncallScheduleResponseBodyRotations] = None,
        shift_robot_id: str = None,
    ):
        self.oncall_schedule_id = oncall_schedule_id
        self.oncall_schedule_name = oncall_schedule_name
        self.request_id = request_id
        self.rotations = rotations
        self.shift_robot_id = shift_robot_id

    def validate(self):
        if self.rotations:
            for k in self.rotations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.oncall_schedule_id is not None:
            result['oncallScheduleId'] = self.oncall_schedule_id
        if self.oncall_schedule_name is not None:
            result['oncallScheduleName'] = self.oncall_schedule_name
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['rotations'] = []
        if self.rotations is not None:
            for k in self.rotations:
                result['rotations'].append(k.to_map() if k else None)
        if self.shift_robot_id is not None:
            result['shiftRobotId'] = self.shift_robot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('oncallScheduleId') is not None:
            self.oncall_schedule_id = m.get('oncallScheduleId')
        if m.get('oncallScheduleName') is not None:
            self.oncall_schedule_name = m.get('oncallScheduleName')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.rotations = []
        if m.get('rotations') is not None:
            for k in m.get('rotations'):
                temp_model = GetOncallScheduleResponseBodyRotations()
                self.rotations.append(temp_model.from_map(k))
        if m.get('shiftRobotId') is not None:
            self.shift_robot_id = m.get('shiftRobotId')
        return self


class GetOncallScheduleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOncallScheduleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOncallScheduleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPrometheusInstanceRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        resource_group_id: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        return self


class GetPrometheusInstanceResponseBodyPrometheusInstanceTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class GetPrometheusInstanceResponseBodyPrometheusInstance(TeaModel):
    def __init__(
        self,
        access_type: str = None,
        archive_duration: int = None,
        auth_free_read_policy: str = None,
        auth_free_write_policy: str = None,
        auth_token: str = None,
        create_time: str = None,
        enable_auth_free_read: bool = None,
        enable_auth_free_write: bool = None,
        enable_auth_token: bool = None,
        extra_info: Dict[str, str] = None,
        folder_url: str = None,
        grafana_instance_id: str = None,
        grafana_instance_name: str = None,
        http_api_inter_url: str = None,
        http_api_intra_url: str = None,
        instance_type: str = None,
        payment_type: str = None,
        payment_type_update_time: str = None,
        product: str = None,
        prometheus_instance_id: str = None,
        prometheus_instance_name: str = None,
        push_gateway_inter_url: str = None,
        push_gateway_intra_url: str = None,
        region_id: str = None,
        remote_read_inter_url: str = None,
        remote_read_intra_url: str = None,
        remote_write_inter_url: str = None,
        remote_write_intra_url: str = None,
        resource_group_id: str = None,
        resource_type: str = None,
        status: str = None,
        storage_duration: int = None,
        support_auth_types: List[str] = None,
        tags: List[GetPrometheusInstanceResponseBodyPrometheusInstanceTags] = None,
        user_id: str = None,
        version: str = None,
        workspace: str = None,
    ):
        self.access_type = access_type
        self.archive_duration = archive_duration
        self.auth_free_read_policy = auth_free_read_policy
        self.auth_free_write_policy = auth_free_write_policy
        self.auth_token = auth_token
        self.create_time = create_time
        self.enable_auth_free_read = enable_auth_free_read
        self.enable_auth_free_write = enable_auth_free_write
        self.enable_auth_token = enable_auth_token
        self.extra_info = extra_info
        self.folder_url = folder_url
        self.grafana_instance_id = grafana_instance_id
        self.grafana_instance_name = grafana_instance_name
        self.http_api_inter_url = http_api_inter_url
        self.http_api_intra_url = http_api_intra_url
        self.instance_type = instance_type
        self.payment_type = payment_type
        self.payment_type_update_time = payment_type_update_time
        self.product = product
        self.prometheus_instance_id = prometheus_instance_id
        self.prometheus_instance_name = prometheus_instance_name
        self.push_gateway_inter_url = push_gateway_inter_url
        self.push_gateway_intra_url = push_gateway_intra_url
        self.region_id = region_id
        self.remote_read_inter_url = remote_read_inter_url
        self.remote_read_intra_url = remote_read_intra_url
        self.remote_write_inter_url = remote_write_inter_url
        self.remote_write_intra_url = remote_write_intra_url
        self.resource_group_id = resource_group_id
        self.resource_type = resource_type
        self.status = status
        self.storage_duration = storage_duration
        self.support_auth_types = support_auth_types
        self.tags = tags
        self.user_id = user_id
        self.version = version
        self.workspace = workspace

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_type is not None:
            result['accessType'] = self.access_type
        if self.archive_duration is not None:
            result['archiveDuration'] = self.archive_duration
        if self.auth_free_read_policy is not None:
            result['authFreeReadPolicy'] = self.auth_free_read_policy
        if self.auth_free_write_policy is not None:
            result['authFreeWritePolicy'] = self.auth_free_write_policy
        if self.auth_token is not None:
            result['authToken'] = self.auth_token
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.enable_auth_free_read is not None:
            result['enableAuthFreeRead'] = self.enable_auth_free_read
        if self.enable_auth_free_write is not None:
            result['enableAuthFreeWrite'] = self.enable_auth_free_write
        if self.enable_auth_token is not None:
            result['enableAuthToken'] = self.enable_auth_token
        if self.extra_info is not None:
            result['extraInfo'] = self.extra_info
        if self.folder_url is not None:
            result['folderUrl'] = self.folder_url
        if self.grafana_instance_id is not None:
            result['grafanaInstanceId'] = self.grafana_instance_id
        if self.grafana_instance_name is not None:
            result['grafanaInstanceName'] = self.grafana_instance_name
        if self.http_api_inter_url is not None:
            result['httpApiInterUrl'] = self.http_api_inter_url
        if self.http_api_intra_url is not None:
            result['httpApiIntraUrl'] = self.http_api_intra_url
        if self.instance_type is not None:
            result['instanceType'] = self.instance_type
        if self.payment_type is not None:
            result['paymentType'] = self.payment_type
        if self.payment_type_update_time is not None:
            result['paymentTypeUpdateTime'] = self.payment_type_update_time
        if self.product is not None:
            result['product'] = self.product
        if self.prometheus_instance_id is not None:
            result['prometheusInstanceId'] = self.prometheus_instance_id
        if self.prometheus_instance_name is not None:
            result['prometheusInstanceName'] = self.prometheus_instance_name
        if self.push_gateway_inter_url is not None:
            result['pushGatewayInterUrl'] = self.push_gateway_inter_url
        if self.push_gateway_intra_url is not None:
            result['pushGatewayIntraUrl'] = self.push_gateway_intra_url
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.remote_read_inter_url is not None:
            result['remoteReadInterUrl'] = self.remote_read_inter_url
        if self.remote_read_intra_url is not None:
            result['remoteReadIntraUrl'] = self.remote_read_intra_url
        if self.remote_write_inter_url is not None:
            result['remoteWriteInterUrl'] = self.remote_write_inter_url
        if self.remote_write_intra_url is not None:
            result['remoteWriteIntraUrl'] = self.remote_write_intra_url
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        if self.status is not None:
            result['status'] = self.status
        if self.storage_duration is not None:
            result['storageDuration'] = self.storage_duration
        if self.support_auth_types is not None:
            result['supportAuthTypes'] = self.support_auth_types
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.version is not None:
            result['version'] = self.version
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessType') is not None:
            self.access_type = m.get('accessType')
        if m.get('archiveDuration') is not None:
            self.archive_duration = m.get('archiveDuration')
        if m.get('authFreeReadPolicy') is not None:
            self.auth_free_read_policy = m.get('authFreeReadPolicy')
        if m.get('authFreeWritePolicy') is not None:
            self.auth_free_write_policy = m.get('authFreeWritePolicy')
        if m.get('authToken') is not None:
            self.auth_token = m.get('authToken')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('enableAuthFreeRead') is not None:
            self.enable_auth_free_read = m.get('enableAuthFreeRead')
        if m.get('enableAuthFreeWrite') is not None:
            self.enable_auth_free_write = m.get('enableAuthFreeWrite')
        if m.get('enableAuthToken') is not None:
            self.enable_auth_token = m.get('enableAuthToken')
        if m.get('extraInfo') is not None:
            self.extra_info = m.get('extraInfo')
        if m.get('folderUrl') is not None:
            self.folder_url = m.get('folderUrl')
        if m.get('grafanaInstanceId') is not None:
            self.grafana_instance_id = m.get('grafanaInstanceId')
        if m.get('grafanaInstanceName') is not None:
            self.grafana_instance_name = m.get('grafanaInstanceName')
        if m.get('httpApiInterUrl') is not None:
            self.http_api_inter_url = m.get('httpApiInterUrl')
        if m.get('httpApiIntraUrl') is not None:
            self.http_api_intra_url = m.get('httpApiIntraUrl')
        if m.get('instanceType') is not None:
            self.instance_type = m.get('instanceType')
        if m.get('paymentType') is not None:
            self.payment_type = m.get('paymentType')
        if m.get('paymentTypeUpdateTime') is not None:
            self.payment_type_update_time = m.get('paymentTypeUpdateTime')
        if m.get('product') is not None:
            self.product = m.get('product')
        if m.get('prometheusInstanceId') is not None:
            self.prometheus_instance_id = m.get('prometheusInstanceId')
        if m.get('prometheusInstanceName') is not None:
            self.prometheus_instance_name = m.get('prometheusInstanceName')
        if m.get('pushGatewayInterUrl') is not None:
            self.push_gateway_inter_url = m.get('pushGatewayInterUrl')
        if m.get('pushGatewayIntraUrl') is not None:
            self.push_gateway_intra_url = m.get('pushGatewayIntraUrl')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('remoteReadInterUrl') is not None:
            self.remote_read_inter_url = m.get('remoteReadInterUrl')
        if m.get('remoteReadIntraUrl') is not None:
            self.remote_read_intra_url = m.get('remoteReadIntraUrl')
        if m.get('remoteWriteInterUrl') is not None:
            self.remote_write_inter_url = m.get('remoteWriteInterUrl')
        if m.get('remoteWriteIntraUrl') is not None:
            self.remote_write_intra_url = m.get('remoteWriteIntraUrl')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('storageDuration') is not None:
            self.storage_duration = m.get('storageDuration')
        if m.get('supportAuthTypes') is not None:
            self.support_auth_types = m.get('supportAuthTypes')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = GetPrometheusInstanceResponseBodyPrometheusInstanceTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class GetPrometheusInstanceResponseBody(TeaModel):
    def __init__(
        self,
        prometheus_instance: GetPrometheusInstanceResponseBodyPrometheusInstance = None,
        request_id: str = None,
    ):
        self.prometheus_instance = prometheus_instance
        self.request_id = request_id

    def validate(self):
        if self.prometheus_instance:
            self.prometheus_instance.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_instance is not None:
            result['prometheusInstance'] = self.prometheus_instance.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('prometheusInstance') is not None:
            temp_model = GetPrometheusInstanceResponseBodyPrometheusInstance()
            self.prometheus_instance = temp_model.from_map(m['prometheusInstance'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetPrometheusInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPrometheusInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPrometheusInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPrometheusUserSettingRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
    ):
        self.aliyun_lang = aliyun_lang

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        return self


class GetPrometheusUserSettingResponseBody(TeaModel):
    def __init__(
        self,
        prometheus_user_setting: Dict[str, str] = None,
        request_id: str = None,
    ):
        self.prometheus_user_setting = prometheus_user_setting
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_user_setting is not None:
            result['prometheusUserSetting'] = self.prometheus_user_setting
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('prometheusUserSetting') is not None:
            self.prometheus_user_setting = m.get('prometheusUserSetting')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetPrometheusUserSettingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPrometheusUserSettingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPrometheusUserSettingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPrometheusViewRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        resource_group_id: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        return self


class GetPrometheusViewResponseBodyPrometheusViewPrometheusInstances(TeaModel):
    def __init__(
        self,
        prometheus_instance_id: str = None,
        region_id: str = None,
        user_id: str = None,
    ):
        self.prometheus_instance_id = prometheus_instance_id
        self.region_id = region_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_instance_id is not None:
            result['prometheusInstanceId'] = self.prometheus_instance_id
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('prometheusInstanceId') is not None:
            self.prometheus_instance_id = m.get('prometheusInstanceId')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class GetPrometheusViewResponseBodyPrometheusViewTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class GetPrometheusViewResponseBodyPrometheusView(TeaModel):
    def __init__(
        self,
        auth_free_read_policy: str = None,
        auth_token: str = None,
        create_time: str = None,
        enable_auth_free_read: bool = None,
        enable_auth_token: bool = None,
        folder_url: str = None,
        grafana_instance_id: str = None,
        grafana_instance_name: str = None,
        http_api_inter_url: str = None,
        http_api_intra_url: str = None,
        instance_type: str = None,
        payment_type: str = None,
        product: str = None,
        prometheus_instances: List[GetPrometheusViewResponseBodyPrometheusViewPrometheusInstances] = None,
        prometheus_view_id: str = None,
        prometheus_view_name: str = None,
        region_id: str = None,
        remote_read_inter_url: str = None,
        remote_read_intra_url: str = None,
        resource_group_id: str = None,
        resource_type: str = None,
        status: str = None,
        support_auth_types: List[str] = None,
        tags: List[GetPrometheusViewResponseBodyPrometheusViewTags] = None,
        user_id: str = None,
        version: str = None,
        workspace: str = None,
    ):
        self.auth_free_read_policy = auth_free_read_policy
        self.auth_token = auth_token
        self.create_time = create_time
        self.enable_auth_free_read = enable_auth_free_read
        self.enable_auth_token = enable_auth_token
        self.folder_url = folder_url
        self.grafana_instance_id = grafana_instance_id
        self.grafana_instance_name = grafana_instance_name
        self.http_api_inter_url = http_api_inter_url
        self.http_api_intra_url = http_api_intra_url
        self.instance_type = instance_type
        self.payment_type = payment_type
        self.product = product
        self.prometheus_instances = prometheus_instances
        self.prometheus_view_id = prometheus_view_id
        self.prometheus_view_name = prometheus_view_name
        self.region_id = region_id
        self.remote_read_inter_url = remote_read_inter_url
        self.remote_read_intra_url = remote_read_intra_url
        self.resource_group_id = resource_group_id
        self.resource_type = resource_type
        self.status = status
        self.support_auth_types = support_auth_types
        self.tags = tags
        self.user_id = user_id
        self.version = version
        self.workspace = workspace

    def validate(self):
        if self.prometheus_instances:
            for k in self.prometheus_instances:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_free_read_policy is not None:
            result['authFreeReadPolicy'] = self.auth_free_read_policy
        if self.auth_token is not None:
            result['authToken'] = self.auth_token
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.enable_auth_free_read is not None:
            result['enableAuthFreeRead'] = self.enable_auth_free_read
        if self.enable_auth_token is not None:
            result['enableAuthToken'] = self.enable_auth_token
        if self.folder_url is not None:
            result['folderUrl'] = self.folder_url
        if self.grafana_instance_id is not None:
            result['grafanaInstanceId'] = self.grafana_instance_id
        if self.grafana_instance_name is not None:
            result['grafanaInstanceName'] = self.grafana_instance_name
        if self.http_api_inter_url is not None:
            result['httpApiInterUrl'] = self.http_api_inter_url
        if self.http_api_intra_url is not None:
            result['httpApiIntraUrl'] = self.http_api_intra_url
        if self.instance_type is not None:
            result['instanceType'] = self.instance_type
        if self.payment_type is not None:
            result['paymentType'] = self.payment_type
        if self.product is not None:
            result['product'] = self.product
        result['prometheusInstances'] = []
        if self.prometheus_instances is not None:
            for k in self.prometheus_instances:
                result['prometheusInstances'].append(k.to_map() if k else None)
        if self.prometheus_view_id is not None:
            result['prometheusViewId'] = self.prometheus_view_id
        if self.prometheus_view_name is not None:
            result['prometheusViewName'] = self.prometheus_view_name
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.remote_read_inter_url is not None:
            result['remoteReadInterUrl'] = self.remote_read_inter_url
        if self.remote_read_intra_url is not None:
            result['remoteReadIntraUrl'] = self.remote_read_intra_url
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        if self.status is not None:
            result['status'] = self.status
        if self.support_auth_types is not None:
            result['supportAuthTypes'] = self.support_auth_types
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.version is not None:
            result['version'] = self.version
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authFreeReadPolicy') is not None:
            self.auth_free_read_policy = m.get('authFreeReadPolicy')
        if m.get('authToken') is not None:
            self.auth_token = m.get('authToken')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('enableAuthFreeRead') is not None:
            self.enable_auth_free_read = m.get('enableAuthFreeRead')
        if m.get('enableAuthToken') is not None:
            self.enable_auth_token = m.get('enableAuthToken')
        if m.get('folderUrl') is not None:
            self.folder_url = m.get('folderUrl')
        if m.get('grafanaInstanceId') is not None:
            self.grafana_instance_id = m.get('grafanaInstanceId')
        if m.get('grafanaInstanceName') is not None:
            self.grafana_instance_name = m.get('grafanaInstanceName')
        if m.get('httpApiInterUrl') is not None:
            self.http_api_inter_url = m.get('httpApiInterUrl')
        if m.get('httpApiIntraUrl') is not None:
            self.http_api_intra_url = m.get('httpApiIntraUrl')
        if m.get('instanceType') is not None:
            self.instance_type = m.get('instanceType')
        if m.get('paymentType') is not None:
            self.payment_type = m.get('paymentType')
        if m.get('product') is not None:
            self.product = m.get('product')
        self.prometheus_instances = []
        if m.get('prometheusInstances') is not None:
            for k in m.get('prometheusInstances'):
                temp_model = GetPrometheusViewResponseBodyPrometheusViewPrometheusInstances()
                self.prometheus_instances.append(temp_model.from_map(k))
        if m.get('prometheusViewId') is not None:
            self.prometheus_view_id = m.get('prometheusViewId')
        if m.get('prometheusViewName') is not None:
            self.prometheus_view_name = m.get('prometheusViewName')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('remoteReadInterUrl') is not None:
            self.remote_read_inter_url = m.get('remoteReadInterUrl')
        if m.get('remoteReadIntraUrl') is not None:
            self.remote_read_intra_url = m.get('remoteReadIntraUrl')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('supportAuthTypes') is not None:
            self.support_auth_types = m.get('supportAuthTypes')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = GetPrometheusViewResponseBodyPrometheusViewTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class GetPrometheusViewResponseBody(TeaModel):
    def __init__(
        self,
        prometheus_view: GetPrometheusViewResponseBodyPrometheusView = None,
        request_id: str = None,
    ):
        self.prometheus_view = prometheus_view
        self.request_id = request_id

    def validate(self):
        if self.prometheus_view:
            self.prometheus_view.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_view is not None:
            result['prometheusView'] = self.prometheus_view.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('prometheusView') is not None:
            temp_model = GetPrometheusViewResponseBodyPrometheusView()
            self.prometheus_view = temp_model.from_map(m['prometheusView'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetPrometheusViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPrometheusViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPrometheusViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRumInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        entity_store: str = None,
        prometheus_instance: PrometheusManagedInstance = None,
        request_id: str = None,
        rum_endpoint: RumDnsResponse = None,
        rum_instance_id: str = None,
        rum_instance_name: str = None,
        storages: List[DataStorageItem] = None,
        topo_store: str = None,
        workspace_name: str = None,
        workspace_project: str = None,
        workspace_region_id: str = None,
    ):
        self.code = code
        self.entity_store = entity_store
        self.prometheus_instance = prometheus_instance
        self.request_id = request_id
        self.rum_endpoint = rum_endpoint
        self.rum_instance_id = rum_instance_id
        self.rum_instance_name = rum_instance_name
        self.storages = storages
        self.topo_store = topo_store
        self.workspace_name = workspace_name
        self.workspace_project = workspace_project
        self.workspace_region_id = workspace_region_id

    def validate(self):
        if self.prometheus_instance:
            self.prometheus_instance.validate()
        if self.rum_endpoint:
            self.rum_endpoint.validate()
        if self.storages:
            for k in self.storages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.entity_store is not None:
            result['entityStore'] = self.entity_store
        if self.prometheus_instance is not None:
            result['prometheusInstance'] = self.prometheus_instance.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.rum_endpoint is not None:
            result['rumEndpoint'] = self.rum_endpoint.to_map()
        if self.rum_instance_id is not None:
            result['rumInstanceId'] = self.rum_instance_id
        if self.rum_instance_name is not None:
            result['rumInstanceName'] = self.rum_instance_name
        result['storages'] = []
        if self.storages is not None:
            for k in self.storages:
                result['storages'].append(k.to_map() if k else None)
        if self.topo_store is not None:
            result['topoStore'] = self.topo_store
        if self.workspace_name is not None:
            result['workspaceName'] = self.workspace_name
        if self.workspace_project is not None:
            result['workspaceProject'] = self.workspace_project
        if self.workspace_region_id is not None:
            result['workspaceRegionId'] = self.workspace_region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('entityStore') is not None:
            self.entity_store = m.get('entityStore')
        if m.get('prometheusInstance') is not None:
            temp_model = PrometheusManagedInstance()
            self.prometheus_instance = temp_model.from_map(m['prometheusInstance'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('rumEndpoint') is not None:
            temp_model = RumDnsResponse()
            self.rum_endpoint = temp_model.from_map(m['rumEndpoint'])
        if m.get('rumInstanceId') is not None:
            self.rum_instance_id = m.get('rumInstanceId')
        if m.get('rumInstanceName') is not None:
            self.rum_instance_name = m.get('rumInstanceName')
        self.storages = []
        if m.get('storages') is not None:
            for k in m.get('storages'):
                temp_model = DataStorageItem()
                self.storages.append(temp_model.from_map(k))
        if m.get('topoStore') is not None:
            self.topo_store = m.get('topoStore')
        if m.get('workspaceName') is not None:
            self.workspace_name = m.get('workspaceName')
        if m.get('workspaceProject') is not None:
            self.workspace_project = m.get('workspaceProject')
        if m.get('workspaceRegionId') is not None:
            self.workspace_region_id = m.get('workspaceRegionId')
        return self


class GetRumInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRumInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRumInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSiteMonitorRequest(TeaModel):
    def __init__(
        self,
        site_monitor_id: str = None,
    ):
        # This parameter is required.
        self.site_monitor_id = site_monitor_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.site_monitor_id is not None:
            result['siteMonitorId'] = self.site_monitor_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('siteMonitorId') is not None:
            self.site_monitor_id = m.get('siteMonitorId')
        return self


class GetSiteMonitorResponseBody(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        payment_type: str = None,
        request_id: str = None,
        resource_group_id: str = None,
        site_monitor_id: str = None,
        site_monitor_name: str = None,
    ):
        self.create_time = create_time
        self.payment_type = payment_type
        self.request_id = request_id
        self.resource_group_id = resource_group_id
        self.site_monitor_id = site_monitor_id
        self.site_monitor_name = site_monitor_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.payment_type is not None:
            result['paymentType'] = self.payment_type
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.site_monitor_id is not None:
            result['siteMonitorId'] = self.site_monitor_id
        if self.site_monitor_name is not None:
            result['siteMonitorName'] = self.site_monitor_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('paymentType') is not None:
            self.payment_type = m.get('paymentType')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('siteMonitorId') is not None:
            self.site_monitor_id = m.get('siteMonitorId')
        if m.get('siteMonitorName') is not None:
            self.site_monitor_name = m.get('siteMonitorName')
        return self


class GetSiteMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSiteMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSiteMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSubscriptionRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class GetSubscriptionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        subscription: SubscriptionForView = None,
    ):
        self.request_id = request_id
        self.subscription = subscription

    def validate(self):
        if self.subscription:
            self.subscription.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.subscription is not None:
            result['subscription'] = self.subscription.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('subscription') is not None:
            temp_model = SubscriptionForView()
            self.subscription = temp_model.from_map(m['subscription'])
        return self


class GetSubscriptionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSubscriptionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSubscriptionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTransformerRequest(TeaModel):
    def __init__(
        self,
        workspace: str = None,
    ):
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class GetTransformerResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        transformer: TransformerForView = None,
    ):
        self.request_id = request_id
        self.transformer = transformer

    def validate(self):
        if self.transformer:
            self.transformer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.transformer is not None:
            result['transformer'] = self.transformer.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('transformer') is not None:
            temp_model = TransformerForView()
            self.transformer = temp_model.from_map(m['transformer'])
        return self


class GetTransformerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTransformerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTransformerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUmodelResponseBodyCommonSchemaRef(TeaModel):
    def __init__(
        self,
        group: str = None,
        items: List[str] = None,
        version: str = None,
    ):
        self.group = group
        self.items = items
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group is not None:
            result['group'] = self.group
        if self.items is not None:
            result['items'] = self.items
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('group') is not None:
            self.group = m.get('group')
        if m.get('items') is not None:
            self.items = m.get('items')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class GetUmodelResponseBody(TeaModel):
    def __init__(
        self,
        common_schema_ref: List[GetUmodelResponseBodyCommonSchemaRef] = None,
        description: str = None,
        region_id: str = None,
        request_id: str = None,
        workspace: str = None,
    ):
        self.common_schema_ref = common_schema_ref
        self.description = description
        self.region_id = region_id
        self.request_id = request_id
        self.workspace = workspace

    def validate(self):
        if self.common_schema_ref:
            for k in self.common_schema_ref:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['commonSchemaRef'] = []
        if self.common_schema_ref is not None:
            for k in self.common_schema_ref:
                result['commonSchemaRef'].append(k.to_map() if k else None)
        if self.description is not None:
            result['description'] = self.description
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.common_schema_ref = []
        if m.get('commonSchemaRef') is not None:
            for k in m.get('commonSchemaRef'):
                temp_model = GetUmodelResponseBodyCommonSchemaRef()
                self.common_schema_ref.append(temp_model.from_map(k))
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class GetUmodelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetUmodelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUmodelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUmodelDataRequest(TeaModel):
    def __init__(
        self,
        content: Any = None,
        method: str = None,
    ):
        self.content = content
        # This parameter is required.
        self.method = method

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.method is not None:
            result['method'] = self.method
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('method') is not None:
            self.method = m.get('method')
        return self


class GetUmodelDataResponseBodyErrors(TeaModel):
    def __init__(
        self,
        message: str = None,
        type: str = None,
    ):
        self.message = message
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['message'] = self.message
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetUmodelDataResponseBody(TeaModel):
    def __init__(
        self,
        errors: List[GetUmodelDataResponseBodyErrors] = None,
        links: List[Any] = None,
        nodes: List[Any] = None,
        request_id: str = None,
        total_links_count: int = None,
        total_nodes_count: int = None,
    ):
        self.errors = errors
        self.links = links
        self.nodes = nodes
        self.request_id = request_id
        self.total_links_count = total_links_count
        self.total_nodes_count = total_nodes_count

    def validate(self):
        if self.errors:
            for k in self.errors:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['errors'] = []
        if self.errors is not None:
            for k in self.errors:
                result['errors'].append(k.to_map() if k else None)
        if self.links is not None:
            result['links'] = self.links
        if self.nodes is not None:
            result['nodes'] = self.nodes
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_links_count is not None:
            result['totalLinksCount'] = self.total_links_count
        if self.total_nodes_count is not None:
            result['totalNodesCount'] = self.total_nodes_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.errors = []
        if m.get('errors') is not None:
            for k in m.get('errors'):
                temp_model = GetUmodelDataResponseBodyErrors()
                self.errors.append(temp_model.from_map(k))
        if m.get('links') is not None:
            self.links = m.get('links')
        if m.get('nodes') is not None:
            self.nodes = m.get('nodes')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalLinksCount') is not None:
            self.total_links_count = m.get('totalLinksCount')
        if m.get('totalNodesCount') is not None:
            self.total_nodes_count = m.get('totalNodesCount')
        return self


class GetUmodelDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetUmodelDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUmodelDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWorkspaceResponseBody(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        display_name: str = None,
        last_modify_time: str = None,
        region_id: str = None,
        request_id: str = None,
        sls_project: str = None,
        workspace_name: str = None,
    ):
        # Use the UTC time format: yyyy-MM-ddTHH:mm:ss.SSSZ
        self.create_time = create_time
        # 工作空间描述
        self.description = description
        self.display_name = display_name
        # Use the UTC time format: yyyy-MM-ddTHH:mm:ssZ
        self.last_modify_time = last_modify_time
        # 地域ID
        self.region_id = region_id
        self.request_id = request_id
        # 工作空间绑定的日志服务项目名称
        self.sls_project = sls_project
        # 工作空间名称
        # 
        # This parameter is required.
        self.workspace_name = workspace_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.last_modify_time is not None:
            result['lastModifyTime'] = self.last_modify_time
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.sls_project is not None:
            result['slsProject'] = self.sls_project
        if self.workspace_name is not None:
            result['workspaceName'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('lastModifyTime') is not None:
            self.last_modify_time = m.get('lastModifyTime')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('slsProject') is not None:
            self.sls_project = m.get('slsProject')
        if m.get('workspaceName') is not None:
            self.workspace_name = m.get('workspaceName')
        return self


class GetWorkspaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWorkspaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWorkspaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class HenghaiTestRequest(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        headers: Dict[str, str] = None,
        lang: str = None,
        method: str = None,
        name: str = None,
        source: str = None,
        type: str = None,
        url: str = None,
    ):
        self.content_type = content_type
        self.headers = headers
        self.lang = lang
        self.method = method
        self.name = name
        self.source = source
        # This parameter is required.
        self.type = type
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.headers is not None:
            result['headers'] = self.headers
        if self.lang is not None:
            result['lang'] = self.lang
        if self.method is not None:
            result['method'] = self.method
        if self.name is not None:
            result['name'] = self.name
        if self.source is not None:
            result['source'] = self.source
        if self.type is not None:
            result['type'] = self.type
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('lang') is not None:
            self.lang = m.get('lang')
        if m.get('method') is not None:
            self.method = m.get('method')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class HenghaiTestResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class HenghaiTestResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: HenghaiTestResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = HenghaiTestResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InitEnvironmentRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        create_auth_token: bool = None,
        environment_id: str = None,
        managed_type: str = None,
        region_id: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.create_auth_token = create_auth_token
        # This parameter is required.
        self.environment_id = environment_id
        self.managed_type = managed_type
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.create_auth_token is not None:
            result['CreateAuthToken'] = self.create_auth_token
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.managed_type is not None:
            result['ManagedType'] = self.managed_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('CreateAuthToken') is not None:
            self.create_auth_token = m.get('CreateAuthToken')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('ManagedType') is not None:
            self.managed_type = m.get('ManagedType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class InitEnvironmentResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InitEnvironmentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InitEnvironmentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InitEnvironmentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InstallAddonRequestPolicyFilter(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        filter_conditions: Dict[str, str] = None,
        instance_ids: List[str] = None,
        provider: str = None,
        taint_conditions: Dict[str, str] = None,
    ):
        self.cluster_id = cluster_id
        self.filter_conditions = filter_conditions
        self.instance_ids = instance_ids
        # This parameter is required.
        self.provider = provider
        self.taint_conditions = taint_conditions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['clusterId'] = self.cluster_id
        if self.filter_conditions is not None:
            result['filterConditions'] = self.filter_conditions
        if self.instance_ids is not None:
            result['instanceIds'] = self.instance_ids
        if self.provider is not None:
            result['provider'] = self.provider
        if self.taint_conditions is not None:
            result['taintConditions'] = self.taint_conditions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterId') is not None:
            self.cluster_id = m.get('clusterId')
        if m.get('filterConditions') is not None:
            self.filter_conditions = m.get('filterConditions')
        if m.get('instanceIds') is not None:
            self.instance_ids = m.get('instanceIds')
        if m.get('provider') is not None:
            self.provider = m.get('provider')
        if m.get('taintConditions') is not None:
            self.taint_conditions = m.get('taintConditions')
        return self


class InstallAddonRequestPolicy(TeaModel):
    def __init__(
        self,
        filter: InstallAddonRequestPolicyFilter = None,
        policy_name: str = None,
        policy_type: str = None,
    ):
        self.filter = filter
        self.policy_name = policy_name
        self.policy_type = policy_type

    def validate(self):
        if self.filter:
            self.filter.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter is not None:
            result['filter'] = self.filter.to_map()
        if self.policy_name is not None:
            result['policyName'] = self.policy_name
        if self.policy_type is not None:
            result['policyType'] = self.policy_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('filter') is not None:
            temp_model = InstallAddonRequestPolicyFilter()
            self.filter = temp_model.from_map(m['filter'])
        if m.get('policyName') is not None:
            self.policy_name = m.get('policyName')
        if m.get('policyType') is not None:
            self.policy_type = m.get('policyType')
        return self


class InstallAddonRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        aliyun_lang: str = None,
        dry_run: bool = None,
        policy: InstallAddonRequestPolicy = None,
        policy_id: str = None,
        region_id: str = None,
        release_name: str = None,
        values: str = None,
        version: str = None,
        workspace: str = None,
    ):
        # This parameter is required.
        self.addon_name = addon_name
        self.aliyun_lang = aliyun_lang
        self.dry_run = dry_run
        self.policy = policy
        self.policy_id = policy_id
        # This parameter is required.
        self.region_id = region_id
        self.release_name = release_name
        self.values = values
        # This parameter is required.
        self.version = version
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        if self.policy:
            self.policy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.dry_run is not None:
            result['dryRun'] = self.dry_run
        if self.policy is not None:
            result['policy'] = self.policy.to_map()
        if self.policy_id is not None:
            result['policyId'] = self.policy_id
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.release_name is not None:
            result['releaseName'] = self.release_name
        if self.values is not None:
            result['values'] = self.values
        if self.version is not None:
            result['version'] = self.version
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('dryRun') is not None:
            self.dry_run = m.get('dryRun')
        if m.get('policy') is not None:
            temp_model = InstallAddonRequestPolicy()
            self.policy = temp_model.from_map(m['policy'])
        if m.get('policyId') is not None:
            self.policy_id = m.get('policyId')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('releaseName') is not None:
            self.release_name = m.get('releaseName')
        if m.get('values') is not None:
            self.values = m.get('values')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class InstallAddonResponseBodyReleaseConditions(TeaModel):
    def __init__(
        self,
        first_transition_time: str = None,
        last_transition_time: str = None,
        message: str = None,
        reason: str = None,
        status: str = None,
        type: str = None,
    ):
        self.first_transition_time = first_transition_time
        self.last_transition_time = last_transition_time
        self.message = message
        self.reason = reason
        self.status = status
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_transition_time is not None:
            result['firstTransitionTime'] = self.first_transition_time
        if self.last_transition_time is not None:
            result['lastTransitionTime'] = self.last_transition_time
        if self.message is not None:
            result['message'] = self.message
        if self.reason is not None:
            result['reason'] = self.reason
        if self.status is not None:
            result['status'] = self.status
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('firstTransitionTime') is not None:
            self.first_transition_time = m.get('firstTransitionTime')
        if m.get('lastTransitionTime') is not None:
            self.last_transition_time = m.get('lastTransitionTime')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class InstallAddonResponseBodyRelease(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        alert_rule_count: int = None,
        conditions: List[InstallAddonResponseBodyReleaseConditions] = None,
        config: str = None,
        create_time: str = None,
        dashboard_count: int = None,
        environment_id: str = None,
        exporter_count: int = None,
        have_config: bool = None,
        install_user_id: str = None,
        language: str = None,
        managed: bool = None,
        region_id: str = None,
        release_id: str = None,
        release_name: str = None,
        scene: str = None,
        status: str = None,
        update_time: str = None,
        user_id: str = None,
        version: str = None,
    ):
        self.addon_name = addon_name
        self.alert_rule_count = alert_rule_count
        self.conditions = conditions
        self.config = config
        self.create_time = create_time
        self.dashboard_count = dashboard_count
        self.environment_id = environment_id
        self.exporter_count = exporter_count
        self.have_config = have_config
        self.install_user_id = install_user_id
        self.language = language
        self.managed = managed
        self.region_id = region_id
        self.release_id = release_id
        self.release_name = release_name
        self.scene = scene
        self.status = status
        self.update_time = update_time
        self.user_id = user_id
        self.version = version

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.alert_rule_count is not None:
            result['alertRuleCount'] = self.alert_rule_count
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.config is not None:
            result['config'] = self.config
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.dashboard_count is not None:
            result['dashboardCount'] = self.dashboard_count
        if self.environment_id is not None:
            result['environmentId'] = self.environment_id
        if self.exporter_count is not None:
            result['exporterCount'] = self.exporter_count
        if self.have_config is not None:
            result['haveConfig'] = self.have_config
        if self.install_user_id is not None:
            result['installUserId'] = self.install_user_id
        if self.language is not None:
            result['language'] = self.language
        if self.managed is not None:
            result['managed'] = self.managed
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.release_id is not None:
            result['releaseId'] = self.release_id
        if self.release_name is not None:
            result['releaseName'] = self.release_name
        if self.scene is not None:
            result['scene'] = self.scene
        if self.status is not None:
            result['status'] = self.status
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('alertRuleCount') is not None:
            self.alert_rule_count = m.get('alertRuleCount')
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = InstallAddonResponseBodyReleaseConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('config') is not None:
            self.config = m.get('config')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('dashboardCount') is not None:
            self.dashboard_count = m.get('dashboardCount')
        if m.get('environmentId') is not None:
            self.environment_id = m.get('environmentId')
        if m.get('exporterCount') is not None:
            self.exporter_count = m.get('exporterCount')
        if m.get('haveConfig') is not None:
            self.have_config = m.get('haveConfig')
        if m.get('installUserId') is not None:
            self.install_user_id = m.get('installUserId')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('managed') is not None:
            self.managed = m.get('managed')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('releaseId') is not None:
            self.release_id = m.get('releaseId')
        if m.get('releaseName') is not None:
            self.release_name = m.get('releaseName')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class InstallAddonResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        release: InstallAddonResponseBodyRelease = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.message = message
        self.release = release
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.release:
            self.release.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.message is not None:
            result['message'] = self.message
        if self.release is not None:
            result['release'] = self.release.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('release') is not None:
            temp_model = InstallAddonResponseBodyRelease()
            self.release = temp_model.from_map(m['release'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class InstallAddonResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InstallAddonResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InstallAddonResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InstallEnvironmentFeatureRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        config: str = None,
        feature_version: str = None,
        region: str = None,
        region_id: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.config = config
        # This parameter is required.
        self.feature_version = feature_version
        self.region = region
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.config is not None:
            result['Config'] = self.config
        if self.feature_version is not None:
            result['FeatureVersion'] = self.feature_version
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('FeatureVersion') is not None:
            self.feature_version = m.get('FeatureVersion')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class InstallEnvironmentFeatureResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InstallEnvironmentFeatureResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InstallEnvironmentFeatureResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InstallEnvironmentFeatureResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAddonReleaseExporterPodsRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        region_id: str = None,
        release_name: str = None,
    ):
        # This parameter is required.
        self.environment_id = environment_id
        self.region_id = region_id
        # This parameter is required.
        self.release_name = release_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_name is not None:
            result['ReleaseName'] = self.release_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseName') is not None:
            self.release_name = m.get('ReleaseName')
        return self


class ListAddonReleaseExporterPodsResponseBodyDataMetadata(TeaModel):
    def __init__(
        self,
        annotations: Dict[str, str] = None,
        labels: Dict[str, str] = None,
        name: str = None,
        namespace: str = None,
    ):
        self.annotations = annotations
        self.labels = labels
        self.name = name
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotations is not None:
            result['Annotations'] = self.annotations
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Annotations') is not None:
            self.annotations = m.get('Annotations')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class ListAddonReleaseExporterPodsResponseBodyData(TeaModel):
    def __init__(
        self,
        api_version: str = None,
        kind: str = None,
        metadata: ListAddonReleaseExporterPodsResponseBodyDataMetadata = None,
        spec: Any = None,
        status: Any = None,
    ):
        self.api_version = api_version
        self.kind = kind
        self.metadata = metadata
        self.spec = spec
        self.status = status

    def validate(self):
        if self.metadata:
            self.metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_version is not None:
            result['ApiVersion'] = self.api_version
        if self.kind is not None:
            result['Kind'] = self.kind
        if self.metadata is not None:
            result['Metadata'] = self.metadata.to_map()
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiVersion') is not None:
            self.api_version = m.get('ApiVersion')
        if m.get('Kind') is not None:
            self.kind = m.get('Kind')
        if m.get('Metadata') is not None:
            temp_model = ListAddonReleaseExporterPodsResponseBodyDataMetadata()
            self.metadata = temp_model.from_map(m['Metadata'])
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListAddonReleaseExporterPodsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListAddonReleaseExporterPodsResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAddonReleaseExporterPodsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListAddonReleaseExporterPodsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAddonReleaseExporterPodsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAddonReleaseExporterPodsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAddonReleasesRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        parent_addon_release_id: str = None,
    ):
        self.addon_name = addon_name
        self.parent_addon_release_id = parent_addon_release_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.parent_addon_release_id is not None:
            result['parentAddonReleaseId'] = self.parent_addon_release_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('parentAddonReleaseId') is not None:
            self.parent_addon_release_id = m.get('parentAddonReleaseId')
        return self


class ListAddonReleasesResponseBodyReleasesConditions(TeaModel):
    def __init__(
        self,
        first_transition_time: str = None,
        last_transition_time: str = None,
        message: str = None,
        status: str = None,
        type: str = None,
    ):
        self.first_transition_time = first_transition_time
        self.last_transition_time = last_transition_time
        self.message = message
        self.status = status
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_transition_time is not None:
            result['firstTransitionTime'] = self.first_transition_time
        if self.last_transition_time is not None:
            result['lastTransitionTime'] = self.last_transition_time
        if self.message is not None:
            result['message'] = self.message
        if self.status is not None:
            result['status'] = self.status
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('firstTransitionTime') is not None:
            self.first_transition_time = m.get('firstTransitionTime')
        if m.get('lastTransitionTime') is not None:
            self.last_transition_time = m.get('lastTransitionTime')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListAddonReleasesResponseBodyReleasesSubAddonRelease(TeaModel):
    def __init__(
        self,
        ready: int = None,
        total: int = None,
    ):
        self.ready = ready
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ready is not None:
            result['ready'] = self.ready
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ready') is not None:
            self.ready = m.get('ready')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListAddonReleasesResponseBodyReleases(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        alert_rule_count: int = None,
        conditions: List[ListAddonReleasesResponseBodyReleasesConditions] = None,
        config: str = None,
        create_time: str = None,
        dashboard_count: int = None,
        env_type: str = None,
        environment_id: str = None,
        exporter_count: int = None,
        have_config: bool = None,
        install_user_id: str = None,
        language: str = None,
        managed: bool = None,
        next_version: str = None,
        parent_addon_release_id: str = None,
        policy_id: str = None,
        region_id: str = None,
        release_id: str = None,
        release_name: str = None,
        scene: str = None,
        status: str = None,
        sub_addon_release: ListAddonReleasesResponseBodyReleasesSubAddonRelease = None,
        update_time: str = None,
        user_id: str = None,
        version: str = None,
        workspace: str = None,
    ):
        self.addon_name = addon_name
        self.alert_rule_count = alert_rule_count
        self.conditions = conditions
        self.config = config
        self.create_time = create_time
        self.dashboard_count = dashboard_count
        self.env_type = env_type
        self.environment_id = environment_id
        self.exporter_count = exporter_count
        self.have_config = have_config
        self.install_user_id = install_user_id
        self.language = language
        self.managed = managed
        self.next_version = next_version
        self.parent_addon_release_id = parent_addon_release_id
        self.policy_id = policy_id
        self.region_id = region_id
        # Release ID。
        self.release_id = release_id
        self.release_name = release_name
        self.scene = scene
        self.status = status
        self.sub_addon_release = sub_addon_release
        self.update_time = update_time
        self.user_id = user_id
        self.version = version
        self.workspace = workspace

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()
        if self.sub_addon_release:
            self.sub_addon_release.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.alert_rule_count is not None:
            result['alertRuleCount'] = self.alert_rule_count
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.config is not None:
            result['config'] = self.config
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.dashboard_count is not None:
            result['dashboardCount'] = self.dashboard_count
        if self.env_type is not None:
            result['envType'] = self.env_type
        if self.environment_id is not None:
            result['environmentId'] = self.environment_id
        if self.exporter_count is not None:
            result['exporterCount'] = self.exporter_count
        if self.have_config is not None:
            result['haveConfig'] = self.have_config
        if self.install_user_id is not None:
            result['installUserId'] = self.install_user_id
        if self.language is not None:
            result['language'] = self.language
        if self.managed is not None:
            result['managed'] = self.managed
        if self.next_version is not None:
            result['nextVersion'] = self.next_version
        if self.parent_addon_release_id is not None:
            result['parentAddonReleaseId'] = self.parent_addon_release_id
        if self.policy_id is not None:
            result['policyId'] = self.policy_id
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.release_id is not None:
            result['releaseId'] = self.release_id
        if self.release_name is not None:
            result['releaseName'] = self.release_name
        if self.scene is not None:
            result['scene'] = self.scene
        if self.status is not None:
            result['status'] = self.status
        if self.sub_addon_release is not None:
            result['subAddonRelease'] = self.sub_addon_release.to_map()
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.version is not None:
            result['version'] = self.version
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('alertRuleCount') is not None:
            self.alert_rule_count = m.get('alertRuleCount')
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = ListAddonReleasesResponseBodyReleasesConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('config') is not None:
            self.config = m.get('config')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('dashboardCount') is not None:
            self.dashboard_count = m.get('dashboardCount')
        if m.get('envType') is not None:
            self.env_type = m.get('envType')
        if m.get('environmentId') is not None:
            self.environment_id = m.get('environmentId')
        if m.get('exporterCount') is not None:
            self.exporter_count = m.get('exporterCount')
        if m.get('haveConfig') is not None:
            self.have_config = m.get('haveConfig')
        if m.get('installUserId') is not None:
            self.install_user_id = m.get('installUserId')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('managed') is not None:
            self.managed = m.get('managed')
        if m.get('nextVersion') is not None:
            self.next_version = m.get('nextVersion')
        if m.get('parentAddonReleaseId') is not None:
            self.parent_addon_release_id = m.get('parentAddonReleaseId')
        if m.get('policyId') is not None:
            self.policy_id = m.get('policyId')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('releaseId') is not None:
            self.release_id = m.get('releaseId')
        if m.get('releaseName') is not None:
            self.release_name = m.get('releaseName')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('subAddonRelease') is not None:
            temp_model = ListAddonReleasesResponseBodyReleasesSubAddonRelease()
            self.sub_addon_release = temp_model.from_map(m['subAddonRelease'])
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListAddonReleasesResponseBody(TeaModel):
    def __init__(
        self,
        releases: List[ListAddonReleasesResponseBodyReleases] = None,
        request_id: str = None,
        total: int = None,
    ):
        self.releases = releases
        self.request_id = request_id
        self.total = total

    def validate(self):
        if self.releases:
            for k in self.releases:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['releases'] = []
        if self.releases is not None:
            for k in self.releases:
                result['releases'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.releases = []
        if m.get('releases') is not None:
            for k in m.get('releases'):
                temp_model = ListAddonReleasesResponseBodyReleases()
                self.releases.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListAddonReleasesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAddonReleasesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAddonReleasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAddonsRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        category: str = None,
        regexp: bool = None,
        search: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.category = category
        self.regexp = regexp
        self.search = search

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.category is not None:
            result['category'] = self.category
        if self.regexp is not None:
            result['regexp'] = self.regexp
        if self.search is not None:
            result['search'] = self.search
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('regexp') is not None:
            self.regexp = m.get('regexp')
        if m.get('search') is not None:
            self.search = m.get('search')
        return self


class ListAddonsResponseBodyAddonsDashboards(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        url: str = None,
    ):
        self.description = description
        self.name = name
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class ListAddonsResponseBodyAddonsEnvironmentsDependencies(TeaModel):
    def __init__(
        self,
        cluster_types: List[str] = None,
        features: Dict[str, bool] = None,
        services: List[str] = None,
    ):
        self.cluster_types = cluster_types
        self.features = features
        self.services = services

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_types is not None:
            result['clusterTypes'] = self.cluster_types
        if self.features is not None:
            result['features'] = self.features
        if self.services is not None:
            result['services'] = self.services
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterTypes') is not None:
            self.cluster_types = m.get('clusterTypes')
        if m.get('features') is not None:
            self.features = m.get('features')
        if m.get('services') is not None:
            self.services = m.get('services')
        return self


class ListAddonsResponseBodyAddonsEnvironmentsPoliciesMetricCheckRule(TeaModel):
    def __init__(
        self,
        prom_ql: List[str] = None,
    ):
        self.prom_ql = prom_ql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prom_ql is not None:
            result['promQL'] = self.prom_ql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('promQL') is not None:
            self.prom_ql = m.get('promQL')
        return self


class ListAddonsResponseBodyAddonsEnvironmentsPoliciesProtocols(TeaModel):
    def __init__(
        self,
        description: str = None,
        icon: str = None,
        label: str = None,
        name: str = None,
    ):
        self.description = description
        self.icon = icon
        self.label = label
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.icon is not None:
            result['icon'] = self.icon
        if self.label is not None:
            result['label'] = self.label
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListAddonsResponseBodyAddonsEnvironmentsPolicies(TeaModel):
    def __init__(
        self,
        alert_default_status: str = None,
        default_install: bool = None,
        enable_service_account: bool = None,
        metric_check_rule: ListAddonsResponseBodyAddonsEnvironmentsPoliciesMetricCheckRule = None,
        need_restart_after_integration: bool = None,
        protocols: List[ListAddonsResponseBodyAddonsEnvironmentsPoliciesProtocols] = None,
        target_addon_name: str = None,
    ):
        self.alert_default_status = alert_default_status
        self.default_install = default_install
        self.enable_service_account = enable_service_account
        self.metric_check_rule = metric_check_rule
        self.need_restart_after_integration = need_restart_after_integration
        self.protocols = protocols
        self.target_addon_name = target_addon_name

    def validate(self):
        if self.metric_check_rule:
            self.metric_check_rule.validate()
        if self.protocols:
            for k in self.protocols:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_default_status is not None:
            result['alertDefaultStatus'] = self.alert_default_status
        if self.default_install is not None:
            result['defaultInstall'] = self.default_install
        if self.enable_service_account is not None:
            result['enableServiceAccount'] = self.enable_service_account
        if self.metric_check_rule is not None:
            result['metricCheckRule'] = self.metric_check_rule.to_map()
        if self.need_restart_after_integration is not None:
            result['needRestartAfterIntegration'] = self.need_restart_after_integration
        result['protocols'] = []
        if self.protocols is not None:
            for k in self.protocols:
                result['protocols'].append(k.to_map() if k else None)
        if self.target_addon_name is not None:
            result['targetAddonName'] = self.target_addon_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertDefaultStatus') is not None:
            self.alert_default_status = m.get('alertDefaultStatus')
        if m.get('defaultInstall') is not None:
            self.default_install = m.get('defaultInstall')
        if m.get('enableServiceAccount') is not None:
            self.enable_service_account = m.get('enableServiceAccount')
        if m.get('metricCheckRule') is not None:
            temp_model = ListAddonsResponseBodyAddonsEnvironmentsPoliciesMetricCheckRule()
            self.metric_check_rule = temp_model.from_map(m['metricCheckRule'])
        if m.get('needRestartAfterIntegration') is not None:
            self.need_restart_after_integration = m.get('needRestartAfterIntegration')
        self.protocols = []
        if m.get('protocols') is not None:
            for k in m.get('protocols'):
                temp_model = ListAddonsResponseBodyAddonsEnvironmentsPoliciesProtocols()
                self.protocols.append(temp_model.from_map(k))
        if m.get('targetAddonName') is not None:
            self.target_addon_name = m.get('targetAddonName')
        return self


class ListAddonsResponseBodyAddonsEnvironments(TeaModel):
    def __init__(
        self,
        dependencies: ListAddonsResponseBodyAddonsEnvironmentsDependencies = None,
        description: str = None,
        enable: bool = None,
        label: str = None,
        name: str = None,
        policies: ListAddonsResponseBodyAddonsEnvironmentsPolicies = None,
        policy_type: str = None,
    ):
        self.dependencies = dependencies
        self.description = description
        self.enable = enable
        self.label = label
        self.name = name
        self.policies = policies
        self.policy_type = policy_type

    def validate(self):
        if self.dependencies:
            self.dependencies.validate()
        if self.policies:
            self.policies.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dependencies is not None:
            result['dependencies'] = self.dependencies.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.enable is not None:
            result['enable'] = self.enable
        if self.label is not None:
            result['label'] = self.label
        if self.name is not None:
            result['name'] = self.name
        if self.policies is not None:
            result['policies'] = self.policies.to_map()
        if self.policy_type is not None:
            result['policyType'] = self.policy_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dependencies') is not None:
            temp_model = ListAddonsResponseBodyAddonsEnvironmentsDependencies()
            self.dependencies = temp_model.from_map(m['dependencies'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('policies') is not None:
            temp_model = ListAddonsResponseBodyAddonsEnvironmentsPolicies()
            self.policies = temp_model.from_map(m['policies'])
        if m.get('policyType') is not None:
            self.policy_type = m.get('policyType')
        return self


class ListAddonsResponseBodyAddons(TeaModel):
    def __init__(
        self,
        alias: str = None,
        categories: List[str] = None,
        dashboards: List[ListAddonsResponseBodyAddonsDashboards] = None,
        description: str = None,
        environments: List[ListAddonsResponseBodyAddonsEnvironments] = None,
        icon: str = None,
        keywords: List[str] = None,
        language: str = None,
        latest_release_create_time: str = None,
        name: str = None,
        once: bool = None,
        scene: str = None,
        version: str = None,
        weight: str = None,
    ):
        self.alias = alias
        self.categories = categories
        self.dashboards = dashboards
        self.description = description
        self.environments = environments
        self.icon = icon
        self.keywords = keywords
        self.language = language
        self.latest_release_create_time = latest_release_create_time
        self.name = name
        self.once = once
        self.scene = scene
        self.version = version
        self.weight = weight

    def validate(self):
        if self.dashboards:
            for k in self.dashboards:
                if k:
                    k.validate()
        if self.environments:
            for k in self.environments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['alias'] = self.alias
        if self.categories is not None:
            result['categories'] = self.categories
        result['dashboards'] = []
        if self.dashboards is not None:
            for k in self.dashboards:
                result['dashboards'].append(k.to_map() if k else None)
        if self.description is not None:
            result['description'] = self.description
        result['environments'] = []
        if self.environments is not None:
            for k in self.environments:
                result['environments'].append(k.to_map() if k else None)
        if self.icon is not None:
            result['icon'] = self.icon
        if self.keywords is not None:
            result['keywords'] = self.keywords
        if self.language is not None:
            result['language'] = self.language
        if self.latest_release_create_time is not None:
            result['latestReleaseCreateTime'] = self.latest_release_create_time
        if self.name is not None:
            result['name'] = self.name
        if self.once is not None:
            result['once'] = self.once
        if self.scene is not None:
            result['scene'] = self.scene
        if self.version is not None:
            result['version'] = self.version
        if self.weight is not None:
            result['weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alias') is not None:
            self.alias = m.get('alias')
        if m.get('categories') is not None:
            self.categories = m.get('categories')
        self.dashboards = []
        if m.get('dashboards') is not None:
            for k in m.get('dashboards'):
                temp_model = ListAddonsResponseBodyAddonsDashboards()
                self.dashboards.append(temp_model.from_map(k))
        if m.get('description') is not None:
            self.description = m.get('description')
        self.environments = []
        if m.get('environments') is not None:
            for k in m.get('environments'):
                temp_model = ListAddonsResponseBodyAddonsEnvironments()
                self.environments.append(temp_model.from_map(k))
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('keywords') is not None:
            self.keywords = m.get('keywords')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('latestReleaseCreateTime') is not None:
            self.latest_release_create_time = m.get('latestReleaseCreateTime')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('once') is not None:
            self.once = m.get('once')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        return self


class ListAddonsResponseBody(TeaModel):
    def __init__(
        self,
        addons: List[ListAddonsResponseBodyAddons] = None,
        request_id: str = None,
    ):
        self.addons = addons
        self.request_id = request_id

    def validate(self):
        if self.addons:
            for k in self.addons:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['addons'] = []
        if self.addons is not None:
            for k in self.addons:
                result['addons'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addons = []
        if m.get('addons') is not None:
            for k in m.get('addons'):
                temp_model = ListAddonsResponseBodyAddons()
                self.addons.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListAddonsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAddonsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAddonsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAggTaskGroupsRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListAggTaskGroupsRequest(TeaModel):
    def __init__(
        self,
        filter_agg_task_group_ids: str = None,
        filter_agg_task_group_names: str = None,
        max_results: int = None,
        next_token: str = None,
        query: str = None,
        status: str = None,
        tags: List[ListAggTaskGroupsRequestTags] = None,
        target_prometheus_id: str = None,
    ):
        self.filter_agg_task_group_ids = filter_agg_task_group_ids
        self.filter_agg_task_group_names = filter_agg_task_group_names
        self.max_results = max_results
        self.next_token = next_token
        self.query = query
        self.status = status
        self.tags = tags
        self.target_prometheus_id = target_prometheus_id

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter_agg_task_group_ids is not None:
            result['filterAggTaskGroupIds'] = self.filter_agg_task_group_ids
        if self.filter_agg_task_group_names is not None:
            result['filterAggTaskGroupNames'] = self.filter_agg_task_group_names
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.query is not None:
            result['query'] = self.query
        if self.status is not None:
            result['status'] = self.status
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.target_prometheus_id is not None:
            result['targetPrometheusId'] = self.target_prometheus_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('filterAggTaskGroupIds') is not None:
            self.filter_agg_task_group_ids = m.get('filterAggTaskGroupIds')
        if m.get('filterAggTaskGroupNames') is not None:
            self.filter_agg_task_group_names = m.get('filterAggTaskGroupNames')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('query') is not None:
            self.query = m.get('query')
        if m.get('status') is not None:
            self.status = m.get('status')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = ListAggTaskGroupsRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('targetPrometheusId') is not None:
            self.target_prometheus_id = m.get('targetPrometheusId')
        return self


class ListAggTaskGroupsShrinkRequest(TeaModel):
    def __init__(
        self,
        filter_agg_task_group_ids: str = None,
        filter_agg_task_group_names: str = None,
        max_results: int = None,
        next_token: str = None,
        query: str = None,
        status: str = None,
        tags_shrink: str = None,
        target_prometheus_id: str = None,
    ):
        self.filter_agg_task_group_ids = filter_agg_task_group_ids
        self.filter_agg_task_group_names = filter_agg_task_group_names
        self.max_results = max_results
        self.next_token = next_token
        self.query = query
        self.status = status
        self.tags_shrink = tags_shrink
        self.target_prometheus_id = target_prometheus_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter_agg_task_group_ids is not None:
            result['filterAggTaskGroupIds'] = self.filter_agg_task_group_ids
        if self.filter_agg_task_group_names is not None:
            result['filterAggTaskGroupNames'] = self.filter_agg_task_group_names
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.query is not None:
            result['query'] = self.query
        if self.status is not None:
            result['status'] = self.status
        if self.tags_shrink is not None:
            result['tags'] = self.tags_shrink
        if self.target_prometheus_id is not None:
            result['targetPrometheusId'] = self.target_prometheus_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('filterAggTaskGroupIds') is not None:
            self.filter_agg_task_group_ids = m.get('filterAggTaskGroupIds')
        if m.get('filterAggTaskGroupNames') is not None:
            self.filter_agg_task_group_names = m.get('filterAggTaskGroupNames')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('query') is not None:
            self.query = m.get('query')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('tags') is not None:
            self.tags_shrink = m.get('tags')
        if m.get('targetPrometheusId') is not None:
            self.target_prometheus_id = m.get('targetPrometheusId')
        return self


class ListAggTaskGroupsResponseBodyAggTaskGroupsTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListAggTaskGroupsResponseBodyAggTaskGroups(TeaModel):
    def __init__(
        self,
        agg_task_group_config_hash: str = None,
        agg_task_group_id: str = None,
        agg_task_group_name: str = None,
        cron_expr: str = None,
        delay: int = None,
        description: str = None,
        from_time: int = None,
        interval: str = None,
        max_retries: int = None,
        max_run_time_in_seconds: int = None,
        region_id: str = None,
        schedule_mode: str = None,
        schedule_time_expr: str = None,
        source_prometheus_id: str = None,
        status: str = None,
        tags: List[ListAggTaskGroupsResponseBodyAggTaskGroupsTags] = None,
        target_prometheus_id: str = None,
        to_time: int = None,
        update_time: str = None,
    ):
        self.agg_task_group_config_hash = agg_task_group_config_hash
        self.agg_task_group_id = agg_task_group_id
        self.agg_task_group_name = agg_task_group_name
        self.cron_expr = cron_expr
        self.delay = delay
        self.description = description
        self.from_time = from_time
        self.interval = interval
        self.max_retries = max_retries
        self.max_run_time_in_seconds = max_run_time_in_seconds
        self.region_id = region_id
        self.schedule_mode = schedule_mode
        self.schedule_time_expr = schedule_time_expr
        self.source_prometheus_id = source_prometheus_id
        self.status = status
        self.tags = tags
        self.target_prometheus_id = target_prometheus_id
        self.to_time = to_time
        self.update_time = update_time

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agg_task_group_config_hash is not None:
            result['aggTaskGroupConfigHash'] = self.agg_task_group_config_hash
        if self.agg_task_group_id is not None:
            result['aggTaskGroupId'] = self.agg_task_group_id
        if self.agg_task_group_name is not None:
            result['aggTaskGroupName'] = self.agg_task_group_name
        if self.cron_expr is not None:
            result['cronExpr'] = self.cron_expr
        if self.delay is not None:
            result['delay'] = self.delay
        if self.description is not None:
            result['description'] = self.description
        if self.from_time is not None:
            result['fromTime'] = self.from_time
        if self.interval is not None:
            result['interval'] = self.interval
        if self.max_retries is not None:
            result['maxRetries'] = self.max_retries
        if self.max_run_time_in_seconds is not None:
            result['maxRunTimeInSeconds'] = self.max_run_time_in_seconds
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.schedule_mode is not None:
            result['scheduleMode'] = self.schedule_mode
        if self.schedule_time_expr is not None:
            result['scheduleTimeExpr'] = self.schedule_time_expr
        if self.source_prometheus_id is not None:
            result['sourcePrometheusId'] = self.source_prometheus_id
        if self.status is not None:
            result['status'] = self.status
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.target_prometheus_id is not None:
            result['targetPrometheusId'] = self.target_prometheus_id
        if self.to_time is not None:
            result['toTime'] = self.to_time
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aggTaskGroupConfigHash') is not None:
            self.agg_task_group_config_hash = m.get('aggTaskGroupConfigHash')
        if m.get('aggTaskGroupId') is not None:
            self.agg_task_group_id = m.get('aggTaskGroupId')
        if m.get('aggTaskGroupName') is not None:
            self.agg_task_group_name = m.get('aggTaskGroupName')
        if m.get('cronExpr') is not None:
            self.cron_expr = m.get('cronExpr')
        if m.get('delay') is not None:
            self.delay = m.get('delay')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('fromTime') is not None:
            self.from_time = m.get('fromTime')
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('maxRetries') is not None:
            self.max_retries = m.get('maxRetries')
        if m.get('maxRunTimeInSeconds') is not None:
            self.max_run_time_in_seconds = m.get('maxRunTimeInSeconds')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('scheduleMode') is not None:
            self.schedule_mode = m.get('scheduleMode')
        if m.get('scheduleTimeExpr') is not None:
            self.schedule_time_expr = m.get('scheduleTimeExpr')
        if m.get('sourcePrometheusId') is not None:
            self.source_prometheus_id = m.get('sourcePrometheusId')
        if m.get('status') is not None:
            self.status = m.get('status')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = ListAggTaskGroupsResponseBodyAggTaskGroupsTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('targetPrometheusId') is not None:
            self.target_prometheus_id = m.get('targetPrometheusId')
        if m.get('toTime') is not None:
            self.to_time = m.get('toTime')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class ListAggTaskGroupsResponseBody(TeaModel):
    def __init__(
        self,
        agg_task_groups: List[ListAggTaskGroupsResponseBodyAggTaskGroups] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.agg_task_groups = agg_task_groups
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.agg_task_groups:
            for k in self.agg_task_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['aggTaskGroups'] = []
        if self.agg_task_groups is not None:
            for k in self.agg_task_groups:
                result['aggTaskGroups'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.agg_task_groups = []
        if m.get('aggTaskGroups') is not None:
            for k in m.get('aggTaskGroups'):
                temp_model = ListAggTaskGroupsResponseBodyAggTaskGroups()
                self.agg_task_groups.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListAggTaskGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAggTaskGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAggTaskGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAlertActionsRequest(TeaModel):
    def __init__(
        self,
        alert_action_ids: List[str] = None,
        alert_action_name: str = None,
        max_results: int = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        source: str = None,
        type: str = None,
    ):
        self.alert_action_ids = alert_action_ids
        self.alert_action_name = alert_action_name
        self.max_results = max_results
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.source = source
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_action_ids is not None:
            result['alertActionIds'] = self.alert_action_ids
        if self.alert_action_name is not None:
            result['alertActionName'] = self.alert_action_name
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.source is not None:
            result['source'] = self.source
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertActionIds') is not None:
            self.alert_action_ids = m.get('alertActionIds')
        if m.get('alertActionName') is not None:
            self.alert_action_name = m.get('alertActionName')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListAlertActionsShrinkRequest(TeaModel):
    def __init__(
        self,
        alert_action_ids_shrink: str = None,
        alert_action_name: str = None,
        max_results: int = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        source: str = None,
        type: str = None,
    ):
        self.alert_action_ids_shrink = alert_action_ids_shrink
        self.alert_action_name = alert_action_name
        self.max_results = max_results
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.source = source
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_action_ids_shrink is not None:
            result['alertActionIds'] = self.alert_action_ids_shrink
        if self.alert_action_name is not None:
            result['alertActionName'] = self.alert_action_name
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.source is not None:
            result['source'] = self.source
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertActionIds') is not None:
            self.alert_action_ids_shrink = m.get('alertActionIds')
        if m.get('alertActionName') is not None:
            self.alert_action_name = m.get('alertActionName')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListAlertActionsResponseBodyAlertActionsEssParam(TeaModel):
    def __init__(
        self,
        ess_group_id: str = None,
        ess_rule_id: str = None,
        region_id: str = None,
    ):
        self.ess_group_id = ess_group_id
        self.ess_rule_id = ess_rule_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ess_group_id is not None:
            result['essGroupId'] = self.ess_group_id
        if self.ess_rule_id is not None:
            result['essRuleId'] = self.ess_rule_id
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('essGroupId') is not None:
            self.ess_group_id = m.get('essGroupId')
        if m.get('essRuleId') is not None:
            self.ess_rule_id = m.get('essRuleId')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class ListAlertActionsResponseBodyAlertActionsFcParam(TeaModel):
    def __init__(
        self,
        function: str = None,
        region_id: str = None,
        service: str = None,
    ):
        self.function = function
        self.region_id = region_id
        self.service = service

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function is not None:
            result['function'] = self.function
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.service is not None:
            result['service'] = self.service
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('function') is not None:
            self.function = m.get('function')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('service') is not None:
            self.service = m.get('service')
        return self


class ListAlertActionsResponseBodyAlertActionsMnsParam(TeaModel):
    def __init__(
        self,
        mns_type: str = None,
        name: str = None,
        region_id: str = None,
    ):
        self.mns_type = mns_type
        self.name = name
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mns_type is not None:
            result['mnsType'] = self.mns_type
        if self.name is not None:
            result['name'] = self.name
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('mnsType') is not None:
            self.mns_type = m.get('mnsType')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class ListAlertActionsResponseBodyAlertActionsPagerDutyParam(TeaModel):
    def __init__(
        self,
        key: str = None,
        url: str = None,
    ):
        self.key = key
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class ListAlertActionsResponseBodyAlertActionsSlsParam(TeaModel):
    def __init__(
        self,
        logstore: str = None,
        project: str = None,
        region_id: str = None,
    ):
        self.logstore = logstore
        self.project = project
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logstore is not None:
            result['logstore'] = self.logstore
        if self.project is not None:
            result['project'] = self.project
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('logstore') is not None:
            self.logstore = m.get('logstore')
        if m.get('project') is not None:
            self.project = m.get('project')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class ListAlertActionsResponseBodyAlertActionsWebhookParam(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        headers: Dict[str, str] = None,
        method: str = None,
        url: str = None,
    ):
        self.content_type = content_type
        self.headers = headers
        self.method = method
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.headers is not None:
            result['headers'] = self.headers
        if self.method is not None:
            result['method'] = self.method
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('method') is not None:
            self.method = m.get('method')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class ListAlertActionsResponseBodyAlertActions(TeaModel):
    def __init__(
        self,
        alert_action_id: str = None,
        alert_action_name: str = None,
        ess_param: ListAlertActionsResponseBodyAlertActionsEssParam = None,
        fc_param: ListAlertActionsResponseBodyAlertActionsFcParam = None,
        mns_param: ListAlertActionsResponseBodyAlertActionsMnsParam = None,
        pager_duty_param: ListAlertActionsResponseBodyAlertActionsPagerDutyParam = None,
        sls_param: ListAlertActionsResponseBodyAlertActionsSlsParam = None,
        type: str = None,
        webhook_param: ListAlertActionsResponseBodyAlertActionsWebhookParam = None,
    ):
        self.alert_action_id = alert_action_id
        self.alert_action_name = alert_action_name
        self.ess_param = ess_param
        self.fc_param = fc_param
        self.mns_param = mns_param
        self.pager_duty_param = pager_duty_param
        self.sls_param = sls_param
        self.type = type
        self.webhook_param = webhook_param

    def validate(self):
        if self.ess_param:
            self.ess_param.validate()
        if self.fc_param:
            self.fc_param.validate()
        if self.mns_param:
            self.mns_param.validate()
        if self.pager_duty_param:
            self.pager_duty_param.validate()
        if self.sls_param:
            self.sls_param.validate()
        if self.webhook_param:
            self.webhook_param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_action_id is not None:
            result['alertActionId'] = self.alert_action_id
        if self.alert_action_name is not None:
            result['alertActionName'] = self.alert_action_name
        if self.ess_param is not None:
            result['essParam'] = self.ess_param.to_map()
        if self.fc_param is not None:
            result['fcParam'] = self.fc_param.to_map()
        if self.mns_param is not None:
            result['mnsParam'] = self.mns_param.to_map()
        if self.pager_duty_param is not None:
            result['pagerDutyParam'] = self.pager_duty_param.to_map()
        if self.sls_param is not None:
            result['slsParam'] = self.sls_param.to_map()
        if self.type is not None:
            result['type'] = self.type
        if self.webhook_param is not None:
            result['webhookParam'] = self.webhook_param.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertActionId') is not None:
            self.alert_action_id = m.get('alertActionId')
        if m.get('alertActionName') is not None:
            self.alert_action_name = m.get('alertActionName')
        if m.get('essParam') is not None:
            temp_model = ListAlertActionsResponseBodyAlertActionsEssParam()
            self.ess_param = temp_model.from_map(m['essParam'])
        if m.get('fcParam') is not None:
            temp_model = ListAlertActionsResponseBodyAlertActionsFcParam()
            self.fc_param = temp_model.from_map(m['fcParam'])
        if m.get('mnsParam') is not None:
            temp_model = ListAlertActionsResponseBodyAlertActionsMnsParam()
            self.mns_param = temp_model.from_map(m['mnsParam'])
        if m.get('pagerDutyParam') is not None:
            temp_model = ListAlertActionsResponseBodyAlertActionsPagerDutyParam()
            self.pager_duty_param = temp_model.from_map(m['pagerDutyParam'])
        if m.get('slsParam') is not None:
            temp_model = ListAlertActionsResponseBodyAlertActionsSlsParam()
            self.sls_param = temp_model.from_map(m['slsParam'])
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('webhookParam') is not None:
            temp_model = ListAlertActionsResponseBodyAlertActionsWebhookParam()
            self.webhook_param = temp_model.from_map(m['webhookParam'])
        return self


class ListAlertActionsResponseBody(TeaModel):
    def __init__(
        self,
        alert_actions: List[ListAlertActionsResponseBodyAlertActions] = None,
        max_results: int = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total: int = None,
    ):
        self.alert_actions = alert_actions
        self.max_results = max_results
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total = total

    def validate(self):
        if self.alert_actions:
            for k in self.alert_actions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['alertActions'] = []
        if self.alert_actions is not None:
            for k in self.alert_actions:
                result['alertActions'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_actions = []
        if m.get('alertActions') is not None:
            for k in m.get('alertActions'):
                temp_model = ListAlertActionsResponseBodyAlertActions()
                self.alert_actions.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListAlertActionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAlertActionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAlertActionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAlertEventIntegrationPoliciesRequest(TeaModel):
    def __init__(
        self,
        alert_event_integration_policy_id: str = None,
        alert_event_integration_policy_name: str = None,
        enable: bool = None,
        max_results: int = None,
        next_token: str = None,
        workspace: str = None,
    ):
        self.alert_event_integration_policy_id = alert_event_integration_policy_id
        self.alert_event_integration_policy_name = alert_event_integration_policy_name
        self.enable = enable
        self.max_results = max_results
        self.next_token = next_token
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_event_integration_policy_id is not None:
            result['alertEventIntegrationPolicyId'] = self.alert_event_integration_policy_id
        if self.alert_event_integration_policy_name is not None:
            result['alertEventIntegrationPolicyName'] = self.alert_event_integration_policy_name
        if self.enable is not None:
            result['enable'] = self.enable
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertEventIntegrationPolicyId') is not None:
            self.alert_event_integration_policy_id = m.get('alertEventIntegrationPolicyId')
        if m.get('alertEventIntegrationPolicyName') is not None:
            self.alert_event_integration_policy_name = m.get('alertEventIntegrationPolicyName')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListAlertEventIntegrationPoliciesResponseBody(TeaModel):
    def __init__(
        self,
        alert_event_integration_policy_list: List[AlertEventIntegrationPolicyForView] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.alert_event_integration_policy_list = alert_event_integration_policy_list
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id

    def validate(self):
        if self.alert_event_integration_policy_list:
            for k in self.alert_event_integration_policy_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['alertEventIntegrationPolicyList'] = []
        if self.alert_event_integration_policy_list is not None:
            for k in self.alert_event_integration_policy_list:
                result['alertEventIntegrationPolicyList'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_event_integration_policy_list = []
        if m.get('alertEventIntegrationPolicyList') is not None:
            for k in m.get('alertEventIntegrationPolicyList'):
                temp_model = AlertEventIntegrationPolicyForView()
                self.alert_event_integration_policy_list.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListAlertEventIntegrationPoliciesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAlertEventIntegrationPoliciesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAlertEventIntegrationPoliciesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAlertHistoriesRequest(TeaModel):
    def __init__(
        self,
        alert_history_id: str = None,
        alert_rule_id: str = None,
        biz_source: str = None,
        display_name_key_word: str = None,
        instance_key: str = None,
        label_filter: AlertRuleLabelFilter = None,
        latest_level: str = None,
        max_level: str = None,
        max_results: int = None,
        next_token: str = None,
        notification_filter: AlertRuleNotificationFilter = None,
        page_number: int = None,
        page_size: int = None,
        start_time_from: int = None,
        start_time_to: int = None,
        status: str = None,
        workspace: str = None,
    ):
        self.alert_history_id = alert_history_id
        self.alert_rule_id = alert_rule_id
        self.biz_source = biz_source
        self.display_name_key_word = display_name_key_word
        self.instance_key = instance_key
        self.label_filter = label_filter
        self.latest_level = latest_level
        self.max_level = max_level
        self.max_results = max_results
        self.next_token = next_token
        self.notification_filter = notification_filter
        self.page_number = page_number
        self.page_size = page_size
        self.start_time_from = start_time_from
        self.start_time_to = start_time_to
        self.status = status
        self.workspace = workspace

    def validate(self):
        if self.label_filter:
            self.label_filter.validate()
        if self.notification_filter:
            self.notification_filter.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_history_id is not None:
            result['alertHistoryId'] = self.alert_history_id
        if self.alert_rule_id is not None:
            result['alertRuleId'] = self.alert_rule_id
        if self.biz_source is not None:
            result['bizSource'] = self.biz_source
        if self.display_name_key_word is not None:
            result['displayNameKeyWord'] = self.display_name_key_word
        if self.instance_key is not None:
            result['instanceKey'] = self.instance_key
        if self.label_filter is not None:
            result['labelFilter'] = self.label_filter.to_map()
        if self.latest_level is not None:
            result['latestLevel'] = self.latest_level
        if self.max_level is not None:
            result['maxLevel'] = self.max_level
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.notification_filter is not None:
            result['notificationFilter'] = self.notification_filter.to_map()
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.start_time_from is not None:
            result['startTimeFrom'] = self.start_time_from
        if self.start_time_to is not None:
            result['startTimeTo'] = self.start_time_to
        if self.status is not None:
            result['status'] = self.status
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertHistoryId') is not None:
            self.alert_history_id = m.get('alertHistoryId')
        if m.get('alertRuleId') is not None:
            self.alert_rule_id = m.get('alertRuleId')
        if m.get('bizSource') is not None:
            self.biz_source = m.get('bizSource')
        if m.get('displayNameKeyWord') is not None:
            self.display_name_key_word = m.get('displayNameKeyWord')
        if m.get('instanceKey') is not None:
            self.instance_key = m.get('instanceKey')
        if m.get('labelFilter') is not None:
            temp_model = AlertRuleLabelFilter()
            self.label_filter = temp_model.from_map(m['labelFilter'])
        if m.get('latestLevel') is not None:
            self.latest_level = m.get('latestLevel')
        if m.get('maxLevel') is not None:
            self.max_level = m.get('maxLevel')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('notificationFilter') is not None:
            temp_model = AlertRuleNotificationFilter()
            self.notification_filter = temp_model.from_map(m['notificationFilter'])
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('startTimeFrom') is not None:
            self.start_time_from = m.get('startTimeFrom')
        if m.get('startTimeTo') is not None:
            self.start_time_to = m.get('startTimeTo')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListAlertHistoriesShrinkRequest(TeaModel):
    def __init__(
        self,
        alert_history_id: str = None,
        alert_rule_id: str = None,
        biz_source: str = None,
        display_name_key_word: str = None,
        instance_key: str = None,
        label_filter_shrink: str = None,
        latest_level: str = None,
        max_level: str = None,
        max_results: int = None,
        next_token: str = None,
        notification_filter_shrink: str = None,
        page_number: int = None,
        page_size: int = None,
        start_time_from: int = None,
        start_time_to: int = None,
        status: str = None,
        workspace: str = None,
    ):
        self.alert_history_id = alert_history_id
        self.alert_rule_id = alert_rule_id
        self.biz_source = biz_source
        self.display_name_key_word = display_name_key_word
        self.instance_key = instance_key
        self.label_filter_shrink = label_filter_shrink
        self.latest_level = latest_level
        self.max_level = max_level
        self.max_results = max_results
        self.next_token = next_token
        self.notification_filter_shrink = notification_filter_shrink
        self.page_number = page_number
        self.page_size = page_size
        self.start_time_from = start_time_from
        self.start_time_to = start_time_to
        self.status = status
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_history_id is not None:
            result['alertHistoryId'] = self.alert_history_id
        if self.alert_rule_id is not None:
            result['alertRuleId'] = self.alert_rule_id
        if self.biz_source is not None:
            result['bizSource'] = self.biz_source
        if self.display_name_key_word is not None:
            result['displayNameKeyWord'] = self.display_name_key_word
        if self.instance_key is not None:
            result['instanceKey'] = self.instance_key
        if self.label_filter_shrink is not None:
            result['labelFilter'] = self.label_filter_shrink
        if self.latest_level is not None:
            result['latestLevel'] = self.latest_level
        if self.max_level is not None:
            result['maxLevel'] = self.max_level
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.notification_filter_shrink is not None:
            result['notificationFilter'] = self.notification_filter_shrink
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.start_time_from is not None:
            result['startTimeFrom'] = self.start_time_from
        if self.start_time_to is not None:
            result['startTimeTo'] = self.start_time_to
        if self.status is not None:
            result['status'] = self.status
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertHistoryId') is not None:
            self.alert_history_id = m.get('alertHistoryId')
        if m.get('alertRuleId') is not None:
            self.alert_rule_id = m.get('alertRuleId')
        if m.get('bizSource') is not None:
            self.biz_source = m.get('bizSource')
        if m.get('displayNameKeyWord') is not None:
            self.display_name_key_word = m.get('displayNameKeyWord')
        if m.get('instanceKey') is not None:
            self.instance_key = m.get('instanceKey')
        if m.get('labelFilter') is not None:
            self.label_filter_shrink = m.get('labelFilter')
        if m.get('latestLevel') is not None:
            self.latest_level = m.get('latestLevel')
        if m.get('maxLevel') is not None:
            self.max_level = m.get('maxLevel')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('notificationFilter') is not None:
            self.notification_filter_shrink = m.get('notificationFilter')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('startTimeFrom') is not None:
            self.start_time_from = m.get('startTimeFrom')
        if m.get('startTimeTo') is not None:
            self.start_time_to = m.get('startTimeTo')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListAlertHistoriesResponseBodyData(TeaModel):
    def __init__(
        self,
        alert_history_id: str = None,
        alert_rule_id: str = None,
        annotations: Dict[str, str] = None,
        biz_source: str = None,
        count: int = None,
        end_time: int = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        instance_detail: Dict[str, str] = None,
        instance_key: str = None,
        labels: Dict[str, str] = None,
        latest_level: str = None,
        max_level: str = None,
        region_id: str = None,
        rule_display_name: str = None,
        send: AlertRuleSend = None,
        start_time: int = None,
        status: str = None,
        workspace: str = None,
    ):
        self.alert_history_id = alert_history_id
        self.alert_rule_id = alert_rule_id
        self.annotations = annotations
        self.biz_source = biz_source
        self.count = count
        self.end_time = end_time
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.instance_detail = instance_detail
        self.instance_key = instance_key
        self.labels = labels
        self.latest_level = latest_level
        self.max_level = max_level
        self.region_id = region_id
        self.rule_display_name = rule_display_name
        self.send = send
        self.start_time = start_time
        self.status = status
        self.workspace = workspace

    def validate(self):
        if self.send:
            self.send.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_history_id is not None:
            result['alertHistoryId'] = self.alert_history_id
        if self.alert_rule_id is not None:
            result['alertRuleId'] = self.alert_rule_id
        if self.annotations is not None:
            result['annotations'] = self.annotations
        if self.biz_source is not None:
            result['bizSource'] = self.biz_source
        if self.count is not None:
            result['count'] = self.count
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.instance_detail is not None:
            result['instanceDetail'] = self.instance_detail
        if self.instance_key is not None:
            result['instanceKey'] = self.instance_key
        if self.labels is not None:
            result['labels'] = self.labels
        if self.latest_level is not None:
            result['latestLevel'] = self.latest_level
        if self.max_level is not None:
            result['maxLevel'] = self.max_level
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.rule_display_name is not None:
            result['ruleDisplayName'] = self.rule_display_name
        if self.send is not None:
            result['send'] = self.send.to_map()
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.status is not None:
            result['status'] = self.status
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertHistoryId') is not None:
            self.alert_history_id = m.get('alertHistoryId')
        if m.get('alertRuleId') is not None:
            self.alert_rule_id = m.get('alertRuleId')
        if m.get('annotations') is not None:
            self.annotations = m.get('annotations')
        if m.get('bizSource') is not None:
            self.biz_source = m.get('bizSource')
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('instanceDetail') is not None:
            self.instance_detail = m.get('instanceDetail')
        if m.get('instanceKey') is not None:
            self.instance_key = m.get('instanceKey')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('latestLevel') is not None:
            self.latest_level = m.get('latestLevel')
        if m.get('maxLevel') is not None:
            self.max_level = m.get('maxLevel')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('ruleDisplayName') is not None:
            self.rule_display_name = m.get('ruleDisplayName')
        if m.get('send') is not None:
            temp_model = AlertRuleSend()
            self.send = temp_model.from_map(m['send'])
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListAlertHistoriesResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListAlertHistoriesResponseBodyData] = None,
        max_results: int = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.data = data
        self.max_results = max_results
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ListAlertHistoriesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListAlertHistoriesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAlertHistoriesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAlertHistoriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAlertMetricGroupsRequest(TeaModel):
    def __init__(
        self,
        alert_metric_group_id: str = None,
        datasource_type: str = None,
        include_details: bool = None,
        max_results: int = None,
        next_token: str = None,
    ):
        self.alert_metric_group_id = alert_metric_group_id
        self.datasource_type = datasource_type
        self.include_details = include_details
        self.max_results = max_results
        self.next_token = next_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_metric_group_id is not None:
            result['alertMetricGroupId'] = self.alert_metric_group_id
        if self.datasource_type is not None:
            result['datasourceType'] = self.datasource_type
        if self.include_details is not None:
            result['includeDetails'] = self.include_details
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertMetricGroupId') is not None:
            self.alert_metric_group_id = m.get('alertMetricGroupId')
        if m.get('datasourceType') is not None:
            self.datasource_type = m.get('datasourceType')
        if m.get('includeDetails') is not None:
            self.include_details = m.get('includeDetails')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        return self


class ListAlertMetricGroupsResponseBodyData(TeaModel):
    def __init__(
        self,
        alert_metric_group_id: str = None,
        datasource_types: str = None,
        description_cn: str = None,
        description_en: str = None,
        display_name_cn: str = None,
        display_name_en: str = None,
        filters: List[AlertRuleAlertMetricFilterDef] = None,
        order_index: int = None,
        params: List[AlertRuleAlertMetricParamDef] = None,
    ):
        self.alert_metric_group_id = alert_metric_group_id
        self.datasource_types = datasource_types
        self.description_cn = description_cn
        self.description_en = description_en
        self.display_name_cn = display_name_cn
        self.display_name_en = display_name_en
        self.filters = filters
        self.order_index = order_index
        self.params = params

    def validate(self):
        if self.filters:
            for k in self.filters:
                if k:
                    k.validate()
        if self.params:
            for k in self.params:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_metric_group_id is not None:
            result['alertMetricGroupId'] = self.alert_metric_group_id
        if self.datasource_types is not None:
            result['datasourceTypes'] = self.datasource_types
        if self.description_cn is not None:
            result['descriptionCn'] = self.description_cn
        if self.description_en is not None:
            result['descriptionEn'] = self.description_en
        if self.display_name_cn is not None:
            result['displayNameCn'] = self.display_name_cn
        if self.display_name_en is not None:
            result['displayNameEn'] = self.display_name_en
        result['filters'] = []
        if self.filters is not None:
            for k in self.filters:
                result['filters'].append(k.to_map() if k else None)
        if self.order_index is not None:
            result['orderIndex'] = self.order_index
        result['params'] = []
        if self.params is not None:
            for k in self.params:
                result['params'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertMetricGroupId') is not None:
            self.alert_metric_group_id = m.get('alertMetricGroupId')
        if m.get('datasourceTypes') is not None:
            self.datasource_types = m.get('datasourceTypes')
        if m.get('descriptionCn') is not None:
            self.description_cn = m.get('descriptionCn')
        if m.get('descriptionEn') is not None:
            self.description_en = m.get('descriptionEn')
        if m.get('displayNameCn') is not None:
            self.display_name_cn = m.get('displayNameCn')
        if m.get('displayNameEn') is not None:
            self.display_name_en = m.get('displayNameEn')
        self.filters = []
        if m.get('filters') is not None:
            for k in m.get('filters'):
                temp_model = AlertRuleAlertMetricFilterDef()
                self.filters.append(temp_model.from_map(k))
        if m.get('orderIndex') is not None:
            self.order_index = m.get('orderIndex')
        self.params = []
        if m.get('params') is not None:
            for k in m.get('params'):
                temp_model = AlertRuleAlertMetricParamDef()
                self.params.append(temp_model.from_map(k))
        return self


class ListAlertMetricGroupsResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListAlertMetricGroupsResponseBodyData] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.data = data
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ListAlertMetricGroupsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListAlertMetricGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAlertMetricGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAlertMetricGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAlertMetricsRequest(TeaModel):
    def __init__(
        self,
        alert_metric_id: str = None,
        group: str = None,
        include_details: bool = None,
        max_results: int = None,
        next_token: str = None,
    ):
        self.alert_metric_id = alert_metric_id
        self.group = group
        self.include_details = include_details
        self.max_results = max_results
        self.next_token = next_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_metric_id is not None:
            result['alertMetricId'] = self.alert_metric_id
        if self.group is not None:
            result['group'] = self.group
        if self.include_details is not None:
            result['includeDetails'] = self.include_details
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertMetricId') is not None:
            self.alert_metric_id = m.get('alertMetricId')
        if m.get('group') is not None:
            self.group = m.get('group')
        if m.get('includeDetails') is not None:
            self.include_details = m.get('includeDetails')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        return self


class ListAlertMetricsResponseBodyDataExprTemplate(TeaModel):
    def __init__(
        self,
        tpl: str = None,
        type: str = None,
    ):
        self.tpl = tpl
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tpl is not None:
            result['tpl'] = self.tpl
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tpl') is not None:
            self.tpl = m.get('tpl')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListAlertMetricsResponseBodyData(TeaModel):
    def __init__(
        self,
        alert_level: str = None,
        alert_message_cn: str = None,
        alert_message_en: str = None,
        alert_metric_id: str = None,
        display_name_cn: str = None,
        display_name_en: str = None,
        display_statement_cn: str = None,
        display_statement_en: str = None,
        duration: int = None,
        expr_template: ListAlertMetricsResponseBodyDataExprTemplate = None,
        ext_info: Dict[str, str] = None,
        filters: List[AlertRuleAlertMetricFilterDef] = None,
        group: str = None,
        params: List[AlertRuleAlertMetricParamDef] = None,
        unit_cn: str = None,
        unit_en: str = None,
    ):
        self.alert_level = alert_level
        self.alert_message_cn = alert_message_cn
        self.alert_message_en = alert_message_en
        self.alert_metric_id = alert_metric_id
        self.display_name_cn = display_name_cn
        self.display_name_en = display_name_en
        self.display_statement_cn = display_statement_cn
        self.display_statement_en = display_statement_en
        self.duration = duration
        self.expr_template = expr_template
        self.ext_info = ext_info
        self.filters = filters
        self.group = group
        self.params = params
        self.unit_cn = unit_cn
        self.unit_en = unit_en

    def validate(self):
        if self.expr_template:
            self.expr_template.validate()
        if self.filters:
            for k in self.filters:
                if k:
                    k.validate()
        if self.params:
            for k in self.params:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_level is not None:
            result['alertLevel'] = self.alert_level
        if self.alert_message_cn is not None:
            result['alertMessageCn'] = self.alert_message_cn
        if self.alert_message_en is not None:
            result['alertMessageEn'] = self.alert_message_en
        if self.alert_metric_id is not None:
            result['alertMetricId'] = self.alert_metric_id
        if self.display_name_cn is not None:
            result['displayNameCn'] = self.display_name_cn
        if self.display_name_en is not None:
            result['displayNameEn'] = self.display_name_en
        if self.display_statement_cn is not None:
            result['displayStatementCn'] = self.display_statement_cn
        if self.display_statement_en is not None:
            result['displayStatementEn'] = self.display_statement_en
        if self.duration is not None:
            result['duration'] = self.duration
        if self.expr_template is not None:
            result['exprTemplate'] = self.expr_template.to_map()
        if self.ext_info is not None:
            result['extInfo'] = self.ext_info
        result['filters'] = []
        if self.filters is not None:
            for k in self.filters:
                result['filters'].append(k.to_map() if k else None)
        if self.group is not None:
            result['group'] = self.group
        result['params'] = []
        if self.params is not None:
            for k in self.params:
                result['params'].append(k.to_map() if k else None)
        if self.unit_cn is not None:
            result['unitCn'] = self.unit_cn
        if self.unit_en is not None:
            result['unitEn'] = self.unit_en
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertLevel') is not None:
            self.alert_level = m.get('alertLevel')
        if m.get('alertMessageCn') is not None:
            self.alert_message_cn = m.get('alertMessageCn')
        if m.get('alertMessageEn') is not None:
            self.alert_message_en = m.get('alertMessageEn')
        if m.get('alertMetricId') is not None:
            self.alert_metric_id = m.get('alertMetricId')
        if m.get('displayNameCn') is not None:
            self.display_name_cn = m.get('displayNameCn')
        if m.get('displayNameEn') is not None:
            self.display_name_en = m.get('displayNameEn')
        if m.get('displayStatementCn') is not None:
            self.display_statement_cn = m.get('displayStatementCn')
        if m.get('displayStatementEn') is not None:
            self.display_statement_en = m.get('displayStatementEn')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('exprTemplate') is not None:
            temp_model = ListAlertMetricsResponseBodyDataExprTemplate()
            self.expr_template = temp_model.from_map(m['exprTemplate'])
        if m.get('extInfo') is not None:
            self.ext_info = m.get('extInfo')
        self.filters = []
        if m.get('filters') is not None:
            for k in m.get('filters'):
                temp_model = AlertRuleAlertMetricFilterDef()
                self.filters.append(temp_model.from_map(k))
        if m.get('group') is not None:
            self.group = m.get('group')
        self.params = []
        if m.get('params') is not None:
            for k in m.get('params'):
                temp_model = AlertRuleAlertMetricParamDef()
                self.params.append(temp_model.from_map(k))
        if m.get('unitCn') is not None:
            self.unit_cn = m.get('unitCn')
        if m.get('unitEn') is not None:
            self.unit_en = m.get('unitEn')
        return self


class ListAlertMetricsResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListAlertMetricsResponseBodyData] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.data = data
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ListAlertMetricsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListAlertMetricsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAlertMetricsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAlertMetricsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAlertNotifyTemplatesRequest(TeaModel):
    def __init__(
        self,
        alert_notify_template_ids: List[str] = None,
        alert_notify_template_name: str = None,
        max_results: int = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        program_lang: str = None,
        type: str = None,
    ):
        self.alert_notify_template_ids = alert_notify_template_ids
        self.alert_notify_template_name = alert_notify_template_name
        self.max_results = max_results
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.program_lang = program_lang
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_notify_template_ids is not None:
            result['alertNotifyTemplateIds'] = self.alert_notify_template_ids
        if self.alert_notify_template_name is not None:
            result['alertNotifyTemplateName'] = self.alert_notify_template_name
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.program_lang is not None:
            result['programLang'] = self.program_lang
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertNotifyTemplateIds') is not None:
            self.alert_notify_template_ids = m.get('alertNotifyTemplateIds')
        if m.get('alertNotifyTemplateName') is not None:
            self.alert_notify_template_name = m.get('alertNotifyTemplateName')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('programLang') is not None:
            self.program_lang = m.get('programLang')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListAlertNotifyTemplatesShrinkRequest(TeaModel):
    def __init__(
        self,
        alert_notify_template_ids_shrink: str = None,
        alert_notify_template_name: str = None,
        max_results: int = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        program_lang: str = None,
        type: str = None,
    ):
        self.alert_notify_template_ids_shrink = alert_notify_template_ids_shrink
        self.alert_notify_template_name = alert_notify_template_name
        self.max_results = max_results
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.program_lang = program_lang
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_notify_template_ids_shrink is not None:
            result['alertNotifyTemplateIds'] = self.alert_notify_template_ids_shrink
        if self.alert_notify_template_name is not None:
            result['alertNotifyTemplateName'] = self.alert_notify_template_name
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.program_lang is not None:
            result['programLang'] = self.program_lang
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertNotifyTemplateIds') is not None:
            self.alert_notify_template_ids_shrink = m.get('alertNotifyTemplateIds')
        if m.get('alertNotifyTemplateName') is not None:
            self.alert_notify_template_name = m.get('alertNotifyTemplateName')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('programLang') is not None:
            self.program_lang = m.get('programLang')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListAlertNotifyTemplatesResponseBodyAlertNotifyTemplates(TeaModel):
    def __init__(
        self,
        alert_notify_template_id: str = None,
        alert_notify_template_name: str = None,
        program_lang: str = None,
        templates: Dict[str, dict] = None,
        type: str = None,
    ):
        self.alert_notify_template_id = alert_notify_template_id
        self.alert_notify_template_name = alert_notify_template_name
        self.program_lang = program_lang
        self.templates = templates
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_notify_template_id is not None:
            result['alertNotifyTemplateId'] = self.alert_notify_template_id
        if self.alert_notify_template_name is not None:
            result['alertNotifyTemplateName'] = self.alert_notify_template_name
        if self.program_lang is not None:
            result['programLang'] = self.program_lang
        if self.templates is not None:
            result['templates'] = self.templates
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertNotifyTemplateId') is not None:
            self.alert_notify_template_id = m.get('alertNotifyTemplateId')
        if m.get('alertNotifyTemplateName') is not None:
            self.alert_notify_template_name = m.get('alertNotifyTemplateName')
        if m.get('programLang') is not None:
            self.program_lang = m.get('programLang')
        if m.get('templates') is not None:
            self.templates = m.get('templates')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListAlertNotifyTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        alert_notify_templates: List[ListAlertNotifyTemplatesResponseBodyAlertNotifyTemplates] = None,
        max_results: int = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total: int = None,
    ):
        self.alert_notify_templates = alert_notify_templates
        self.max_results = max_results
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total = total

    def validate(self):
        if self.alert_notify_templates:
            for k in self.alert_notify_templates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['alertNotifyTemplates'] = []
        if self.alert_notify_templates is not None:
            for k in self.alert_notify_templates:
                result['alertNotifyTemplates'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_notify_templates = []
        if m.get('alertNotifyTemplates') is not None:
            for k in m.get('alertNotifyTemplates'):
                temp_model = ListAlertNotifyTemplatesResponseBodyAlertNotifyTemplates()
                self.alert_notify_templates.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListAlertNotifyTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAlertNotifyTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAlertNotifyTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAlertRobotsRequest(TeaModel):
    def __init__(
        self,
        is_custom: str = None,
        max_results: int = None,
        name: str = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        robot_ids: List[str] = None,
        source: str = None,
        types: List[str] = None,
    ):
        self.is_custom = is_custom
        self.max_results = max_results
        self.name = name
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.robot_ids = robot_ids
        self.source = source
        self.types = types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_custom is not None:
            result['isCustom'] = self.is_custom
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.name is not None:
            result['name'] = self.name
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.robot_ids is not None:
            result['robotIds'] = self.robot_ids
        if self.source is not None:
            result['source'] = self.source
        if self.types is not None:
            result['types'] = self.types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isCustom') is not None:
            self.is_custom = m.get('isCustom')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('robotIds') is not None:
            self.robot_ids = m.get('robotIds')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('types') is not None:
            self.types = m.get('types')
        return self


class ListAlertRobotsShrinkRequest(TeaModel):
    def __init__(
        self,
        is_custom: str = None,
        max_results: int = None,
        name: str = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        robot_ids_shrink: str = None,
        source: str = None,
        types_shrink: str = None,
    ):
        self.is_custom = is_custom
        self.max_results = max_results
        self.name = name
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.robot_ids_shrink = robot_ids_shrink
        self.source = source
        self.types_shrink = types_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_custom is not None:
            result['isCustom'] = self.is_custom
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.name is not None:
            result['name'] = self.name
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.robot_ids_shrink is not None:
            result['robotIds'] = self.robot_ids_shrink
        if self.source is not None:
            result['source'] = self.source
        if self.types_shrink is not None:
            result['types'] = self.types_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isCustom') is not None:
            self.is_custom = m.get('isCustom')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('robotIds') is not None:
            self.robot_ids_shrink = m.get('robotIds')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('types') is not None:
            self.types_shrink = m.get('types')
        return self


class ListAlertRobotsResponseBodyRobots(TeaModel):
    def __init__(
        self,
        lang: str = None,
        name: str = None,
        robot_id: str = None,
        type: str = None,
        url: str = None,
    ):
        self.lang = lang
        self.name = name
        self.robot_id = robot_id
        self.type = type
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['lang'] = self.lang
        if self.name is not None:
            result['name'] = self.name
        if self.robot_id is not None:
            result['robotId'] = self.robot_id
        if self.type is not None:
            result['type'] = self.type
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('lang') is not None:
            self.lang = m.get('lang')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('robotId') is not None:
            self.robot_id = m.get('robotId')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class ListAlertRobotsResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        robots: List[ListAlertRobotsResponseBodyRobots] = None,
        total: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.robots = robots
        self.total = total

    def validate(self):
        if self.robots:
            for k in self.robots:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['robots'] = []
        if self.robots is not None:
            for k in self.robots:
                result['robots'].append(k.to_map() if k else None)
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.robots = []
        if m.get('robots') is not None:
            for k in m.get('robots'):
                temp_model = ListAlertRobotsResponseBodyRobots()
                self.robots.append(temp_model.from_map(k))
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListAlertRobotsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAlertRobotsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAlertRobotsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAlertRuleTemplatesRequest(TeaModel):
    def __init__(
        self,
        alert_rule_template_id: str = None,
        biz_source: str = None,
        include_details: bool = None,
        max_results: int = None,
        next_token: str = None,
    ):
        self.alert_rule_template_id = alert_rule_template_id
        self.biz_source = biz_source
        self.include_details = include_details
        self.max_results = max_results
        self.next_token = next_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_template_id is not None:
            result['alertRuleTemplateId'] = self.alert_rule_template_id
        if self.biz_source is not None:
            result['bizSource'] = self.biz_source
        if self.include_details is not None:
            result['includeDetails'] = self.include_details
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleTemplateId') is not None:
            self.alert_rule_template_id = m.get('alertRuleTemplateId')
        if m.get('bizSource') is not None:
            self.biz_source = m.get('bizSource')
        if m.get('includeDetails') is not None:
            self.include_details = m.get('includeDetails')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        return self


class ListAlertRuleTemplatesResponseBodyData(TeaModel):
    def __init__(
        self,
        alert_rule_template_id: str = None,
        annotations_cn: Dict[str, str] = None,
        annotations_en: Dict[str, str] = None,
        biz_source: str = None,
        condition: AlertRuleCondition = None,
        datasource: AlertRuleDataSource = None,
        description_cn: str = None,
        description_en: str = None,
        display_name_cn: str = None,
        display_name_en: str = None,
        interval: int = None,
        labels: Dict[str, str] = None,
        level: str = None,
        query: AlertRuleQuery = None,
    ):
        self.alert_rule_template_id = alert_rule_template_id
        self.annotations_cn = annotations_cn
        self.annotations_en = annotations_en
        self.biz_source = biz_source
        self.condition = condition
        self.datasource = datasource
        self.description_cn = description_cn
        self.description_en = description_en
        self.display_name_cn = display_name_cn
        self.display_name_en = display_name_en
        self.interval = interval
        self.labels = labels
        self.level = level
        self.query = query

    def validate(self):
        if self.condition:
            self.condition.validate()
        if self.datasource:
            self.datasource.validate()
        if self.query:
            self.query.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_template_id is not None:
            result['alertRuleTemplateId'] = self.alert_rule_template_id
        if self.annotations_cn is not None:
            result['annotationsCn'] = self.annotations_cn
        if self.annotations_en is not None:
            result['annotationsEn'] = self.annotations_en
        if self.biz_source is not None:
            result['bizSource'] = self.biz_source
        if self.condition is not None:
            result['condition'] = self.condition.to_map()
        if self.datasource is not None:
            result['datasource'] = self.datasource.to_map()
        if self.description_cn is not None:
            result['descriptionCn'] = self.description_cn
        if self.description_en is not None:
            result['descriptionEn'] = self.description_en
        if self.display_name_cn is not None:
            result['displayNameCn'] = self.display_name_cn
        if self.display_name_en is not None:
            result['displayNameEn'] = self.display_name_en
        if self.interval is not None:
            result['interval'] = self.interval
        if self.labels is not None:
            result['labels'] = self.labels
        if self.level is not None:
            result['level'] = self.level
        if self.query is not None:
            result['query'] = self.query.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleTemplateId') is not None:
            self.alert_rule_template_id = m.get('alertRuleTemplateId')
        if m.get('annotationsCn') is not None:
            self.annotations_cn = m.get('annotationsCn')
        if m.get('annotationsEn') is not None:
            self.annotations_en = m.get('annotationsEn')
        if m.get('bizSource') is not None:
            self.biz_source = m.get('bizSource')
        if m.get('condition') is not None:
            temp_model = AlertRuleCondition()
            self.condition = temp_model.from_map(m['condition'])
        if m.get('datasource') is not None:
            temp_model = AlertRuleDataSource()
            self.datasource = temp_model.from_map(m['datasource'])
        if m.get('descriptionCn') is not None:
            self.description_cn = m.get('descriptionCn')
        if m.get('descriptionEn') is not None:
            self.description_en = m.get('descriptionEn')
        if m.get('displayNameCn') is not None:
            self.display_name_cn = m.get('displayNameCn')
        if m.get('displayNameEn') is not None:
            self.display_name_en = m.get('displayNameEn')
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('query') is not None:
            temp_model = AlertRuleQuery()
            self.query = temp_model.from_map(m['query'])
        return self


class ListAlertRuleTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListAlertRuleTemplatesResponseBodyData] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.data = data
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ListAlertRuleTemplatesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListAlertRuleTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAlertRuleTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAlertRuleTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAlertRulesRequest(TeaModel):
    def __init__(
        self,
        alert_rule_id: str = None,
        biz_source: str = None,
        display_name_key_word: str = None,
        enabled: bool = None,
        label_filter: AlertRuleLabelFilter = None,
        max_results: int = None,
        next_token: str = None,
        notification_filter: AlertRuleNotificationFilter = None,
        page_number: int = None,
        page_size: int = None,
        status: str = None,
        workspace: str = None,
    ):
        self.alert_rule_id = alert_rule_id
        self.biz_source = biz_source
        self.display_name_key_word = display_name_key_word
        self.enabled = enabled
        self.label_filter = label_filter
        self.max_results = max_results
        self.next_token = next_token
        self.notification_filter = notification_filter
        self.page_number = page_number
        self.page_size = page_size
        self.status = status
        self.workspace = workspace

    def validate(self):
        if self.label_filter:
            self.label_filter.validate()
        if self.notification_filter:
            self.notification_filter.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_id is not None:
            result['alertRuleId'] = self.alert_rule_id
        if self.biz_source is not None:
            result['bizSource'] = self.biz_source
        if self.display_name_key_word is not None:
            result['displayNameKeyWord'] = self.display_name_key_word
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.label_filter is not None:
            result['labelFilter'] = self.label_filter.to_map()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.notification_filter is not None:
            result['notificationFilter'] = self.notification_filter.to_map()
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.status is not None:
            result['status'] = self.status
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleId') is not None:
            self.alert_rule_id = m.get('alertRuleId')
        if m.get('bizSource') is not None:
            self.biz_source = m.get('bizSource')
        if m.get('displayNameKeyWord') is not None:
            self.display_name_key_word = m.get('displayNameKeyWord')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('labelFilter') is not None:
            temp_model = AlertRuleLabelFilter()
            self.label_filter = temp_model.from_map(m['labelFilter'])
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('notificationFilter') is not None:
            temp_model = AlertRuleNotificationFilter()
            self.notification_filter = temp_model.from_map(m['notificationFilter'])
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListAlertRulesShrinkRequest(TeaModel):
    def __init__(
        self,
        alert_rule_id: str = None,
        biz_source: str = None,
        display_name_key_word: str = None,
        enabled: bool = None,
        label_filter_shrink: str = None,
        max_results: int = None,
        next_token: str = None,
        notification_filter_shrink: str = None,
        page_number: int = None,
        page_size: int = None,
        status: str = None,
        workspace: str = None,
    ):
        self.alert_rule_id = alert_rule_id
        self.biz_source = biz_source
        self.display_name_key_word = display_name_key_word
        self.enabled = enabled
        self.label_filter_shrink = label_filter_shrink
        self.max_results = max_results
        self.next_token = next_token
        self.notification_filter_shrink = notification_filter_shrink
        self.page_number = page_number
        self.page_size = page_size
        self.status = status
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_id is not None:
            result['alertRuleId'] = self.alert_rule_id
        if self.biz_source is not None:
            result['bizSource'] = self.biz_source
        if self.display_name_key_word is not None:
            result['displayNameKeyWord'] = self.display_name_key_word
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.label_filter_shrink is not None:
            result['labelFilter'] = self.label_filter_shrink
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.notification_filter_shrink is not None:
            result['notificationFilter'] = self.notification_filter_shrink
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.status is not None:
            result['status'] = self.status
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertRuleId') is not None:
            self.alert_rule_id = m.get('alertRuleId')
        if m.get('bizSource') is not None:
            self.biz_source = m.get('bizSource')
        if m.get('displayNameKeyWord') is not None:
            self.display_name_key_word = m.get('displayNameKeyWord')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('labelFilter') is not None:
            self.label_filter_shrink = m.get('labelFilter')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('notificationFilter') is not None:
            self.notification_filter_shrink = m.get('notificationFilter')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListAlertRulesResponseBodyData(TeaModel):
    def __init__(
        self,
        alert_metric_input: AlertRuleAlertMetricInput = None,
        alert_rule_id: str = None,
        annotations: Dict[str, str] = None,
        biz_source: str = None,
        condition: AlertRuleCondition = None,
        created_by: str = None,
        datasource: AlertRuleDataSource = None,
        display_name: str = None,
        effect_time: AlertRuleTimeSpan = None,
        enabled: bool = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        interval: int = None,
        labels: Dict[str, str] = None,
        level: str = None,
        message: str = None,
        query: AlertRuleQuery = None,
        region_id: str = None,
        send: AlertRuleSend = None,
        status: str = None,
        workspace: str = None,
    ):
        self.alert_metric_input = alert_metric_input
        self.alert_rule_id = alert_rule_id
        self.annotations = annotations
        self.biz_source = biz_source
        self.condition = condition
        self.created_by = created_by
        self.datasource = datasource
        self.display_name = display_name
        self.effect_time = effect_time
        self.enabled = enabled
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.interval = interval
        self.labels = labels
        self.level = level
        self.message = message
        self.query = query
        self.region_id = region_id
        self.send = send
        self.status = status
        self.workspace = workspace

    def validate(self):
        if self.alert_metric_input:
            self.alert_metric_input.validate()
        if self.condition:
            self.condition.validate()
        if self.datasource:
            self.datasource.validate()
        if self.effect_time:
            self.effect_time.validate()
        if self.query:
            self.query.validate()
        if self.send:
            self.send.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_metric_input is not None:
            result['alertMetricInput'] = self.alert_metric_input.to_map()
        if self.alert_rule_id is not None:
            result['alertRuleId'] = self.alert_rule_id
        if self.annotations is not None:
            result['annotations'] = self.annotations
        if self.biz_source is not None:
            result['bizSource'] = self.biz_source
        if self.condition is not None:
            result['condition'] = self.condition.to_map()
        if self.created_by is not None:
            result['createdBy'] = self.created_by
        if self.datasource is not None:
            result['datasource'] = self.datasource.to_map()
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.effect_time is not None:
            result['effectTime'] = self.effect_time.to_map()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.interval is not None:
            result['interval'] = self.interval
        if self.labels is not None:
            result['labels'] = self.labels
        if self.level is not None:
            result['level'] = self.level
        if self.message is not None:
            result['message'] = self.message
        if self.query is not None:
            result['query'] = self.query.to_map()
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.send is not None:
            result['send'] = self.send.to_map()
        if self.status is not None:
            result['status'] = self.status
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertMetricInput') is not None:
            temp_model = AlertRuleAlertMetricInput()
            self.alert_metric_input = temp_model.from_map(m['alertMetricInput'])
        if m.get('alertRuleId') is not None:
            self.alert_rule_id = m.get('alertRuleId')
        if m.get('annotations') is not None:
            self.annotations = m.get('annotations')
        if m.get('bizSource') is not None:
            self.biz_source = m.get('bizSource')
        if m.get('condition') is not None:
            temp_model = AlertRuleCondition()
            self.condition = temp_model.from_map(m['condition'])
        if m.get('createdBy') is not None:
            self.created_by = m.get('createdBy')
        if m.get('datasource') is not None:
            temp_model = AlertRuleDataSource()
            self.datasource = temp_model.from_map(m['datasource'])
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('effectTime') is not None:
            temp_model = AlertRuleTimeSpan()
            self.effect_time = temp_model.from_map(m['effectTime'])
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('query') is not None:
            temp_model = AlertRuleQuery()
            self.query = temp_model.from_map(m['query'])
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('send') is not None:
            temp_model = AlertRuleSend()
            self.send = temp_model.from_map(m['send'])
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListAlertRulesResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListAlertRulesResponseBodyData] = None,
        max_results: int = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.data = data
        self.max_results = max_results
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ListAlertRulesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListAlertRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAlertRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAlertRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAlertWebhookRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        source: str = None,
        types: List[str] = None,
        webhook_ids: List[str] = None,
    ):
        self.name = name
        self.page_number = page_number
        self.page_size = page_size
        self.source = source
        self.types = types
        self.webhook_ids = webhook_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.source is not None:
            result['source'] = self.source
        if self.types is not None:
            result['types'] = self.types
        if self.webhook_ids is not None:
            result['webhookIds'] = self.webhook_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('types') is not None:
            self.types = m.get('types')
        if m.get('webhookIds') is not None:
            self.webhook_ids = m.get('webhookIds')
        return self


class ListAlertWebhookShrinkRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        source: str = None,
        types_shrink: str = None,
        webhook_ids_shrink: str = None,
    ):
        self.name = name
        self.page_number = page_number
        self.page_size = page_size
        self.source = source
        self.types_shrink = types_shrink
        self.webhook_ids_shrink = webhook_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.source is not None:
            result['source'] = self.source
        if self.types_shrink is not None:
            result['types'] = self.types_shrink
        if self.webhook_ids_shrink is not None:
            result['webhookIds'] = self.webhook_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('types') is not None:
            self.types_shrink = m.get('types')
        if m.get('webhookIds') is not None:
            self.webhook_ids_shrink = m.get('webhookIds')
        return self


class ListAlertWebhookResponseBodyDataWebhooks(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        headers: Dict[str, Any] = None,
        lang: str = None,
        method: str = None,
        name: str = None,
        type: str = None,
        url: str = None,
        webhook_id: str = None,
    ):
        self.content_type = content_type
        self.headers = headers
        self.lang = lang
        self.method = method
        self.name = name
        self.type = type
        self.url = url
        self.webhook_id = webhook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.headers is not None:
            result['headers'] = self.headers
        if self.lang is not None:
            result['lang'] = self.lang
        if self.method is not None:
            result['method'] = self.method
        if self.name is not None:
            result['name'] = self.name
        if self.type is not None:
            result['type'] = self.type
        if self.url is not None:
            result['url'] = self.url
        if self.webhook_id is not None:
            result['webhookId'] = self.webhook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('lang') is not None:
            self.lang = m.get('lang')
        if m.get('method') is not None:
            self.method = m.get('method')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('webhookId') is not None:
            self.webhook_id = m.get('webhookId')
        return self


class ListAlertWebhookResponseBodyData(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        total: int = None,
        webhooks: List[ListAlertWebhookResponseBodyDataWebhooks] = None,
    ):
        self.page_number = page_number
        self.page_size = page_size
        self.total = total
        self.webhooks = webhooks

    def validate(self):
        if self.webhooks:
            for k in self.webhooks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.total is not None:
            result['total'] = self.total
        result['webhooks'] = []
        if self.webhooks is not None:
            for k in self.webhooks:
                result['webhooks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('total') is not None:
            self.total = m.get('total')
        self.webhooks = []
        if m.get('webhooks') is not None:
            for k in m.get('webhooks'):
                temp_model = ListAlertWebhookResponseBodyDataWebhooks()
                self.webhooks.append(temp_model.from_map(k))
        return self


class ListAlertWebhookResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListAlertWebhookResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            temp_model = ListAlertWebhookResponseBodyData()
            self.data = temp_model.from_map(m['data'])
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListAlertWebhookResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAlertWebhookResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAlertWebhookResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAlertWebhooksRequest(TeaModel):
    def __init__(
        self,
        is_custom: str = None,
        max_results: int = None,
        name: str = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        source: str = None,
        webhook_ids: List[str] = None,
    ):
        self.is_custom = is_custom
        self.max_results = max_results
        self.name = name
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.source = source
        self.webhook_ids = webhook_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_custom is not None:
            result['isCustom'] = self.is_custom
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.name is not None:
            result['name'] = self.name
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.source is not None:
            result['source'] = self.source
        if self.webhook_ids is not None:
            result['webhookIds'] = self.webhook_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isCustom') is not None:
            self.is_custom = m.get('isCustom')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('webhookIds') is not None:
            self.webhook_ids = m.get('webhookIds')
        return self


class ListAlertWebhooksShrinkRequest(TeaModel):
    def __init__(
        self,
        is_custom: str = None,
        max_results: int = None,
        name: str = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        source: str = None,
        webhook_ids_shrink: str = None,
    ):
        self.is_custom = is_custom
        self.max_results = max_results
        self.name = name
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.source = source
        self.webhook_ids_shrink = webhook_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_custom is not None:
            result['isCustom'] = self.is_custom
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.name is not None:
            result['name'] = self.name
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.source is not None:
            result['source'] = self.source
        if self.webhook_ids_shrink is not None:
            result['webhookIds'] = self.webhook_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isCustom') is not None:
            self.is_custom = m.get('isCustom')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('webhookIds') is not None:
            self.webhook_ids_shrink = m.get('webhookIds')
        return self


class ListAlertWebhooksResponseBodyWebhooks(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        headers: Dict[str, Any] = None,
        lang: str = None,
        method: str = None,
        name: str = None,
        url: str = None,
        webhook_id: str = None,
    ):
        self.content_type = content_type
        self.headers = headers
        self.lang = lang
        self.method = method
        self.name = name
        self.url = url
        self.webhook_id = webhook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.headers is not None:
            result['headers'] = self.headers
        if self.lang is not None:
            result['lang'] = self.lang
        if self.method is not None:
            result['method'] = self.method
        if self.name is not None:
            result['name'] = self.name
        if self.url is not None:
            result['url'] = self.url
        if self.webhook_id is not None:
            result['webhookId'] = self.webhook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('lang') is not None:
            self.lang = m.get('lang')
        if m.get('method') is not None:
            self.method = m.get('method')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('webhookId') is not None:
            self.webhook_id = m.get('webhookId')
        return self


class ListAlertWebhooksResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total: int = None,
        webhooks: List[ListAlertWebhooksResponseBodyWebhooks] = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total = total
        self.webhooks = webhooks

    def validate(self):
        if self.webhooks:
            for k in self.webhooks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total is not None:
            result['total'] = self.total
        result['webhooks'] = []
        if self.webhooks is not None:
            for k in self.webhooks:
                result['webhooks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('total') is not None:
            self.total = m.get('total')
        self.webhooks = []
        if m.get('webhooks') is not None:
            for k in m.get('webhooks'):
                temp_model = ListAlertWebhooksResponseBodyWebhooks()
                self.webhooks.append(temp_model.from_map(k))
        return self


class ListAlertWebhooksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAlertWebhooksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAlertWebhooksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAvailableRegionsForCloudRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        addon_version: str = None,
        aliyun_lang: str = None,
        region_id: str = None,
    ):
        self.addon_name = addon_name
        self.addon_version = addon_version
        self.aliyun_lang = aliyun_lang
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.addon_version is not None:
            result['AddonVersion'] = self.addon_version
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('AddonVersion') is not None:
            self.addon_version = m.get('AddonVersion')
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListAvailableRegionsForCloudResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[str] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListAvailableRegionsForCloudResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAvailableRegionsForCloudResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAvailableRegionsForCloudResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListBizTracesRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        workspace: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListBizTracesResponseBody(TeaModel):
    def __init__(
        self,
        items: List[BizTraceConfig] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.items = items
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = BizTraceConfig()
                self.items.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListBizTracesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListBizTracesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListBizTracesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListClusterApmWorkloadRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_namespace: str = None,
        policy_id: str = None,
        workload_name: str = None,
    ):
        self.cluster_id = cluster_id
        self.cluster_namespace = cluster_namespace
        # This parameter is required.
        self.policy_id = policy_id
        self.workload_name = workload_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['clusterId'] = self.cluster_id
        if self.cluster_namespace is not None:
            result['clusterNamespace'] = self.cluster_namespace
        if self.policy_id is not None:
            result['policyId'] = self.policy_id
        if self.workload_name is not None:
            result['workloadName'] = self.workload_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterId') is not None:
            self.cluster_id = m.get('clusterId')
        if m.get('clusterNamespace') is not None:
            self.cluster_namespace = m.get('clusterNamespace')
        if m.get('policyId') is not None:
            self.policy_id = m.get('policyId')
        if m.get('workloadName') is not None:
            self.workload_name = m.get('workloadName')
        return self


class ListClusterApmWorkloadResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: Any = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListClusterApmWorkloadResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListClusterApmWorkloadResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListClusterApmWorkloadResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListContactRequest(TeaModel):
    def __init__(
        self,
        contact_ids: List[str] = None,
        email: str = None,
        group_identifier: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        phone: str = None,
        query_ungrouped_contacts: bool = None,
        source: str = None,
    ):
        self.contact_ids = contact_ids
        self.email = email
        self.group_identifier = group_identifier
        self.name = name
        self.page_number = page_number
        self.page_size = page_size
        self.phone = phone
        self.query_ungrouped_contacts = query_ungrouped_contacts
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_ids is not None:
            result['contactIds'] = self.contact_ids
        if self.email is not None:
            result['email'] = self.email
        if self.group_identifier is not None:
            result['groupIdentifier'] = self.group_identifier
        if self.name is not None:
            result['name'] = self.name
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.phone is not None:
            result['phone'] = self.phone
        if self.query_ungrouped_contacts is not None:
            result['queryUngroupedContacts'] = self.query_ungrouped_contacts
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactIds') is not None:
            self.contact_ids = m.get('contactIds')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('groupIdentifier') is not None:
            self.group_identifier = m.get('groupIdentifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('phone') is not None:
            self.phone = m.get('phone')
        if m.get('queryUngroupedContacts') is not None:
            self.query_ungrouped_contacts = m.get('queryUngroupedContacts')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class ListContactShrinkRequest(TeaModel):
    def __init__(
        self,
        contact_ids_shrink: str = None,
        email: str = None,
        group_identifier: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        phone: str = None,
        query_ungrouped_contacts: bool = None,
        source: str = None,
    ):
        self.contact_ids_shrink = contact_ids_shrink
        self.email = email
        self.group_identifier = group_identifier
        self.name = name
        self.page_number = page_number
        self.page_size = page_size
        self.phone = phone
        self.query_ungrouped_contacts = query_ungrouped_contacts
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_ids_shrink is not None:
            result['contactIds'] = self.contact_ids_shrink
        if self.email is not None:
            result['email'] = self.email
        if self.group_identifier is not None:
            result['groupIdentifier'] = self.group_identifier
        if self.name is not None:
            result['name'] = self.name
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.phone is not None:
            result['phone'] = self.phone
        if self.query_ungrouped_contacts is not None:
            result['queryUngroupedContacts'] = self.query_ungrouped_contacts
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactIds') is not None:
            self.contact_ids_shrink = m.get('contactIds')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('groupIdentifier') is not None:
            self.group_identifier = m.get('groupIdentifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('phone') is not None:
            self.phone = m.get('phone')
        if m.get('queryUngroupedContacts') is not None:
            self.query_ungrouped_contacts = m.get('queryUngroupedContacts')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class ListContactResponseBodyDataContacts(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        email: str = None,
        email_verify: bool = None,
        group_list: List[str] = None,
        lang: str = None,
        name: str = None,
        phone: str = None,
        phone_code: str = None,
        phone_verify: bool = None,
        update_time: str = None,
    ):
        self.contact_id = contact_id
        self.email = email
        self.email_verify = email_verify
        self.group_list = group_list
        self.lang = lang
        self.name = name
        self.phone = phone
        self.phone_code = phone_code
        self.phone_verify = phone_verify
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['contactId'] = self.contact_id
        if self.email is not None:
            result['email'] = self.email
        if self.email_verify is not None:
            result['emailVerify'] = self.email_verify
        if self.group_list is not None:
            result['groupList'] = self.group_list
        if self.lang is not None:
            result['lang'] = self.lang
        if self.name is not None:
            result['name'] = self.name
        if self.phone is not None:
            result['phone'] = self.phone
        if self.phone_code is not None:
            result['phoneCode'] = self.phone_code
        if self.phone_verify is not None:
            result['phoneVerify'] = self.phone_verify
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactId') is not None:
            self.contact_id = m.get('contactId')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('emailVerify') is not None:
            self.email_verify = m.get('emailVerify')
        if m.get('groupList') is not None:
            self.group_list = m.get('groupList')
        if m.get('lang') is not None:
            self.lang = m.get('lang')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('phone') is not None:
            self.phone = m.get('phone')
        if m.get('phoneCode') is not None:
            self.phone_code = m.get('phoneCode')
        if m.get('phoneVerify') is not None:
            self.phone_verify = m.get('phoneVerify')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class ListContactResponseBodyData(TeaModel):
    def __init__(
        self,
        contacts: List[ListContactResponseBodyDataContacts] = None,
        page_number: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.contacts = contacts
        self.page_number = page_number
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.contacts:
            for k in self.contacts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['contacts'] = []
        if self.contacts is not None:
            for k in self.contacts:
                result['contacts'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.contacts = []
        if m.get('contacts') is not None:
            for k in m.get('contacts'):
                temp_model = ListContactResponseBodyDataContacts()
                self.contacts.append(temp_model.from_map(k))
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListContactResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListContactResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            temp_model = ListContactResponseBodyData()
            self.data = temp_model.from_map(m['data'])
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListContactResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListContactResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListContactResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListContactGroupRequest(TeaModel):
    def __init__(
        self,
        contact_group_ids: List[str] = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        source: str = None,
    ):
        self.contact_group_ids = contact_group_ids
        self.name = name
        self.page_number = page_number
        self.page_size = page_size
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_ids is not None:
            result['contactGroupIds'] = self.contact_group_ids
        if self.name is not None:
            result['name'] = self.name
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactGroupIds') is not None:
            self.contact_group_ids = m.get('contactGroupIds')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class ListContactGroupShrinkRequest(TeaModel):
    def __init__(
        self,
        contact_group_ids_shrink: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        source: str = None,
    ):
        self.contact_group_ids_shrink = contact_group_ids_shrink
        self.name = name
        self.page_number = page_number
        self.page_size = page_size
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_ids_shrink is not None:
            result['contactGroupIds'] = self.contact_group_ids_shrink
        if self.name is not None:
            result['name'] = self.name
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactGroupIds') is not None:
            self.contact_group_ids_shrink = m.get('contactGroupIds')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class ListContactGroupResponseBodyDataContactGroups(TeaModel):
    def __init__(
        self,
        contact_group_id: str = None,
        contact_identifiers: List[str] = None,
        name: str = None,
    ):
        self.contact_group_id = contact_group_id
        self.contact_identifiers = contact_identifiers
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_id is not None:
            result['contactGroupId'] = self.contact_group_id
        if self.contact_identifiers is not None:
            result['contactIdentifiers'] = self.contact_identifiers
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactGroupId') is not None:
            self.contact_group_id = m.get('contactGroupId')
        if m.get('contactIdentifiers') is not None:
            self.contact_identifiers = m.get('contactIdentifiers')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListContactGroupResponseBodyData(TeaModel):
    def __init__(
        self,
        contact_groups: List[ListContactGroupResponseBodyDataContactGroups] = None,
        page_number: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.contact_groups = contact_groups
        self.page_number = page_number
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.contact_groups:
            for k in self.contact_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['contactGroups'] = []
        if self.contact_groups is not None:
            for k in self.contact_groups:
                result['contactGroups'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.contact_groups = []
        if m.get('contactGroups') is not None:
            for k in m.get('contactGroups'):
                temp_model = ListContactGroupResponseBodyDataContactGroups()
                self.contact_groups.append(temp_model.from_map(k))
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListContactGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListContactGroupResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            temp_model = ListContactGroupResponseBodyData()
            self.data = temp_model.from_map(m['data'])
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListContactGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListContactGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListContactGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListContactGroupsRequest(TeaModel):
    def __init__(
        self,
        contact_group_ids: List[str] = None,
        max_results: int = None,
        name: str = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        source: str = None,
    ):
        self.contact_group_ids = contact_group_ids
        self.max_results = max_results
        self.name = name
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_ids is not None:
            result['contactGroupIds'] = self.contact_group_ids
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.name is not None:
            result['name'] = self.name
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactGroupIds') is not None:
            self.contact_group_ids = m.get('contactGroupIds')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class ListContactGroupsShrinkRequest(TeaModel):
    def __init__(
        self,
        contact_group_ids_shrink: str = None,
        max_results: int = None,
        name: str = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        source: str = None,
    ):
        self.contact_group_ids_shrink = contact_group_ids_shrink
        self.max_results = max_results
        self.name = name
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_ids_shrink is not None:
            result['contactGroupIds'] = self.contact_group_ids_shrink
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.name is not None:
            result['name'] = self.name
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactGroupIds') is not None:
            self.contact_group_ids_shrink = m.get('contactGroupIds')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class ListContactGroupsResponseBodyContactGroups(TeaModel):
    def __init__(
        self,
        contact_group_id: str = None,
        contact_ids: List[str] = None,
        name: str = None,
    ):
        self.contact_group_id = contact_group_id
        self.contact_ids = contact_ids
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_id is not None:
            result['contactGroupId'] = self.contact_group_id
        if self.contact_ids is not None:
            result['contactIds'] = self.contact_ids
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactGroupId') is not None:
            self.contact_group_id = m.get('contactGroupId')
        if m.get('contactIds') is not None:
            self.contact_ids = m.get('contactIds')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListContactGroupsResponseBody(TeaModel):
    def __init__(
        self,
        contact_groups: List[ListContactGroupsResponseBodyContactGroups] = None,
        max_results: int = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total: int = None,
    ):
        self.contact_groups = contact_groups
        self.max_results = max_results
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total = total

    def validate(self):
        if self.contact_groups:
            for k in self.contact_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['contactGroups'] = []
        if self.contact_groups is not None:
            for k in self.contact_groups:
                result['contactGroups'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.contact_groups = []
        if m.get('contactGroups') is not None:
            for k in m.get('contactGroups'):
                temp_model = ListContactGroupsResponseBodyContactGroups()
                self.contact_groups.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListContactGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListContactGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListContactGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListContactsRequest(TeaModel):
    def __init__(
        self,
        contact_ids: List[str] = None,
        email: str = None,
        group_id: str = None,
        max_results: int = None,
        name: str = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        phone: str = None,
        query_ungrouped_contacts: bool = None,
        source: str = None,
    ):
        self.contact_ids = contact_ids
        self.email = email
        self.group_id = group_id
        self.max_results = max_results
        self.name = name
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.phone = phone
        self.query_ungrouped_contacts = query_ungrouped_contacts
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_ids is not None:
            result['contactIds'] = self.contact_ids
        if self.email is not None:
            result['email'] = self.email
        if self.group_id is not None:
            result['groupId'] = self.group_id
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.name is not None:
            result['name'] = self.name
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.phone is not None:
            result['phone'] = self.phone
        if self.query_ungrouped_contacts is not None:
            result['queryUngroupedContacts'] = self.query_ungrouped_contacts
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactIds') is not None:
            self.contact_ids = m.get('contactIds')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('groupId') is not None:
            self.group_id = m.get('groupId')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('phone') is not None:
            self.phone = m.get('phone')
        if m.get('queryUngroupedContacts') is not None:
            self.query_ungrouped_contacts = m.get('queryUngroupedContacts')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class ListContactsShrinkRequest(TeaModel):
    def __init__(
        self,
        contact_ids_shrink: str = None,
        email: str = None,
        group_id: str = None,
        max_results: int = None,
        name: str = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        phone: str = None,
        query_ungrouped_contacts: bool = None,
        source: str = None,
    ):
        self.contact_ids_shrink = contact_ids_shrink
        self.email = email
        self.group_id = group_id
        self.max_results = max_results
        self.name = name
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.phone = phone
        self.query_ungrouped_contacts = query_ungrouped_contacts
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_ids_shrink is not None:
            result['contactIds'] = self.contact_ids_shrink
        if self.email is not None:
            result['email'] = self.email
        if self.group_id is not None:
            result['groupId'] = self.group_id
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.name is not None:
            result['name'] = self.name
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.phone is not None:
            result['phone'] = self.phone
        if self.query_ungrouped_contacts is not None:
            result['queryUngroupedContacts'] = self.query_ungrouped_contacts
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactIds') is not None:
            self.contact_ids_shrink = m.get('contactIds')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('groupId') is not None:
            self.group_id = m.get('groupId')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('phone') is not None:
            self.phone = m.get('phone')
        if m.get('queryUngroupedContacts') is not None:
            self.query_ungrouped_contacts = m.get('queryUngroupedContacts')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class ListContactsResponseBodyContacts(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        email: str = None,
        email_verify: bool = None,
        group_list: List[str] = None,
        im_user_ids: Dict[str, str] = None,
        lang: str = None,
        name: str = None,
        phone: str = None,
        phone_code: str = None,
        phone_verify: bool = None,
        update_time: str = None,
    ):
        self.contact_id = contact_id
        self.email = email
        self.email_verify = email_verify
        self.group_list = group_list
        self.im_user_ids = im_user_ids
        self.lang = lang
        self.name = name
        self.phone = phone
        self.phone_code = phone_code
        self.phone_verify = phone_verify
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['contactId'] = self.contact_id
        if self.email is not None:
            result['email'] = self.email
        if self.email_verify is not None:
            result['emailVerify'] = self.email_verify
        if self.group_list is not None:
            result['groupList'] = self.group_list
        if self.im_user_ids is not None:
            result['imUserIds'] = self.im_user_ids
        if self.lang is not None:
            result['lang'] = self.lang
        if self.name is not None:
            result['name'] = self.name
        if self.phone is not None:
            result['phone'] = self.phone
        if self.phone_code is not None:
            result['phoneCode'] = self.phone_code
        if self.phone_verify is not None:
            result['phoneVerify'] = self.phone_verify
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactId') is not None:
            self.contact_id = m.get('contactId')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('emailVerify') is not None:
            self.email_verify = m.get('emailVerify')
        if m.get('groupList') is not None:
            self.group_list = m.get('groupList')
        if m.get('imUserIds') is not None:
            self.im_user_ids = m.get('imUserIds')
        if m.get('lang') is not None:
            self.lang = m.get('lang')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('phone') is not None:
            self.phone = m.get('phone')
        if m.get('phoneCode') is not None:
            self.phone_code = m.get('phoneCode')
        if m.get('phoneVerify') is not None:
            self.phone_verify = m.get('phoneVerify')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class ListContactsResponseBody(TeaModel):
    def __init__(
        self,
        contacts: List[ListContactsResponseBodyContacts] = None,
        max_results: int = None,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        total: int = None,
    ):
        self.contacts = contacts
        self.max_results = max_results
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.total = total

    def validate(self):
        if self.contacts:
            for k in self.contacts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['contacts'] = []
        if self.contacts is not None:
            for k in self.contacts:
                result['contacts'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.contacts = []
        if m.get('contacts') is not None:
            for k in m.get('contacts'):
                temp_model = ListContactsResponseBodyContacts()
                self.contacts.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListContactsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListContactsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListContactsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEntityGroupsRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        workspace: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListEntityGroupsResponseBodyEntityGroupsEntityQueries(TeaModel):
    def __init__(
        self,
        entity_type: str = None,
        sql: str = None,
    ):
        self.entity_type = entity_type
        self.sql = sql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_type is not None:
            result['entityType'] = self.entity_type
        if self.sql is not None:
            result['sql'] = self.sql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('entityType') is not None:
            self.entity_type = m.get('entityType')
        if m.get('sql') is not None:
            self.sql = m.get('sql')
        return self


class ListEntityGroupsResponseBodyEntityGroupsEntityRulesAnnotations(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class ListEntityGroupsResponseBodyEntityGroupsEntityRulesFieldRules(TeaModel):
    def __init__(
        self,
        field_key: str = None,
        field_values: List[str] = None,
        op: str = None,
    ):
        self.field_key = field_key
        self.field_values = field_values
        self.op = op

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_key is not None:
            result['fieldKey'] = self.field_key
        if self.field_values is not None:
            result['fieldValues'] = self.field_values
        if self.op is not None:
            result['op'] = self.op
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldKey') is not None:
            self.field_key = m.get('fieldKey')
        if m.get('fieldValues') is not None:
            self.field_values = m.get('fieldValues')
        if m.get('op') is not None:
            self.op = m.get('op')
        return self


class ListEntityGroupsResponseBodyEntityGroupsEntityRulesIpMatchRule(TeaModel):
    def __init__(
        self,
        ip_cidr: str = None,
        ip_field_key: str = None,
    ):
        self.ip_cidr = ip_cidr
        self.ip_field_key = ip_field_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_cidr is not None:
            result['ipCIDR'] = self.ip_cidr
        if self.ip_field_key is not None:
            result['ipFieldKey'] = self.ip_field_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ipCIDR') is not None:
            self.ip_cidr = m.get('ipCIDR')
        if m.get('ipFieldKey') is not None:
            self.ip_field_key = m.get('ipFieldKey')
        return self


class ListEntityGroupsResponseBodyEntityGroupsEntityRulesLabels(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class ListEntityGroupsResponseBodyEntityGroupsEntityRulesTags(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class ListEntityGroupsResponseBodyEntityGroupsEntityRules(TeaModel):
    def __init__(
        self,
        annotations: List[ListEntityGroupsResponseBodyEntityGroupsEntityRulesAnnotations] = None,
        entity_types: List[str] = None,
        field_rules: List[ListEntityGroupsResponseBodyEntityGroupsEntityRulesFieldRules] = None,
        instance_ids: List[str] = None,
        ip_match_rule: ListEntityGroupsResponseBodyEntityGroupsEntityRulesIpMatchRule = None,
        labels: List[ListEntityGroupsResponseBodyEntityGroupsEntityRulesLabels] = None,
        resource_group_id: str = None,
        tags: List[ListEntityGroupsResponseBodyEntityGroupsEntityRulesTags] = None,
    ):
        self.annotations = annotations
        self.entity_types = entity_types
        self.field_rules = field_rules
        self.instance_ids = instance_ids
        self.ip_match_rule = ip_match_rule
        self.labels = labels
        self.resource_group_id = resource_group_id
        self.tags = tags

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.field_rules:
            for k in self.field_rules:
                if k:
                    k.validate()
        if self.ip_match_rule:
            self.ip_match_rule.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        if self.entity_types is not None:
            result['entityTypes'] = self.entity_types
        result['fieldRules'] = []
        if self.field_rules is not None:
            for k in self.field_rules:
                result['fieldRules'].append(k.to_map() if k else None)
        if self.instance_ids is not None:
            result['instanceIds'] = self.instance_ids
        if self.ip_match_rule is not None:
            result['ipMatchRule'] = self.ip_match_rule.to_map()
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = ListEntityGroupsResponseBodyEntityGroupsEntityRulesAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('entityTypes') is not None:
            self.entity_types = m.get('entityTypes')
        self.field_rules = []
        if m.get('fieldRules') is not None:
            for k in m.get('fieldRules'):
                temp_model = ListEntityGroupsResponseBodyEntityGroupsEntityRulesFieldRules()
                self.field_rules.append(temp_model.from_map(k))
        if m.get('instanceIds') is not None:
            self.instance_ids = m.get('instanceIds')
        if m.get('ipMatchRule') is not None:
            temp_model = ListEntityGroupsResponseBodyEntityGroupsEntityRulesIpMatchRule()
            self.ip_match_rule = temp_model.from_map(m['ipMatchRule'])
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = ListEntityGroupsResponseBodyEntityGroupsEntityRulesLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = ListEntityGroupsResponseBodyEntityGroupsEntityRulesTags()
                self.tags.append(temp_model.from_map(k))
        return self


class ListEntityGroupsResponseBodyEntityGroups(TeaModel):
    def __init__(
        self,
        description: str = None,
        entity_group_id: str = None,
        entity_group_name: str = None,
        entity_queries: ListEntityGroupsResponseBodyEntityGroupsEntityQueries = None,
        entity_rules: ListEntityGroupsResponseBodyEntityGroupsEntityRules = None,
        query: str = None,
        region_id: str = None,
        user_id: str = None,
        workspace: str = None,
    ):
        self.description = description
        self.entity_group_id = entity_group_id
        self.entity_group_name = entity_group_name
        self.entity_queries = entity_queries
        self.entity_rules = entity_rules
        self.query = query
        self.region_id = region_id
        self.user_id = user_id
        self.workspace = workspace

    def validate(self):
        if self.entity_queries:
            self.entity_queries.validate()
        if self.entity_rules:
            self.entity_rules.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.entity_group_id is not None:
            result['entityGroupId'] = self.entity_group_id
        if self.entity_group_name is not None:
            result['entityGroupName'] = self.entity_group_name
        if self.entity_queries is not None:
            result['entityQueries'] = self.entity_queries.to_map()
        if self.entity_rules is not None:
            result['entityRules'] = self.entity_rules.to_map()
        if self.query is not None:
            result['query'] = self.query
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('entityGroupId') is not None:
            self.entity_group_id = m.get('entityGroupId')
        if m.get('entityGroupName') is not None:
            self.entity_group_name = m.get('entityGroupName')
        if m.get('entityQueries') is not None:
            temp_model = ListEntityGroupsResponseBodyEntityGroupsEntityQueries()
            self.entity_queries = temp_model.from_map(m['entityQueries'])
        if m.get('entityRules') is not None:
            temp_model = ListEntityGroupsResponseBodyEntityGroupsEntityRules()
            self.entity_rules = temp_model.from_map(m['entityRules'])
        if m.get('query') is not None:
            self.query = m.get('query')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListEntityGroupsResponseBody(TeaModel):
    def __init__(
        self,
        entity_groups: List[ListEntityGroupsResponseBodyEntityGroups] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.entity_groups = entity_groups
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.entity_groups:
            for k in self.entity_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['entityGroups'] = []
        if self.entity_groups is not None:
            for k in self.entity_groups:
                result['entityGroups'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.entity_groups = []
        if m.get('entityGroups') is not None:
            for k in m.get('entityGroups'):
                temp_model = ListEntityGroupsResponseBodyEntityGroups()
                self.entity_groups.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListEntityGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEntityGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEntityGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvKubernetesNamespacesRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        region_id: str = None,
    ):
        # This parameter is required.
        self.environment_id = environment_id
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListEnvKubernetesNamespacesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[str] = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListEnvKubernetesNamespacesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvKubernetesNamespacesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvKubernetesNamespacesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvKubernetesServicesRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        namespace: str = None,
        region_id: str = None,
    ):
        # This parameter is required.
        self.environment_id = environment_id
        # This parameter is required.
        self.namespace = namespace
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListEnvKubernetesServicesResponseBodyDataPorts(TeaModel):
    def __init__(
        self,
        name: str = None,
        port: str = None,
        protocol: str = None,
        target_port: str = None,
    ):
        self.name = name
        self.port = port
        self.protocol = protocol
        self.target_port = target_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.port is not None:
            result['Port'] = self.port
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.target_port is not None:
            result['TargetPort'] = self.target_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('TargetPort') is not None:
            self.target_port = m.get('TargetPort')
        return self


class ListEnvKubernetesServicesResponseBodyData(TeaModel):
    def __init__(
        self,
        labels: Dict[str, str] = None,
        name_space: str = None,
        ports: List[ListEnvKubernetesServicesResponseBodyDataPorts] = None,
        selector: Dict[str, str] = None,
        service_name: str = None,
    ):
        self.labels = labels
        self.name_space = name_space
        self.ports = ports
        self.selector = selector
        self.service_name = service_name

    def validate(self):
        if self.ports:
            for k in self.ports:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.name_space is not None:
            result['NameSpace'] = self.name_space
        result['Ports'] = []
        if self.ports is not None:
            for k in self.ports:
                result['Ports'].append(k.to_map() if k else None)
        if self.selector is not None:
            result['Selector'] = self.selector
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('NameSpace') is not None:
            self.name_space = m.get('NameSpace')
        self.ports = []
        if m.get('Ports') is not None:
            for k in m.get('Ports'):
                temp_model = ListEnvKubernetesServicesResponseBodyDataPorts()
                self.ports.append(temp_model.from_map(k))
        if m.get('Selector') is not None:
            self.selector = m.get('Selector')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        return self


class ListEnvKubernetesServicesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListEnvKubernetesServicesResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListEnvKubernetesServicesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListEnvKubernetesServicesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvKubernetesServicesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvKubernetesServicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvPodsByPodAnnotationRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        region_id: str = None,
    ):
        # This parameter is required.
        self.environment_id = environment_id
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListEnvPodsByPodAnnotationResponseBodyData(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        name_space: str = None,
        path: str = None,
        pod_ip: str = None,
        pod_name: str = None,
        port: int = None,
        scrape_interval: str = None,
    ):
        self.environment_id = environment_id
        self.name_space = name_space
        self.path = path
        self.pod_ip = pod_ip
        self.pod_name = pod_name
        self.port = port
        self.scrape_interval = scrape_interval

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.name_space is not None:
            result['NameSpace'] = self.name_space
        if self.path is not None:
            result['Path'] = self.path
        if self.pod_ip is not None:
            result['PodIp'] = self.pod_ip
        if self.pod_name is not None:
            result['PodName'] = self.pod_name
        if self.port is not None:
            result['Port'] = self.port
        if self.scrape_interval is not None:
            result['ScrapeInterval'] = self.scrape_interval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('NameSpace') is not None:
            self.name_space = m.get('NameSpace')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('PodIp') is not None:
            self.pod_ip = m.get('PodIp')
        if m.get('PodName') is not None:
            self.pod_name = m.get('PodName')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('ScrapeInterval') is not None:
            self.scrape_interval = m.get('ScrapeInterval')
        return self


class ListEnvPodsByPodAnnotationResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListEnvPodsByPodAnnotationResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListEnvPodsByPodAnnotationResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListEnvPodsByPodAnnotationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvPodsByPodAnnotationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvPodsByPodAnnotationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvironmentAlertRulesRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        environment_id: str = None,
        region_id: str = None,
        scene: str = None,
    ):
        self.addon_name = addon_name
        # This parameter is required.
        self.environment_id = environment_id
        self.region_id = region_id
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scene is not None:
            result['Scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        return self


class ListEnvironmentAlertRulesResponseBodyDataRules(TeaModel):
    def __init__(
        self,
        alert_id: int = None,
        name: str = None,
    ):
        self.alert_id = alert_id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListEnvironmentAlertRulesResponseBodyData(TeaModel):
    def __init__(
        self,
        groups: List[str] = None,
        rules: List[ListEnvironmentAlertRulesResponseBodyDataRules] = None,
        total: int = None,
    ):
        self.groups = groups
        self.rules = rules
        self.total = total

    def validate(self):
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.groups is not None:
            result['Groups'] = self.groups
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Groups') is not None:
            self.groups = m.get('Groups')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = ListEnvironmentAlertRulesResponseBodyDataRules()
                self.rules.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListEnvironmentAlertRulesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListEnvironmentAlertRulesResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListEnvironmentAlertRulesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListEnvironmentAlertRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvironmentAlertRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvironmentAlertRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvironmentFeaturesRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        region_id: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListEnvironmentFeaturesResponseBodyData(TeaModel):
    def __init__(
        self,
        alias: str = None,
        config: Dict[str, str] = None,
        description: str = None,
        environment_id: str = None,
        icon: str = None,
        language: str = None,
        latest_version: str = None,
        managed: bool = None,
        name: str = None,
        status: str = None,
        version: str = None,
    ):
        self.alias = alias
        self.config = config
        self.description = description
        self.environment_id = environment_id
        self.icon = icon
        self.language = language
        self.latest_version = latest_version
        self.managed = managed
        self.name = name
        self.status = status
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.config is not None:
            result['Config'] = self.config
        if self.description is not None:
            result['Description'] = self.description
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.language is not None:
            result['Language'] = self.language
        if self.latest_version is not None:
            result['LatestVersion'] = self.latest_version
        if self.managed is not None:
            result['Managed'] = self.managed
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('LatestVersion') is not None:
            self.latest_version = m.get('LatestVersion')
        if m.get('Managed') is not None:
            self.managed = m.get('Managed')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListEnvironmentFeaturesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListEnvironmentFeaturesResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListEnvironmentFeaturesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListEnvironmentFeaturesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvironmentFeaturesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvironmentFeaturesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvironmentResourcesRequest(TeaModel):
    def __init__(
        self,
        bind_resource_id: str = None,
        bind_resource_name: str = None,
        environment_sub_type: str = None,
        environment_type: str = None,
        page_number: int = None,
        region_id: str = None,
    ):
        self.bind_resource_id = bind_resource_id
        self.bind_resource_name = bind_resource_name
        self.environment_sub_type = environment_sub_type
        # This parameter is required.
        self.environment_type = environment_type
        self.page_number = page_number
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_resource_id is not None:
            result['BindResourceId'] = self.bind_resource_id
        if self.bind_resource_name is not None:
            result['BindResourceName'] = self.bind_resource_name
        if self.environment_sub_type is not None:
            result['EnvironmentSubType'] = self.environment_sub_type
        if self.environment_type is not None:
            result['EnvironmentType'] = self.environment_type
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BindResourceId') is not None:
            self.bind_resource_id = m.get('BindResourceId')
        if m.get('BindResourceName') is not None:
            self.bind_resource_name = m.get('BindResourceName')
        if m.get('EnvironmentSubType') is not None:
            self.environment_sub_type = m.get('EnvironmentSubType')
        if m.get('EnvironmentType') is not None:
            self.environment_type = m.get('EnvironmentType')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListEnvironmentResourcesResponseBodyData(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        environment_name: str = None,
        fee_package: str = None,
        install_status: str = None,
        region_id: str = None,
        resource_id: str = None,
        resource_name: str = None,
        resource_sub_type: str = None,
        resource_type: str = None,
        user_id: str = None,
    ):
        self.environment_id = environment_id
        self.environment_name = environment_name
        self.fee_package = fee_package
        self.install_status = install_status
        self.region_id = region_id
        self.resource_id = resource_id
        self.resource_name = resource_name
        self.resource_sub_type = resource_sub_type
        self.resource_type = resource_type
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.environment_name is not None:
            result['EnvironmentName'] = self.environment_name
        if self.fee_package is not None:
            result['FeePackage'] = self.fee_package
        if self.install_status is not None:
            result['InstallStatus'] = self.install_status
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_name is not None:
            result['ResourceName'] = self.resource_name
        if self.resource_sub_type is not None:
            result['ResourceSubType'] = self.resource_sub_type
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('EnvironmentName') is not None:
            self.environment_name = m.get('EnvironmentName')
        if m.get('FeePackage') is not None:
            self.fee_package = m.get('FeePackage')
        if m.get('InstallStatus') is not None:
            self.install_status = m.get('InstallStatus')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceName') is not None:
            self.resource_name = m.get('ResourceName')
        if m.get('ResourceSubType') is not None:
            self.resource_sub_type = m.get('ResourceSubType')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListEnvironmentResourcesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListEnvironmentResourcesResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListEnvironmentResourcesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListEnvironmentResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvironmentResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvironmentResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvironmentsRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListEnvironmentsRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        bind_resource_id: str = None,
        environment_type: str = None,
        fee_package: str = None,
        filter_region_ids: str = None,
        page_number: int = None,
        page_size: int = None,
        region: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tag: List[ListEnvironmentsRequestTag] = None,
    ):
        self.addon_name = addon_name
        self.bind_resource_id = bind_resource_id
        self.environment_type = environment_type
        self.fee_package = fee_package
        self.filter_region_ids = filter_region_ids
        self.page_number = page_number
        self.page_size = page_size
        self.region = region
        self.region_id = region_id
        self.resource_group_id = resource_group_id
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.bind_resource_id is not None:
            result['BindResourceId'] = self.bind_resource_id
        if self.environment_type is not None:
            result['EnvironmentType'] = self.environment_type
        if self.fee_package is not None:
            result['FeePackage'] = self.fee_package
        if self.filter_region_ids is not None:
            result['FilterRegionIds'] = self.filter_region_ids
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('BindResourceId') is not None:
            self.bind_resource_id = m.get('BindResourceId')
        if m.get('EnvironmentType') is not None:
            self.environment_type = m.get('EnvironmentType')
        if m.get('FeePackage') is not None:
            self.fee_package = m.get('FeePackage')
        if m.get('FilterRegionIds') is not None:
            self.filter_region_ids = m.get('FilterRegionIds')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = ListEnvironmentsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class ListEnvironmentsShrinkRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        bind_resource_id: str = None,
        environment_type: str = None,
        fee_package: str = None,
        filter_region_ids: str = None,
        page_number: int = None,
        page_size: int = None,
        region: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tag_shrink: str = None,
    ):
        self.addon_name = addon_name
        self.bind_resource_id = bind_resource_id
        self.environment_type = environment_type
        self.fee_package = fee_package
        self.filter_region_ids = filter_region_ids
        self.page_number = page_number
        self.page_size = page_size
        self.region = region
        self.region_id = region_id
        self.resource_group_id = resource_group_id
        self.tag_shrink = tag_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.bind_resource_id is not None:
            result['BindResourceId'] = self.bind_resource_id
        if self.environment_type is not None:
            result['EnvironmentType'] = self.environment_type
        if self.fee_package is not None:
            result['FeePackage'] = self.fee_package
        if self.filter_region_ids is not None:
            result['FilterRegionIds'] = self.filter_region_ids
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.tag_shrink is not None:
            result['Tag'] = self.tag_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('BindResourceId') is not None:
            self.bind_resource_id = m.get('BindResourceId')
        if m.get('EnvironmentType') is not None:
            self.environment_type = m.get('EnvironmentType')
        if m.get('FeePackage') is not None:
            self.fee_package = m.get('FeePackage')
        if m.get('FilterRegionIds') is not None:
            self.filter_region_ids = m.get('FilterRegionIds')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Tag') is not None:
            self.tag_shrink = m.get('Tag')
        return self


class ListEnvironmentsResponseBodyDataEnvironmentsAddons(TeaModel):
    def __init__(
        self,
        alias: str = None,
        description: str = None,
        icon: str = None,
        name: str = None,
    ):
        self.alias = alias
        self.description = description
        self.icon = icon
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.description is not None:
            result['Description'] = self.description
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListEnvironmentsResponseBodyDataEnvironmentsFeatures(TeaModel):
    def __init__(
        self,
        alias: str = None,
        description: str = None,
        icon: str = None,
        name: str = None,
    ):
        self.alias = alias
        self.description = description
        self.icon = icon
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.description is not None:
            result['Description'] = self.description
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListEnvironmentsResponseBodyDataEnvironmentsTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListEnvironmentsResponseBodyDataEnvironments(TeaModel):
    def __init__(
        self,
        addons: List[ListEnvironmentsResponseBodyDataEnvironmentsAddons] = None,
        bind_resource_id: str = None,
        bind_resource_profile: str = None,
        bind_resource_type: str = None,
        bind_vpc_cidr: str = None,
        create_time: str = None,
        created_user_id: str = None,
        environment_id: str = None,
        environment_name: str = None,
        environment_type: str = None,
        features: List[ListEnvironmentsResponseBodyDataEnvironmentsFeatures] = None,
        fee_package: str = None,
        grafana_datasource_uid: str = None,
        grafana_folder_title: str = None,
        grafana_folder_uid: str = None,
        latest_release_create_time: str = None,
        managed_type: str = None,
        prometheus_id: int = None,
        prometheus_instance_id: str = None,
        region_id: str = None,
        release_count: int = None,
        resource_group_id: str = None,
        tags: List[ListEnvironmentsResponseBodyDataEnvironmentsTags] = None,
        user_id: str = None,
    ):
        self.addons = addons
        self.bind_resource_id = bind_resource_id
        self.bind_resource_profile = bind_resource_profile
        self.bind_resource_type = bind_resource_type
        self.bind_vpc_cidr = bind_vpc_cidr
        self.create_time = create_time
        self.created_user_id = created_user_id
        self.environment_id = environment_id
        self.environment_name = environment_name
        self.environment_type = environment_type
        self.features = features
        self.fee_package = fee_package
        self.grafana_datasource_uid = grafana_datasource_uid
        self.grafana_folder_title = grafana_folder_title
        self.grafana_folder_uid = grafana_folder_uid
        self.latest_release_create_time = latest_release_create_time
        self.managed_type = managed_type
        self.prometheus_id = prometheus_id
        self.prometheus_instance_id = prometheus_instance_id
        self.region_id = region_id
        self.release_count = release_count
        self.resource_group_id = resource_group_id
        self.tags = tags
        self.user_id = user_id

    def validate(self):
        if self.addons:
            for k in self.addons:
                if k:
                    k.validate()
        if self.features:
            for k in self.features:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Addons'] = []
        if self.addons is not None:
            for k in self.addons:
                result['Addons'].append(k.to_map() if k else None)
        if self.bind_resource_id is not None:
            result['BindResourceId'] = self.bind_resource_id
        if self.bind_resource_profile is not None:
            result['BindResourceProfile'] = self.bind_resource_profile
        if self.bind_resource_type is not None:
            result['BindResourceType'] = self.bind_resource_type
        if self.bind_vpc_cidr is not None:
            result['BindVpcCidr'] = self.bind_vpc_cidr
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.created_user_id is not None:
            result['CreatedUserId'] = self.created_user_id
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.environment_name is not None:
            result['EnvironmentName'] = self.environment_name
        if self.environment_type is not None:
            result['EnvironmentType'] = self.environment_type
        result['Features'] = []
        if self.features is not None:
            for k in self.features:
                result['Features'].append(k.to_map() if k else None)
        if self.fee_package is not None:
            result['FeePackage'] = self.fee_package
        if self.grafana_datasource_uid is not None:
            result['GrafanaDatasourceUid'] = self.grafana_datasource_uid
        if self.grafana_folder_title is not None:
            result['GrafanaFolderTitle'] = self.grafana_folder_title
        if self.grafana_folder_uid is not None:
            result['GrafanaFolderUid'] = self.grafana_folder_uid
        if self.latest_release_create_time is not None:
            result['LatestReleaseCreateTime'] = self.latest_release_create_time
        if self.managed_type is not None:
            result['ManagedType'] = self.managed_type
        if self.prometheus_id is not None:
            result['PrometheusId'] = self.prometheus_id
        if self.prometheus_instance_id is not None:
            result['PrometheusInstanceId'] = self.prometheus_instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_count is not None:
            result['ReleaseCount'] = self.release_count
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addons = []
        if m.get('Addons') is not None:
            for k in m.get('Addons'):
                temp_model = ListEnvironmentsResponseBodyDataEnvironmentsAddons()
                self.addons.append(temp_model.from_map(k))
        if m.get('BindResourceId') is not None:
            self.bind_resource_id = m.get('BindResourceId')
        if m.get('BindResourceProfile') is not None:
            self.bind_resource_profile = m.get('BindResourceProfile')
        if m.get('BindResourceType') is not None:
            self.bind_resource_type = m.get('BindResourceType')
        if m.get('BindVpcCidr') is not None:
            self.bind_vpc_cidr = m.get('BindVpcCidr')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatedUserId') is not None:
            self.created_user_id = m.get('CreatedUserId')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('EnvironmentName') is not None:
            self.environment_name = m.get('EnvironmentName')
        if m.get('EnvironmentType') is not None:
            self.environment_type = m.get('EnvironmentType')
        self.features = []
        if m.get('Features') is not None:
            for k in m.get('Features'):
                temp_model = ListEnvironmentsResponseBodyDataEnvironmentsFeatures()
                self.features.append(temp_model.from_map(k))
        if m.get('FeePackage') is not None:
            self.fee_package = m.get('FeePackage')
        if m.get('GrafanaDatasourceUid') is not None:
            self.grafana_datasource_uid = m.get('GrafanaDatasourceUid')
        if m.get('GrafanaFolderTitle') is not None:
            self.grafana_folder_title = m.get('GrafanaFolderTitle')
        if m.get('GrafanaFolderUid') is not None:
            self.grafana_folder_uid = m.get('GrafanaFolderUid')
        if m.get('LatestReleaseCreateTime') is not None:
            self.latest_release_create_time = m.get('LatestReleaseCreateTime')
        if m.get('ManagedType') is not None:
            self.managed_type = m.get('ManagedType')
        if m.get('PrometheusId') is not None:
            self.prometheus_id = m.get('PrometheusId')
        if m.get('PrometheusInstanceId') is not None:
            self.prometheus_instance_id = m.get('PrometheusInstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseCount') is not None:
            self.release_count = m.get('ReleaseCount')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListEnvironmentsResponseBodyDataEnvironmentsTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListEnvironmentsResponseBodyData(TeaModel):
    def __init__(
        self,
        environments: List[ListEnvironmentsResponseBodyDataEnvironments] = None,
        total: int = None,
    ):
        self.environments = environments
        self.total = total

    def validate(self):
        if self.environments:
            for k in self.environments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Environments'] = []
        if self.environments is not None:
            for k in self.environments:
                result['Environments'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.environments = []
        if m.get('Environments') is not None:
            for k in m.get('Environments'):
                temp_model = ListEnvironmentsResponseBodyDataEnvironments()
                self.environments.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListEnvironmentsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListEnvironmentsResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListEnvironmentsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListEnvironmentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvironmentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvironmentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEscalationRequest(TeaModel):
    def __init__(
        self,
        enable: bool = None,
        name: str = None,
        owner_product: str = None,
        page: int = None,
        size: int = None,
        uuid: str = None,
        workspace: str = None,
    ):
        self.enable = enable
        self.name = name
        self.owner_product = owner_product
        self.page = page
        self.size = size
        self.uuid = uuid
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable is not None:
            result['enable'] = self.enable
        if self.name is not None:
            result['name'] = self.name
        if self.owner_product is not None:
            result['ownerProduct'] = self.owner_product
        if self.page is not None:
            result['page'] = self.page
        if self.size is not None:
            result['size'] = self.size
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('ownerProduct') is not None:
            self.owner_product = m.get('ownerProduct')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListEscalationResponseBody(TeaModel):
    def __init__(
        self,
        escalation_list: List[EscalationForView] = None,
        page: int = None,
        request_id: str = None,
        size: int = None,
        total: int = None,
    ):
        self.escalation_list = escalation_list
        self.page = page
        self.request_id = request_id
        self.size = size
        self.total = total

    def validate(self):
        if self.escalation_list:
            for k in self.escalation_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['escalationList'] = []
        if self.escalation_list is not None:
            for k in self.escalation_list:
                result['escalationList'].append(k.to_map() if k else None)
        if self.page is not None:
            result['page'] = self.page
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.size is not None:
            result['size'] = self.size
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.escalation_list = []
        if m.get('escalationList') is not None:
            for k in m.get('escalationList'):
                temp_model = EscalationForView()
                self.escalation_list.append(temp_model.from_map(k))
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListEscalationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEscalationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEscalationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEventLabelCacheKeysRequest(TeaModel):
    def __init__(
        self,
        key: str = None,
        max_results: int = None,
        workspace: str = None,
    ):
        self.key = key
        self.max_results = max_results
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListEventLabelCacheKeysResponseBody(TeaModel):
    def __init__(
        self,
        keys: List[str] = None,
        max_results: int = None,
        request_id: str = None,
    ):
        self.keys = keys
        self.max_results = max_results
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keys is not None:
            result['keys'] = self.keys
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('keys') is not None:
            self.keys = m.get('keys')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListEventLabelCacheKeysResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEventLabelCacheKeysResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEventLabelCacheKeysResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEventLabelCacheValuesRequest(TeaModel):
    def __init__(
        self,
        key: str = None,
        max_results: int = None,
        value: str = None,
        workspace: str = None,
    ):
        # This parameter is required.
        self.key = key
        self.max_results = max_results
        self.value = value
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.value is not None:
            result['value'] = self.value
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListEventLabelCacheValuesResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        request_id: str = None,
        values: List[str] = None,
    ):
        self.max_results = max_results
        self.request_id = request_id
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.values is not None:
            result['values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('values') is not None:
            self.values = m.get('values')
        return self


class ListEventLabelCacheValuesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEventLabelCacheValuesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEventLabelCacheValuesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHistogramsRequest(TeaModel):
    def __init__(
        self,
        batch_id: str = None,
        contact: str = None,
        contact_group: str = None,
        enable: bool = None,
        from_: int = None,
        grouping_id: str = None,
        grouping_string: str = None,
        incident_id: str = None,
        name: str = None,
        owner_product: str = None,
        page: int = None,
        receiver: str = None,
        severity: str = None,
        size: int = None,
        status: str = None,
        strategy_name: str = None,
        strategy_uuid: str = None,
        to: int = None,
        uuid: str = None,
        workspace: str = None,
    ):
        self.batch_id = batch_id
        self.contact = contact
        self.contact_group = contact_group
        self.enable = enable
        # This parameter is required.
        self.from_ = from_
        self.grouping_id = grouping_id
        self.grouping_string = grouping_string
        self.incident_id = incident_id
        self.name = name
        self.owner_product = owner_product
        self.page = page
        self.receiver = receiver
        self.severity = severity
        self.size = size
        self.status = status
        self.strategy_name = strategy_name
        self.strategy_uuid = strategy_uuid
        # This parameter is required.
        self.to = to
        self.uuid = uuid
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_id is not None:
            result['batchId'] = self.batch_id
        if self.contact is not None:
            result['contact'] = self.contact
        if self.contact_group is not None:
            result['contactGroup'] = self.contact_group
        if self.enable is not None:
            result['enable'] = self.enable
        if self.from_ is not None:
            result['from'] = self.from_
        if self.grouping_id is not None:
            result['groupingId'] = self.grouping_id
        if self.grouping_string is not None:
            result['groupingString'] = self.grouping_string
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        if self.name is not None:
            result['name'] = self.name
        if self.owner_product is not None:
            result['ownerProduct'] = self.owner_product
        if self.page is not None:
            result['page'] = self.page
        if self.receiver is not None:
            result['receiver'] = self.receiver
        if self.severity is not None:
            result['severity'] = self.severity
        if self.size is not None:
            result['size'] = self.size
        if self.status is not None:
            result['status'] = self.status
        if self.strategy_name is not None:
            result['strategyName'] = self.strategy_name
        if self.strategy_uuid is not None:
            result['strategyUuid'] = self.strategy_uuid
        if self.to is not None:
            result['to'] = self.to
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('batchId') is not None:
            self.batch_id = m.get('batchId')
        if m.get('contact') is not None:
            self.contact = m.get('contact')
        if m.get('contactGroup') is not None:
            self.contact_group = m.get('contactGroup')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('groupingId') is not None:
            self.grouping_id = m.get('groupingId')
        if m.get('groupingString') is not None:
            self.grouping_string = m.get('groupingString')
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('ownerProduct') is not None:
            self.owner_product = m.get('ownerProduct')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('receiver') is not None:
            self.receiver = m.get('receiver')
        if m.get('severity') is not None:
            self.severity = m.get('severity')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('strategyName') is not None:
            self.strategy_name = m.get('strategyName')
        if m.get('strategyUuid') is not None:
            self.strategy_uuid = m.get('strategyUuid')
        if m.get('to') is not None:
            self.to = m.get('to')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListHistogramsResponseBodyDataList(TeaModel):
    def __init__(
        self,
        count: int = None,
        from_: int = None,
        to: int = None,
    ):
        self.count = count
        self.from_ = from_
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['count'] = self.count
        if self.from_ is not None:
            result['from'] = self.from_
        if self.to is not None:
            result['to'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('to') is not None:
            self.to = m.get('to')
        return self


class ListHistogramsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_list: List[ListHistogramsResponseBodyDataList] = None,
        message: str = None,
        page: int = None,
        request_id: str = None,
        size: int = None,
        success: bool = None,
        total: int = None,
    ):
        self.code = code
        self.data_list = data_list
        self.message = message
        self.page = page
        self.request_id = request_id
        self.size = size
        self.success = success
        self.total = total

    def validate(self):
        if self.data_list:
            for k in self.data_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        result['dataList'] = []
        if self.data_list is not None:
            for k in self.data_list:
                result['dataList'].append(k.to_map() if k else None)
        if self.message is not None:
            result['message'] = self.message
        if self.page is not None:
            result['page'] = self.page
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.size is not None:
            result['size'] = self.size
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        self.data_list = []
        if m.get('dataList') is not None:
            for k in m.get('dataList'):
                temp_model = ListHistogramsResponseBodyDataList()
                self.data_list.append(temp_model.from_map(k))
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListHistogramsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHistogramsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHistogramsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHistoriesRequest(TeaModel):
    def __init__(
        self,
        batch_id: str = None,
        contact: str = None,
        contact_group: str = None,
        from_: int = None,
        grouping_id: str = None,
        incident_id: str = None,
        max_results: int = None,
        next_token: str = None,
        receiver: str = None,
        severity: str = None,
        status: str = None,
        strategy_name: str = None,
        strategy_uuid: str = None,
        to: int = None,
        workspace: str = None,
    ):
        self.batch_id = batch_id
        self.contact = contact
        self.contact_group = contact_group
        # This parameter is required.
        self.from_ = from_
        self.grouping_id = grouping_id
        self.incident_id = incident_id
        self.max_results = max_results
        self.next_token = next_token
        self.receiver = receiver
        self.severity = severity
        self.status = status
        self.strategy_name = strategy_name
        self.strategy_uuid = strategy_uuid
        # This parameter is required.
        self.to = to
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_id is not None:
            result['batchId'] = self.batch_id
        if self.contact is not None:
            result['contact'] = self.contact
        if self.contact_group is not None:
            result['contactGroup'] = self.contact_group
        if self.from_ is not None:
            result['from'] = self.from_
        if self.grouping_id is not None:
            result['groupingId'] = self.grouping_id
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.receiver is not None:
            result['receiver'] = self.receiver
        if self.severity is not None:
            result['severity'] = self.severity
        if self.status is not None:
            result['status'] = self.status
        if self.strategy_name is not None:
            result['strategyName'] = self.strategy_name
        if self.strategy_uuid is not None:
            result['strategyUuid'] = self.strategy_uuid
        if self.to is not None:
            result['to'] = self.to
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('batchId') is not None:
            self.batch_id = m.get('batchId')
        if m.get('contact') is not None:
            self.contact = m.get('contact')
        if m.get('contactGroup') is not None:
            self.contact_group = m.get('contactGroup')
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('groupingId') is not None:
            self.grouping_id = m.get('groupingId')
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('receiver') is not None:
            self.receiver = m.get('receiver')
        if m.get('severity') is not None:
            self.severity = m.get('severity')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('strategyName') is not None:
            self.strategy_name = m.get('strategyName')
        if m.get('strategyUuid') is not None:
            self.strategy_uuid = m.get('strategyUuid')
        if m.get('to') is not None:
            self.to = m.get('to')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListHistoriesResponseBodyHistoryList(TeaModel):
    def __init__(
        self,
        alert_time: str = None,
        batch_id: str = None,
        contacts: str = None,
        events: str = None,
        grouping_id: str = None,
        grouping_keys: str = None,
        grouping_string: str = None,
        groups: str = None,
        incident_id: str = None,
        notify_result: str = None,
        receivers: str = None,
        severity: str = None,
        status: str = None,
        strategy_name: str = None,
        strategy_uuid: str = None,
        user_id: str = None,
        workspace: str = None,
    ):
        self.alert_time = alert_time
        self.batch_id = batch_id
        self.contacts = contacts
        self.events = events
        self.grouping_id = grouping_id
        self.grouping_keys = grouping_keys
        self.grouping_string = grouping_string
        self.groups = groups
        self.incident_id = incident_id
        self.notify_result = notify_result
        self.receivers = receivers
        self.severity = severity
        self.status = status
        self.strategy_name = strategy_name
        self.strategy_uuid = strategy_uuid
        self.user_id = user_id
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_time is not None:
            result['alertTime'] = self.alert_time
        if self.batch_id is not None:
            result['batchId'] = self.batch_id
        if self.contacts is not None:
            result['contacts'] = self.contacts
        if self.events is not None:
            result['events'] = self.events
        if self.grouping_id is not None:
            result['groupingId'] = self.grouping_id
        if self.grouping_keys is not None:
            result['groupingKeys'] = self.grouping_keys
        if self.grouping_string is not None:
            result['groupingString'] = self.grouping_string
        if self.groups is not None:
            result['groups'] = self.groups
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        if self.notify_result is not None:
            result['notifyResult'] = self.notify_result
        if self.receivers is not None:
            result['receivers'] = self.receivers
        if self.severity is not None:
            result['severity'] = self.severity
        if self.status is not None:
            result['status'] = self.status
        if self.strategy_name is not None:
            result['strategyName'] = self.strategy_name
        if self.strategy_uuid is not None:
            result['strategyUuid'] = self.strategy_uuid
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertTime') is not None:
            self.alert_time = m.get('alertTime')
        if m.get('batchId') is not None:
            self.batch_id = m.get('batchId')
        if m.get('contacts') is not None:
            self.contacts = m.get('contacts')
        if m.get('events') is not None:
            self.events = m.get('events')
        if m.get('groupingId') is not None:
            self.grouping_id = m.get('groupingId')
        if m.get('groupingKeys') is not None:
            self.grouping_keys = m.get('groupingKeys')
        if m.get('groupingString') is not None:
            self.grouping_string = m.get('groupingString')
        if m.get('groups') is not None:
            self.groups = m.get('groups')
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        if m.get('notifyResult') is not None:
            self.notify_result = m.get('notifyResult')
        if m.get('receivers') is not None:
            self.receivers = m.get('receivers')
        if m.get('severity') is not None:
            self.severity = m.get('severity')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('strategyName') is not None:
            self.strategy_name = m.get('strategyName')
        if m.get('strategyUuid') is not None:
            self.strategy_uuid = m.get('strategyUuid')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListHistoriesResponseBody(TeaModel):
    def __init__(
        self,
        history_list: List[ListHistoriesResponseBodyHistoryList] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.history_list = history_list
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id

    def validate(self):
        if self.history_list:
            for k in self.history_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['historyList'] = []
        if self.history_list is not None:
            for k in self.history_list:
                result['historyList'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.history_list = []
        if m.get('historyList') is not None:
            for k in m.get('historyList'):
                temp_model = ListHistoriesResponseBodyHistoryList()
                self.history_list.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListHistoriesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHistoriesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHistoriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHistoryHistogramsRequest(TeaModel):
    def __init__(
        self,
        batch_id: str = None,
        contact: str = None,
        contact_group: str = None,
        from_: int = None,
        grouping_id: str = None,
        incident_id: str = None,
        max_results: int = None,
        next_token: str = None,
        receiver: str = None,
        severity: str = None,
        status: str = None,
        strategy_name: str = None,
        strategy_uuid: str = None,
        to: int = None,
        workspace: str = None,
    ):
        self.batch_id = batch_id
        self.contact = contact
        self.contact_group = contact_group
        # This parameter is required.
        self.from_ = from_
        self.grouping_id = grouping_id
        self.incident_id = incident_id
        self.max_results = max_results
        self.next_token = next_token
        self.receiver = receiver
        self.severity = severity
        self.status = status
        self.strategy_name = strategy_name
        self.strategy_uuid = strategy_uuid
        # This parameter is required.
        self.to = to
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_id is not None:
            result['batchId'] = self.batch_id
        if self.contact is not None:
            result['contact'] = self.contact
        if self.contact_group is not None:
            result['contactGroup'] = self.contact_group
        if self.from_ is not None:
            result['from'] = self.from_
        if self.grouping_id is not None:
            result['groupingId'] = self.grouping_id
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.receiver is not None:
            result['receiver'] = self.receiver
        if self.severity is not None:
            result['severity'] = self.severity
        if self.status is not None:
            result['status'] = self.status
        if self.strategy_name is not None:
            result['strategyName'] = self.strategy_name
        if self.strategy_uuid is not None:
            result['strategyUuid'] = self.strategy_uuid
        if self.to is not None:
            result['to'] = self.to
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('batchId') is not None:
            self.batch_id = m.get('batchId')
        if m.get('contact') is not None:
            self.contact = m.get('contact')
        if m.get('contactGroup') is not None:
            self.contact_group = m.get('contactGroup')
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('groupingId') is not None:
            self.grouping_id = m.get('groupingId')
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('receiver') is not None:
            self.receiver = m.get('receiver')
        if m.get('severity') is not None:
            self.severity = m.get('severity')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('strategyName') is not None:
            self.strategy_name = m.get('strategyName')
        if m.get('strategyUuid') is not None:
            self.strategy_uuid = m.get('strategyUuid')
        if m.get('to') is not None:
            self.to = m.get('to')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListHistoryHistogramsResponseBodyHistogramList(TeaModel):
    def __init__(
        self,
        count: int = None,
        from_: int = None,
        to: int = None,
    ):
        self.count = count
        self.from_ = from_
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['count'] = self.count
        if self.from_ is not None:
            result['from'] = self.from_
        if self.to is not None:
            result['to'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('to') is not None:
            self.to = m.get('to')
        return self


class ListHistoryHistogramsResponseBody(TeaModel):
    def __init__(
        self,
        histogram_list: List[ListHistoryHistogramsResponseBodyHistogramList] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.histogram_list = histogram_list
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id

    def validate(self):
        if self.histogram_list:
            for k in self.histogram_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['histogramList'] = []
        if self.histogram_list is not None:
            for k in self.histogram_list:
                result['histogramList'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.histogram_list = []
        if m.get('histogramList') is not None:
            for k in m.get('histogramList'):
                temp_model = ListHistoryHistogramsResponseBodyHistogramList()
                self.histogram_list.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListHistoryHistogramsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHistoryHistogramsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHistoryHistogramsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInstalledAddonsRequest(TeaModel):
    def __init__(
        self,
        region: str = None,
        region_id: str = None,
    ):
        self.region = region
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListInstalledAddonsResponseBodyDataAddonsDashboards(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        url: str = None,
    ):
        self.description = description
        self.name = name
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListInstalledAddonsResponseBodyDataAddonsEnvironmentsDependencies(TeaModel):
    def __init__(
        self,
        cluster_types: List[str] = None,
        features: Dict[str, bool] = None,
        services: List[str] = None,
    ):
        self.cluster_types = cluster_types
        self.features = features
        self.services = services

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_types is not None:
            result['ClusterTypes'] = self.cluster_types
        if self.features is not None:
            result['Features'] = self.features
        if self.services is not None:
            result['Services'] = self.services
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterTypes') is not None:
            self.cluster_types = m.get('ClusterTypes')
        if m.get('Features') is not None:
            self.features = m.get('Features')
        if m.get('Services') is not None:
            self.services = m.get('Services')
        return self


class ListInstalledAddonsResponseBodyDataAddonsEnvironmentsPoliciesMetricCheckRule(TeaModel):
    def __init__(
        self,
        prom_ql: List[str] = None,
    ):
        self.prom_ql = prom_ql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prom_ql is not None:
            result['PromQL'] = self.prom_ql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PromQL') is not None:
            self.prom_ql = m.get('PromQL')
        return self


class ListInstalledAddonsResponseBodyDataAddonsEnvironmentsPoliciesProtocols(TeaModel):
    def __init__(
        self,
        description: str = None,
        icon: str = None,
        label: str = None,
        name: str = None,
    ):
        self.description = description
        self.icon = icon
        self.label = label
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.label is not None:
            result['Label'] = self.label
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListInstalledAddonsResponseBodyDataAddonsEnvironmentsPolicies(TeaModel):
    def __init__(
        self,
        alert_default_status: str = None,
        default_install: bool = None,
        enable_service_account: bool = None,
        metric_check_rule: ListInstalledAddonsResponseBodyDataAddonsEnvironmentsPoliciesMetricCheckRule = None,
        need_restart_after_integration: bool = None,
        protocols: List[ListInstalledAddonsResponseBodyDataAddonsEnvironmentsPoliciesProtocols] = None,
        target_addon_name: str = None,
    ):
        self.alert_default_status = alert_default_status
        self.default_install = default_install
        self.enable_service_account = enable_service_account
        self.metric_check_rule = metric_check_rule
        self.need_restart_after_integration = need_restart_after_integration
        self.protocols = protocols
        self.target_addon_name = target_addon_name

    def validate(self):
        if self.metric_check_rule:
            self.metric_check_rule.validate()
        if self.protocols:
            for k in self.protocols:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_default_status is not None:
            result['AlertDefaultStatus'] = self.alert_default_status
        if self.default_install is not None:
            result['DefaultInstall'] = self.default_install
        if self.enable_service_account is not None:
            result['EnableServiceAccount'] = self.enable_service_account
        if self.metric_check_rule is not None:
            result['MetricCheckRule'] = self.metric_check_rule.to_map()
        if self.need_restart_after_integration is not None:
            result['NeedRestartAfterIntegration'] = self.need_restart_after_integration
        result['Protocols'] = []
        if self.protocols is not None:
            for k in self.protocols:
                result['Protocols'].append(k.to_map() if k else None)
        if self.target_addon_name is not None:
            result['TargetAddonName'] = self.target_addon_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertDefaultStatus') is not None:
            self.alert_default_status = m.get('AlertDefaultStatus')
        if m.get('DefaultInstall') is not None:
            self.default_install = m.get('DefaultInstall')
        if m.get('EnableServiceAccount') is not None:
            self.enable_service_account = m.get('EnableServiceAccount')
        if m.get('MetricCheckRule') is not None:
            temp_model = ListInstalledAddonsResponseBodyDataAddonsEnvironmentsPoliciesMetricCheckRule()
            self.metric_check_rule = temp_model.from_map(m['MetricCheckRule'])
        if m.get('NeedRestartAfterIntegration') is not None:
            self.need_restart_after_integration = m.get('NeedRestartAfterIntegration')
        self.protocols = []
        if m.get('Protocols') is not None:
            for k in m.get('Protocols'):
                temp_model = ListInstalledAddonsResponseBodyDataAddonsEnvironmentsPoliciesProtocols()
                self.protocols.append(temp_model.from_map(k))
        if m.get('TargetAddonName') is not None:
            self.target_addon_name = m.get('TargetAddonName')
        return self


class ListInstalledAddonsResponseBodyDataAddonsEnvironments(TeaModel):
    def __init__(
        self,
        dependencies: ListInstalledAddonsResponseBodyDataAddonsEnvironmentsDependencies = None,
        description: str = None,
        enable: bool = None,
        label: str = None,
        name: str = None,
        policies: ListInstalledAddonsResponseBodyDataAddonsEnvironmentsPolicies = None,
    ):
        self.dependencies = dependencies
        self.description = description
        self.enable = enable
        self.label = label
        self.name = name
        self.policies = policies

    def validate(self):
        if self.dependencies:
            self.dependencies.validate()
        if self.policies:
            self.policies.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dependencies is not None:
            result['Dependencies'] = self.dependencies.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.label is not None:
            result['Label'] = self.label
        if self.name is not None:
            result['Name'] = self.name
        if self.policies is not None:
            result['Policies'] = self.policies.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dependencies') is not None:
            temp_model = ListInstalledAddonsResponseBodyDataAddonsEnvironmentsDependencies()
            self.dependencies = temp_model.from_map(m['Dependencies'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Policies') is not None:
            temp_model = ListInstalledAddonsResponseBodyDataAddonsEnvironmentsPolicies()
            self.policies = temp_model.from_map(m['Policies'])
        return self


class ListInstalledAddonsResponseBodyDataAddons(TeaModel):
    def __init__(
        self,
        alias: str = None,
        categories: List[str] = None,
        dashboards: List[ListInstalledAddonsResponseBodyDataAddonsDashboards] = None,
        description: str = None,
        environments: List[ListInstalledAddonsResponseBodyDataAddonsEnvironments] = None,
        icon: str = None,
        keywords: List[str] = None,
        language: str = None,
        latest_release_create_time: str = None,
        name: str = None,
        once: bool = None,
        scene: str = None,
        version: str = None,
        weight: str = None,
    ):
        self.alias = alias
        self.categories = categories
        self.dashboards = dashboards
        self.description = description
        self.environments = environments
        self.icon = icon
        self.keywords = keywords
        self.language = language
        self.latest_release_create_time = latest_release_create_time
        self.name = name
        self.once = once
        self.scene = scene
        self.version = version
        self.weight = weight

    def validate(self):
        if self.dashboards:
            for k in self.dashboards:
                if k:
                    k.validate()
        if self.environments:
            for k in self.environments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.categories is not None:
            result['Categories'] = self.categories
        result['Dashboards'] = []
        if self.dashboards is not None:
            for k in self.dashboards:
                result['Dashboards'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        result['Environments'] = []
        if self.environments is not None:
            for k in self.environments:
                result['Environments'].append(k.to_map() if k else None)
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.keywords is not None:
            result['Keywords'] = self.keywords
        if self.language is not None:
            result['Language'] = self.language
        if self.latest_release_create_time is not None:
            result['LatestReleaseCreateTime'] = self.latest_release_create_time
        if self.name is not None:
            result['Name'] = self.name
        if self.once is not None:
            result['Once'] = self.once
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.version is not None:
            result['Version'] = self.version
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Categories') is not None:
            self.categories = m.get('Categories')
        self.dashboards = []
        if m.get('Dashboards') is not None:
            for k in m.get('Dashboards'):
                temp_model = ListInstalledAddonsResponseBodyDataAddonsDashboards()
                self.dashboards.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.environments = []
        if m.get('Environments') is not None:
            for k in m.get('Environments'):
                temp_model = ListInstalledAddonsResponseBodyDataAddonsEnvironments()
                self.environments.append(temp_model.from_map(k))
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Keywords') is not None:
            self.keywords = m.get('Keywords')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('LatestReleaseCreateTime') is not None:
            self.latest_release_create_time = m.get('LatestReleaseCreateTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Once') is not None:
            self.once = m.get('Once')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class ListInstalledAddonsResponseBodyData(TeaModel):
    def __init__(
        self,
        addons: List[ListInstalledAddonsResponseBodyDataAddons] = None,
        total: int = None,
    ):
        self.addons = addons
        self.total = total

    def validate(self):
        if self.addons:
            for k in self.addons:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Addons'] = []
        if self.addons is not None:
            for k in self.addons:
                result['Addons'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addons = []
        if m.get('Addons') is not None:
            for k in m.get('Addons'):
                temp_model = ListInstalledAddonsResponseBodyDataAddons()
                self.addons.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListInstalledAddonsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListInstalledAddonsResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListInstalledAddonsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListInstalledAddonsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInstalledAddonsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInstalledAddonsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInstallingAddonReleasesRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
    ):
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListInstallingAddonReleasesResponseBodyDataReleasesConditions(TeaModel):
    def __init__(
        self,
        first_transition_time: str = None,
        last_transition_time: str = None,
        message: str = None,
        reason: str = None,
        status: str = None,
        type: str = None,
    ):
        self.first_transition_time = first_transition_time
        self.last_transition_time = last_transition_time
        self.message = message
        self.reason = reason
        self.status = status
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_transition_time is not None:
            result['FirstTransitionTime'] = self.first_transition_time
        if self.last_transition_time is not None:
            result['LastTransitionTime'] = self.last_transition_time
        if self.message is not None:
            result['Message'] = self.message
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FirstTransitionTime') is not None:
            self.first_transition_time = m.get('FirstTransitionTime')
        if m.get('LastTransitionTime') is not None:
            self.last_transition_time = m.get('LastTransitionTime')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListInstallingAddonReleasesResponseBodyDataReleases(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        alert_rule_count: int = None,
        conditions: List[ListInstallingAddonReleasesResponseBodyDataReleasesConditions] = None,
        create_time: str = None,
        dashboard_count: int = None,
        environment_id: str = None,
        exporter_count: int = None,
        have_config: bool = None,
        install_user_id: str = None,
        language: str = None,
        region_id: str = None,
        release_id: str = None,
        release_name: str = None,
        scene: str = None,
        status: str = None,
        update_time: str = None,
        user_id: str = None,
        version: str = None,
    ):
        self.addon_name = addon_name
        self.alert_rule_count = alert_rule_count
        self.conditions = conditions
        self.create_time = create_time
        self.dashboard_count = dashboard_count
        self.environment_id = environment_id
        self.exporter_count = exporter_count
        self.have_config = have_config
        self.install_user_id = install_user_id
        self.language = language
        self.region_id = region_id
        self.release_id = release_id
        self.release_name = release_name
        self.scene = scene
        self.status = status
        self.update_time = update_time
        self.user_id = user_id
        self.version = version

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.alert_rule_count is not None:
            result['AlertRuleCount'] = self.alert_rule_count
        result['Conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['Conditions'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dashboard_count is not None:
            result['DashboardCount'] = self.dashboard_count
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.exporter_count is not None:
            result['ExporterCount'] = self.exporter_count
        if self.have_config is not None:
            result['HaveConfig'] = self.have_config
        if self.install_user_id is not None:
            result['InstallUserId'] = self.install_user_id
        if self.language is not None:
            result['Language'] = self.language
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_id is not None:
            result['ReleaseId'] = self.release_id
        if self.release_name is not None:
            result['ReleaseName'] = self.release_name
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.status is not None:
            result['Status'] = self.status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('AlertRuleCount') is not None:
            self.alert_rule_count = m.get('AlertRuleCount')
        self.conditions = []
        if m.get('Conditions') is not None:
            for k in m.get('Conditions'):
                temp_model = ListInstallingAddonReleasesResponseBodyDataReleasesConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DashboardCount') is not None:
            self.dashboard_count = m.get('DashboardCount')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('ExporterCount') is not None:
            self.exporter_count = m.get('ExporterCount')
        if m.get('HaveConfig') is not None:
            self.have_config = m.get('HaveConfig')
        if m.get('InstallUserId') is not None:
            self.install_user_id = m.get('InstallUserId')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseId') is not None:
            self.release_id = m.get('ReleaseId')
        if m.get('ReleaseName') is not None:
            self.release_name = m.get('ReleaseName')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListInstallingAddonReleasesResponseBodyData(TeaModel):
    def __init__(
        self,
        releases: List[ListInstallingAddonReleasesResponseBodyDataReleases] = None,
        total: int = None,
    ):
        self.releases = releases
        self.total = total

    def validate(self):
        if self.releases:
            for k in self.releases:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Releases'] = []
        if self.releases is not None:
            for k in self.releases:
                result['Releases'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.releases = []
        if m.get('Releases') is not None:
            for k in m.get('Releases'):
                temp_model = ListInstallingAddonReleasesResponseBodyDataReleases()
                self.releases.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListInstallingAddonReleasesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListInstallingAddonReleasesResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListInstallingAddonReleasesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListInstallingAddonReleasesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInstallingAddonReleasesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInstallingAddonReleasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntegrationPoliciesRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListIntegrationPoliciesRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        entity_group_ids: str = None,
        filter_region_ids: str = None,
        max_results: int = None,
        next_token: str = None,
        policy_id: str = None,
        policy_name: str = None,
        policy_type: str = None,
        query: str = None,
        resource_group_id: str = None,
        tag: List[ListIntegrationPoliciesRequestTag] = None,
        workspace: str = None,
    ):
        self.addon_name = addon_name
        self.entity_group_ids = entity_group_ids
        self.filter_region_ids = filter_region_ids
        self.max_results = max_results
        self.next_token = next_token
        self.policy_id = policy_id
        self.policy_name = policy_name
        self.policy_type = policy_type
        self.query = query
        self.resource_group_id = resource_group_id
        self.tag = tag
        self.workspace = workspace

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.entity_group_ids is not None:
            result['entityGroupIds'] = self.entity_group_ids
        if self.filter_region_ids is not None:
            result['filterRegionIds'] = self.filter_region_ids
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.policy_id is not None:
            result['policyId'] = self.policy_id
        if self.policy_name is not None:
            result['policyName'] = self.policy_name
        if self.policy_type is not None:
            result['policyType'] = self.policy_type
        if self.query is not None:
            result['query'] = self.query
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        result['tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['tag'].append(k.to_map() if k else None)
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('entityGroupIds') is not None:
            self.entity_group_ids = m.get('entityGroupIds')
        if m.get('filterRegionIds') is not None:
            self.filter_region_ids = m.get('filterRegionIds')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('policyId') is not None:
            self.policy_id = m.get('policyId')
        if m.get('policyName') is not None:
            self.policy_name = m.get('policyName')
        if m.get('policyType') is not None:
            self.policy_type = m.get('policyType')
        if m.get('query') is not None:
            self.query = m.get('query')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        self.tag = []
        if m.get('tag') is not None:
            for k in m.get('tag'):
                temp_model = ListIntegrationPoliciesRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListIntegrationPoliciesShrinkRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        entity_group_ids: str = None,
        filter_region_ids: str = None,
        max_results: int = None,
        next_token: str = None,
        policy_id: str = None,
        policy_name: str = None,
        policy_type: str = None,
        query: str = None,
        resource_group_id: str = None,
        tag_shrink: str = None,
        workspace: str = None,
    ):
        self.addon_name = addon_name
        self.entity_group_ids = entity_group_ids
        self.filter_region_ids = filter_region_ids
        self.max_results = max_results
        self.next_token = next_token
        self.policy_id = policy_id
        self.policy_name = policy_name
        self.policy_type = policy_type
        self.query = query
        self.resource_group_id = resource_group_id
        self.tag_shrink = tag_shrink
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.entity_group_ids is not None:
            result['entityGroupIds'] = self.entity_group_ids
        if self.filter_region_ids is not None:
            result['filterRegionIds'] = self.filter_region_ids
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.policy_id is not None:
            result['policyId'] = self.policy_id
        if self.policy_name is not None:
            result['policyName'] = self.policy_name
        if self.policy_type is not None:
            result['policyType'] = self.policy_type
        if self.query is not None:
            result['query'] = self.query
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.tag_shrink is not None:
            result['tag'] = self.tag_shrink
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('entityGroupIds') is not None:
            self.entity_group_ids = m.get('entityGroupIds')
        if m.get('filterRegionIds') is not None:
            self.filter_region_ids = m.get('filterRegionIds')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('policyId') is not None:
            self.policy_id = m.get('policyId')
        if m.get('policyName') is not None:
            self.policy_name = m.get('policyName')
        if m.get('policyType') is not None:
            self.policy_type = m.get('policyType')
        if m.get('query') is not None:
            self.query = m.get('query')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('tag') is not None:
            self.tag_shrink = m.get('tag')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListIntegrationPoliciesResponseBodyPoliciesBindResource(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_type: str = None,
        vpc_cidr: str = None,
        vpc_id: str = None,
    ):
        self.cluster_id = cluster_id
        self.cluster_type = cluster_type
        self.vpc_cidr = vpc_cidr
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['clusterId'] = self.cluster_id
        if self.cluster_type is not None:
            result['clusterType'] = self.cluster_type
        if self.vpc_cidr is not None:
            result['vpcCidr'] = self.vpc_cidr
        if self.vpc_id is not None:
            result['vpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterId') is not None:
            self.cluster_id = m.get('clusterId')
        if m.get('clusterType') is not None:
            self.cluster_type = m.get('clusterType')
        if m.get('vpcCidr') is not None:
            self.vpc_cidr = m.get('vpcCidr')
        if m.get('vpcId') is not None:
            self.vpc_id = m.get('vpcId')
        return self


class ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRulesAnnotations(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRulesFieldRules(TeaModel):
    def __init__(
        self,
        field_key: str = None,
        field_values: List[str] = None,
        op: str = None,
    ):
        self.field_key = field_key
        self.field_values = field_values
        self.op = op

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_key is not None:
            result['fieldKey'] = self.field_key
        if self.field_values is not None:
            result['fieldValues'] = self.field_values
        if self.op is not None:
            result['op'] = self.op
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldKey') is not None:
            self.field_key = m.get('fieldKey')
        if m.get('fieldValues') is not None:
            self.field_values = m.get('fieldValues')
        if m.get('op') is not None:
            self.op = m.get('op')
        return self


class ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRulesIpMatchRule(TeaModel):
    def __init__(
        self,
        ip_cidr: str = None,
        ip_field_key: str = None,
    ):
        self.ip_cidr = ip_cidr
        self.ip_field_key = ip_field_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_cidr is not None:
            result['ipCidr'] = self.ip_cidr
        if self.ip_field_key is not None:
            result['ipFieldKey'] = self.ip_field_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ipCidr') is not None:
            self.ip_cidr = m.get('ipCidr')
        if m.get('ipFieldKey') is not None:
            self.ip_field_key = m.get('ipFieldKey')
        return self


class ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRulesLabels(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRulesTags(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRules(TeaModel):
    def __init__(
        self,
        annotations: List[ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRulesAnnotations] = None,
        entity_types: List[str] = None,
        field_rules: List[ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRulesFieldRules] = None,
        instance_ids: List[str] = None,
        ip_match_rule: ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRulesIpMatchRule = None,
        labels: List[ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRulesLabels] = None,
        region_ids: List[str] = None,
        resource_group_id: str = None,
        tags: List[ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRulesTags] = None,
    ):
        self.annotations = annotations
        self.entity_types = entity_types
        self.field_rules = field_rules
        self.instance_ids = instance_ids
        self.ip_match_rule = ip_match_rule
        self.labels = labels
        self.region_ids = region_ids
        self.resource_group_id = resource_group_id
        self.tags = tags

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.field_rules:
            for k in self.field_rules:
                if k:
                    k.validate()
        if self.ip_match_rule:
            self.ip_match_rule.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        if self.entity_types is not None:
            result['entityTypes'] = self.entity_types
        result['fieldRules'] = []
        if self.field_rules is not None:
            for k in self.field_rules:
                result['fieldRules'].append(k.to_map() if k else None)
        if self.instance_ids is not None:
            result['instanceIds'] = self.instance_ids
        if self.ip_match_rule is not None:
            result['ipMatchRule'] = self.ip_match_rule.to_map()
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.region_ids is not None:
            result['regionIds'] = self.region_ids
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRulesAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('entityTypes') is not None:
            self.entity_types = m.get('entityTypes')
        self.field_rules = []
        if m.get('fieldRules') is not None:
            for k in m.get('fieldRules'):
                temp_model = ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRulesFieldRules()
                self.field_rules.append(temp_model.from_map(k))
        if m.get('instanceIds') is not None:
            self.instance_ids = m.get('instanceIds')
        if m.get('ipMatchRule') is not None:
            temp_model = ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRulesIpMatchRule()
            self.ip_match_rule = temp_model.from_map(m['ipMatchRule'])
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRulesLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('regionIds') is not None:
            self.region_ids = m.get('regionIds')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRulesTags()
                self.tags.append(temp_model.from_map(k))
        return self


class ListIntegrationPoliciesResponseBodyPoliciesEntityGroup(TeaModel):
    def __init__(
        self,
        description: str = None,
        entity_group_id: str = None,
        entity_group_name: str = None,
        entity_rules: ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRules = None,
        query: str = None,
        region_id: str = None,
        user_id: str = None,
        workspace: str = None,
    ):
        self.description = description
        self.entity_group_id = entity_group_id
        self.entity_group_name = entity_group_name
        self.entity_rules = entity_rules
        self.query = query
        self.region_id = region_id
        self.user_id = user_id
        self.workspace = workspace

    def validate(self):
        if self.entity_rules:
            self.entity_rules.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.entity_group_id is not None:
            result['entityGroupId'] = self.entity_group_id
        if self.entity_group_name is not None:
            result['entityGroupName'] = self.entity_group_name
        if self.entity_rules is not None:
            result['entityRules'] = self.entity_rules.to_map()
        if self.query is not None:
            result['query'] = self.query
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('entityGroupId') is not None:
            self.entity_group_id = m.get('entityGroupId')
        if m.get('entityGroupName') is not None:
            self.entity_group_name = m.get('entityGroupName')
        if m.get('entityRules') is not None:
            temp_model = ListIntegrationPoliciesResponseBodyPoliciesEntityGroupEntityRules()
            self.entity_rules = temp_model.from_map(m['entityRules'])
        if m.get('query') is not None:
            self.query = m.get('query')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListIntegrationPoliciesResponseBodyPoliciesManagedInfo(TeaModel):
    def __init__(
        self,
        security_group_id: str = None,
        vswitch_id: str = None,
    ):
        self.security_group_id = security_group_id
        self.vswitch_id = vswitch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group_id is not None:
            result['securityGroupId'] = self.security_group_id
        if self.vswitch_id is not None:
            result['vswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('securityGroupId') is not None:
            self.security_group_id = m.get('securityGroupId')
        if m.get('vswitchId') is not None:
            self.vswitch_id = m.get('vswitchId')
        return self


class ListIntegrationPoliciesResponseBodyPoliciesSubAddonRelease(TeaModel):
    def __init__(
        self,
        ready: int = None,
        total: int = None,
    ):
        self.ready = ready
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ready is not None:
            result['ready'] = self.ready
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ready') is not None:
            self.ready = m.get('ready')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListIntegrationPoliciesResponseBodyPoliciesTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListIntegrationPoliciesResponseBodyPolicies(TeaModel):
    def __init__(
        self,
        bind_resource: ListIntegrationPoliciesResponseBodyPoliciesBindResource = None,
        entity_group: ListIntegrationPoliciesResponseBodyPoliciesEntityGroup = None,
        managed_info: ListIntegrationPoliciesResponseBodyPoliciesManagedInfo = None,
        policy_id: str = None,
        policy_name: str = None,
        policy_type: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        sub_addon_release: ListIntegrationPoliciesResponseBodyPoliciesSubAddonRelease = None,
        tags: List[ListIntegrationPoliciesResponseBodyPoliciesTags] = None,
        user_id: str = None,
        workspace: str = None,
    ):
        self.bind_resource = bind_resource
        self.entity_group = entity_group
        self.managed_info = managed_info
        self.policy_id = policy_id
        self.policy_name = policy_name
        self.policy_type = policy_type
        self.region_id = region_id
        self.resource_group_id = resource_group_id
        self.sub_addon_release = sub_addon_release
        self.tags = tags
        self.user_id = user_id
        self.workspace = workspace

    def validate(self):
        if self.bind_resource:
            self.bind_resource.validate()
        if self.entity_group:
            self.entity_group.validate()
        if self.managed_info:
            self.managed_info.validate()
        if self.sub_addon_release:
            self.sub_addon_release.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_resource is not None:
            result['bindResource'] = self.bind_resource.to_map()
        if self.entity_group is not None:
            result['entityGroup'] = self.entity_group.to_map()
        if self.managed_info is not None:
            result['managedInfo'] = self.managed_info.to_map()
        if self.policy_id is not None:
            result['policyId'] = self.policy_id
        if self.policy_name is not None:
            result['policyName'] = self.policy_name
        if self.policy_type is not None:
            result['policyType'] = self.policy_type
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.sub_addon_release is not None:
            result['subAddonRelease'] = self.sub_addon_release.to_map()
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bindResource') is not None:
            temp_model = ListIntegrationPoliciesResponseBodyPoliciesBindResource()
            self.bind_resource = temp_model.from_map(m['bindResource'])
        if m.get('entityGroup') is not None:
            temp_model = ListIntegrationPoliciesResponseBodyPoliciesEntityGroup()
            self.entity_group = temp_model.from_map(m['entityGroup'])
        if m.get('managedInfo') is not None:
            temp_model = ListIntegrationPoliciesResponseBodyPoliciesManagedInfo()
            self.managed_info = temp_model.from_map(m['managedInfo'])
        if m.get('policyId') is not None:
            self.policy_id = m.get('policyId')
        if m.get('policyName') is not None:
            self.policy_name = m.get('policyName')
        if m.get('policyType') is not None:
            self.policy_type = m.get('policyType')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('subAddonRelease') is not None:
            temp_model = ListIntegrationPoliciesResponseBodyPoliciesSubAddonRelease()
            self.sub_addon_release = temp_model.from_map(m['subAddonRelease'])
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = ListIntegrationPoliciesResponseBodyPoliciesTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListIntegrationPoliciesResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        policies: List[ListIntegrationPoliciesResponseBodyPolicies] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.policies = policies
        # Id of the request
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.policies:
            for k in self.policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['policies'] = []
        if self.policies is not None:
            for k in self.policies:
                result['policies'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.policies = []
        if m.get('policies') is not None:
            for k in m.get('policies'):
                temp_model = ListIntegrationPoliciesResponseBodyPolicies()
                self.policies.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListIntegrationPoliciesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntegrationPoliciesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntegrationPoliciesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntegrationPolicyAddonsResponseBodyAddonsDashboards(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        url: str = None,
    ):
        self.description = description
        self.name = name
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class ListIntegrationPolicyAddonsResponseBodyAddonsEnvironmentsDependencies(TeaModel):
    def __init__(
        self,
        cluster_types: List[str] = None,
        features: Dict[str, bool] = None,
        services: List[str] = None,
    ):
        self.cluster_types = cluster_types
        self.features = features
        self.services = services

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_types is not None:
            result['clusterTypes'] = self.cluster_types
        if self.features is not None:
            result['features'] = self.features
        if self.services is not None:
            result['services'] = self.services
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterTypes') is not None:
            self.cluster_types = m.get('clusterTypes')
        if m.get('features') is not None:
            self.features = m.get('features')
        if m.get('services') is not None:
            self.services = m.get('services')
        return self


class ListIntegrationPolicyAddonsResponseBodyAddonsEnvironmentsPoliciesMetricCheckRule(TeaModel):
    def __init__(
        self,
        prom_ql: List[str] = None,
    ):
        self.prom_ql = prom_ql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prom_ql is not None:
            result['promQl'] = self.prom_ql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('promQl') is not None:
            self.prom_ql = m.get('promQl')
        return self


class ListIntegrationPolicyAddonsResponseBodyAddonsEnvironmentsPoliciesProtocols(TeaModel):
    def __init__(
        self,
        description: str = None,
        icon: str = None,
        label: str = None,
        name: str = None,
    ):
        self.description = description
        self.icon = icon
        self.label = label
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.icon is not None:
            result['icon'] = self.icon
        if self.label is not None:
            result['label'] = self.label
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListIntegrationPolicyAddonsResponseBodyAddonsEnvironmentsPolicies(TeaModel):
    def __init__(
        self,
        alert_default_status: str = None,
        default_install: bool = None,
        enable_service_account: bool = None,
        metric_check_rule: ListIntegrationPolicyAddonsResponseBodyAddonsEnvironmentsPoliciesMetricCheckRule = None,
        need_restart_after_integration: bool = None,
        protocols: List[ListIntegrationPolicyAddonsResponseBodyAddonsEnvironmentsPoliciesProtocols] = None,
        target_addon_name: str = None,
    ):
        self.alert_default_status = alert_default_status
        self.default_install = default_install
        self.enable_service_account = enable_service_account
        self.metric_check_rule = metric_check_rule
        self.need_restart_after_integration = need_restart_after_integration
        self.protocols = protocols
        self.target_addon_name = target_addon_name

    def validate(self):
        if self.metric_check_rule:
            self.metric_check_rule.validate()
        if self.protocols:
            for k in self.protocols:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_default_status is not None:
            result['alertDefaultStatus'] = self.alert_default_status
        if self.default_install is not None:
            result['defaultInstall'] = self.default_install
        if self.enable_service_account is not None:
            result['enableServiceAccount'] = self.enable_service_account
        if self.metric_check_rule is not None:
            result['metricCheckRule'] = self.metric_check_rule.to_map()
        if self.need_restart_after_integration is not None:
            result['needRestartAfterIntegration'] = self.need_restart_after_integration
        result['protocols'] = []
        if self.protocols is not None:
            for k in self.protocols:
                result['protocols'].append(k.to_map() if k else None)
        if self.target_addon_name is not None:
            result['targetAddonName'] = self.target_addon_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertDefaultStatus') is not None:
            self.alert_default_status = m.get('alertDefaultStatus')
        if m.get('defaultInstall') is not None:
            self.default_install = m.get('defaultInstall')
        if m.get('enableServiceAccount') is not None:
            self.enable_service_account = m.get('enableServiceAccount')
        if m.get('metricCheckRule') is not None:
            temp_model = ListIntegrationPolicyAddonsResponseBodyAddonsEnvironmentsPoliciesMetricCheckRule()
            self.metric_check_rule = temp_model.from_map(m['metricCheckRule'])
        if m.get('needRestartAfterIntegration') is not None:
            self.need_restart_after_integration = m.get('needRestartAfterIntegration')
        self.protocols = []
        if m.get('protocols') is not None:
            for k in m.get('protocols'):
                temp_model = ListIntegrationPolicyAddonsResponseBodyAddonsEnvironmentsPoliciesProtocols()
                self.protocols.append(temp_model.from_map(k))
        if m.get('targetAddonName') is not None:
            self.target_addon_name = m.get('targetAddonName')
        return self


class ListIntegrationPolicyAddonsResponseBodyAddonsEnvironments(TeaModel):
    def __init__(
        self,
        dependencies: ListIntegrationPolicyAddonsResponseBodyAddonsEnvironmentsDependencies = None,
        description: str = None,
        enable: bool = None,
        label: str = None,
        name: str = None,
        policies: ListIntegrationPolicyAddonsResponseBodyAddonsEnvironmentsPolicies = None,
    ):
        self.dependencies = dependencies
        self.description = description
        self.enable = enable
        self.label = label
        self.name = name
        self.policies = policies

    def validate(self):
        if self.dependencies:
            self.dependencies.validate()
        if self.policies:
            self.policies.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dependencies is not None:
            result['dependencies'] = self.dependencies.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.enable is not None:
            result['enable'] = self.enable
        if self.label is not None:
            result['label'] = self.label
        if self.name is not None:
            result['name'] = self.name
        if self.policies is not None:
            result['policies'] = self.policies.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dependencies') is not None:
            temp_model = ListIntegrationPolicyAddonsResponseBodyAddonsEnvironmentsDependencies()
            self.dependencies = temp_model.from_map(m['dependencies'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('policies') is not None:
            temp_model = ListIntegrationPolicyAddonsResponseBodyAddonsEnvironmentsPolicies()
            self.policies = temp_model.from_map(m['policies'])
        return self


class ListIntegrationPolicyAddonsResponseBodyAddons(TeaModel):
    def __init__(
        self,
        alias: str = None,
        categories: List[str] = None,
        dashboards: List[ListIntegrationPolicyAddonsResponseBodyAddonsDashboards] = None,
        description: str = None,
        environments: List[ListIntegrationPolicyAddonsResponseBodyAddonsEnvironments] = None,
        icon: str = None,
        keywords: List[str] = None,
        language: str = None,
        latest_release_create_time: str = None,
        name: str = None,
        once: bool = None,
        scene: str = None,
        version: str = None,
        weight: int = None,
    ):
        self.alias = alias
        self.categories = categories
        self.dashboards = dashboards
        self.description = description
        self.environments = environments
        self.icon = icon
        self.keywords = keywords
        self.language = language
        self.latest_release_create_time = latest_release_create_time
        self.name = name
        self.once = once
        self.scene = scene
        self.version = version
        self.weight = weight

    def validate(self):
        if self.dashboards:
            for k in self.dashboards:
                if k:
                    k.validate()
        if self.environments:
            for k in self.environments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['alias'] = self.alias
        if self.categories is not None:
            result['categories'] = self.categories
        result['dashboards'] = []
        if self.dashboards is not None:
            for k in self.dashboards:
                result['dashboards'].append(k.to_map() if k else None)
        if self.description is not None:
            result['description'] = self.description
        result['environments'] = []
        if self.environments is not None:
            for k in self.environments:
                result['environments'].append(k.to_map() if k else None)
        if self.icon is not None:
            result['icon'] = self.icon
        if self.keywords is not None:
            result['keywords'] = self.keywords
        if self.language is not None:
            result['language'] = self.language
        if self.latest_release_create_time is not None:
            result['latestReleaseCreateTime'] = self.latest_release_create_time
        if self.name is not None:
            result['name'] = self.name
        if self.once is not None:
            result['once'] = self.once
        if self.scene is not None:
            result['scene'] = self.scene
        if self.version is not None:
            result['version'] = self.version
        if self.weight is not None:
            result['weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alias') is not None:
            self.alias = m.get('alias')
        if m.get('categories') is not None:
            self.categories = m.get('categories')
        self.dashboards = []
        if m.get('dashboards') is not None:
            for k in m.get('dashboards'):
                temp_model = ListIntegrationPolicyAddonsResponseBodyAddonsDashboards()
                self.dashboards.append(temp_model.from_map(k))
        if m.get('description') is not None:
            self.description = m.get('description')
        self.environments = []
        if m.get('environments') is not None:
            for k in m.get('environments'):
                temp_model = ListIntegrationPolicyAddonsResponseBodyAddonsEnvironments()
                self.environments.append(temp_model.from_map(k))
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('keywords') is not None:
            self.keywords = m.get('keywords')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('latestReleaseCreateTime') is not None:
            self.latest_release_create_time = m.get('latestReleaseCreateTime')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('once') is not None:
            self.once = m.get('once')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        return self


class ListIntegrationPolicyAddonsResponseBody(TeaModel):
    def __init__(
        self,
        addons: List[ListIntegrationPolicyAddonsResponseBodyAddons] = None,
        request_id: str = None,
        total: int = None,
    ):
        self.addons = addons
        self.request_id = request_id
        self.total = total

    def validate(self):
        if self.addons:
            for k in self.addons:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['addons'] = []
        if self.addons is not None:
            for k in self.addons:
                result['addons'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addons = []
        if m.get('addons') is not None:
            for k in m.get('addons'):
                temp_model = ListIntegrationPolicyAddonsResponseBodyAddons()
                self.addons.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListIntegrationPolicyAddonsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntegrationPolicyAddonsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntegrationPolicyAddonsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntegrationPolicyAlertRulesRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        scene: str = None,
    ):
        self.addon_name = addon_name
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.scene is not None:
            result['scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        return self


class ListIntegrationPolicyAlertRulesResponseBodyRules(TeaModel):
    def __init__(
        self,
        alert_id: int = None,
        group: str = None,
        name: str = None,
        uuid: str = None,
    ):
        self.alert_id = alert_id
        self.group = group
        self.name = name
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['alertId'] = self.alert_id
        if self.group is not None:
            result['group'] = self.group
        if self.name is not None:
            result['name'] = self.name
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertId') is not None:
            self.alert_id = m.get('alertId')
        if m.get('group') is not None:
            self.group = m.get('group')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class ListIntegrationPolicyAlertRulesResponseBody(TeaModel):
    def __init__(
        self,
        groups: List[str] = None,
        request_id: str = None,
        rules: List[ListIntegrationPolicyAlertRulesResponseBodyRules] = None,
        total: int = None,
    ):
        self.groups = groups
        # Id of the request
        self.request_id = request_id
        self.rules = rules
        self.total = total

    def validate(self):
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.groups is not None:
            result['groups'] = self.groups
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['rules'].append(k.to_map() if k else None)
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('groups') is not None:
            self.groups = m.get('groups')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.rules = []
        if m.get('rules') is not None:
            for k in m.get('rules'):
                temp_model = ListIntegrationPolicyAlertRulesResponseBodyRules()
                self.rules.append(temp_model.from_map(k))
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListIntegrationPolicyAlertRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntegrationPolicyAlertRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntegrationPolicyAlertRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntegrationPolicyCollectorsRequest(TeaModel):
    def __init__(
        self,
        addon_release_name: str = None,
        collector_type: str = None,
        language: str = None,
    ):
        self.addon_release_name = addon_release_name
        # This parameter is required.
        self.collector_type = collector_type
        self.language = language

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_release_name is not None:
            result['addonReleaseName'] = self.addon_release_name
        if self.collector_type is not None:
            result['collectorType'] = self.collector_type
        if self.language is not None:
            result['language'] = self.language
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonReleaseName') is not None:
            self.addon_release_name = m.get('addonReleaseName')
        if m.get('collectorType') is not None:
            self.collector_type = m.get('collectorType')
        if m.get('language') is not None:
            self.language = m.get('language')
        return self


class ListIntegrationPolicyCollectorsResponseBodyCollectorsConditions(TeaModel):
    def __init__(
        self,
        first_transition_time: str = None,
        last_transition_time: str = None,
        message: str = None,
        reason: str = None,
        status: str = None,
        type: str = None,
    ):
        self.first_transition_time = first_transition_time
        self.last_transition_time = last_transition_time
        self.message = message
        self.reason = reason
        self.status = status
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_transition_time is not None:
            result['firstTransitionTime'] = self.first_transition_time
        if self.last_transition_time is not None:
            result['lastTransitionTime'] = self.last_transition_time
        if self.message is not None:
            result['message'] = self.message
        if self.reason is not None:
            result['reason'] = self.reason
        if self.status is not None:
            result['status'] = self.status
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('firstTransitionTime') is not None:
            self.first_transition_time = m.get('firstTransitionTime')
        if m.get('lastTransitionTime') is not None:
            self.last_transition_time = m.get('lastTransitionTime')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListIntegrationPolicyCollectorsResponseBodyCollectorsWorkloadsManagedInfo(TeaModel):
    def __init__(
        self,
        security_group_id: str = None,
        vswitch_id: str = None,
    ):
        self.security_group_id = security_group_id
        self.vswitch_id = vswitch_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group_id is not None:
            result['securityGroupId'] = self.security_group_id
        if self.vswitch_id is not None:
            result['vswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('securityGroupId') is not None:
            self.security_group_id = m.get('securityGroupId')
        if m.get('vswitchId') is not None:
            self.vswitch_id = m.get('vswitchId')
        return self


class ListIntegrationPolicyCollectorsResponseBodyCollectorsWorkloads(TeaModel):
    def __init__(
        self,
        host_ip: str = None,
        ip: str = None,
        managed: bool = None,
        managed_info: ListIntegrationPolicyCollectorsResponseBodyCollectorsWorkloadsManagedInfo = None,
        message: str = None,
        name: str = None,
        namespace: str = None,
        owner_reference_kind: str = None,
        owner_reference_name: str = None,
        start_time: str = None,
        status: str = None,
        version: str = None,
    ):
        self.host_ip = host_ip
        self.ip = ip
        self.managed = managed
        self.managed_info = managed_info
        self.message = message
        self.name = name
        self.namespace = namespace
        self.owner_reference_kind = owner_reference_kind
        self.owner_reference_name = owner_reference_name
        self.start_time = start_time
        self.status = status
        self.version = version

    def validate(self):
        if self.managed_info:
            self.managed_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host_ip is not None:
            result['hostIp'] = self.host_ip
        if self.ip is not None:
            result['ip'] = self.ip
        if self.managed is not None:
            result['managed'] = self.managed
        if self.managed_info is not None:
            result['managedInfo'] = self.managed_info.to_map()
        if self.message is not None:
            result['message'] = self.message
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.owner_reference_kind is not None:
            result['ownerReferenceKind'] = self.owner_reference_kind
        if self.owner_reference_name is not None:
            result['ownerReferenceName'] = self.owner_reference_name
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.status is not None:
            result['status'] = self.status
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hostIp') is not None:
            self.host_ip = m.get('hostIp')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('managed') is not None:
            self.managed = m.get('managed')
        if m.get('managedInfo') is not None:
            temp_model = ListIntegrationPolicyCollectorsResponseBodyCollectorsWorkloadsManagedInfo()
            self.managed_info = temp_model.from_map(m['managedInfo'])
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('ownerReferenceKind') is not None:
            self.owner_reference_kind = m.get('ownerReferenceKind')
        if m.get('ownerReferenceName') is not None:
            self.owner_reference_name = m.get('ownerReferenceName')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class ListIntegrationPolicyCollectorsResponseBodyCollectors(TeaModel):
    def __init__(
        self,
        addon_meta: AddonMeta = None,
        collector_name: str = None,
        collector_type: str = None,
        conditions: List[ListIntegrationPolicyCollectorsResponseBodyCollectorsConditions] = None,
        managed: bool = None,
        next_version: str = None,
        release_name: str = None,
        release_values: str = None,
        state: str = None,
        version: str = None,
        workloads: List[ListIntegrationPolicyCollectorsResponseBodyCollectorsWorkloads] = None,
    ):
        self.addon_meta = addon_meta
        self.collector_name = collector_name
        self.collector_type = collector_type
        self.conditions = conditions
        self.managed = managed
        self.next_version = next_version
        self.release_name = release_name
        self.release_values = release_values
        self.state = state
        self.version = version
        self.workloads = workloads

    def validate(self):
        if self.addon_meta:
            self.addon_meta.validate()
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()
        if self.workloads:
            for k in self.workloads:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_meta is not None:
            result['addonMeta'] = self.addon_meta.to_map()
        if self.collector_name is not None:
            result['collectorName'] = self.collector_name
        if self.collector_type is not None:
            result['collectorType'] = self.collector_type
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.managed is not None:
            result['managed'] = self.managed
        if self.next_version is not None:
            result['nextVersion'] = self.next_version
        if self.release_name is not None:
            result['releaseName'] = self.release_name
        if self.release_values is not None:
            result['releaseValues'] = self.release_values
        if self.state is not None:
            result['state'] = self.state
        if self.version is not None:
            result['version'] = self.version
        result['workloads'] = []
        if self.workloads is not None:
            for k in self.workloads:
                result['workloads'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonMeta') is not None:
            temp_model = AddonMeta()
            self.addon_meta = temp_model.from_map(m['addonMeta'])
        if m.get('collectorName') is not None:
            self.collector_name = m.get('collectorName')
        if m.get('collectorType') is not None:
            self.collector_type = m.get('collectorType')
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = ListIntegrationPolicyCollectorsResponseBodyCollectorsConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('managed') is not None:
            self.managed = m.get('managed')
        if m.get('nextVersion') is not None:
            self.next_version = m.get('nextVersion')
        if m.get('releaseName') is not None:
            self.release_name = m.get('releaseName')
        if m.get('releaseValues') is not None:
            self.release_values = m.get('releaseValues')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('version') is not None:
            self.version = m.get('version')
        self.workloads = []
        if m.get('workloads') is not None:
            for k in m.get('workloads'):
                temp_model = ListIntegrationPolicyCollectorsResponseBodyCollectorsWorkloads()
                self.workloads.append(temp_model.from_map(k))
        return self


class ListIntegrationPolicyCollectorsResponseBody(TeaModel):
    def __init__(
        self,
        collectors: List[ListIntegrationPolicyCollectorsResponseBodyCollectors] = None,
        request_id: str = None,
    ):
        self.collectors = collectors
        self.request_id = request_id

    def validate(self):
        if self.collectors:
            for k in self.collectors:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['collectors'] = []
        if self.collectors is not None:
            for k in self.collectors:
                result['collectors'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.collectors = []
        if m.get('collectors') is not None:
            for k in m.get('collectors'):
                temp_model = ListIntegrationPolicyCollectorsResponseBodyCollectors()
                self.collectors.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListIntegrationPolicyCollectorsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntegrationPolicyCollectorsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntegrationPolicyCollectorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntegrationPolicyCustomScrapeJobRulesRequest(TeaModel):
    def __init__(
        self,
        addon_release_name: str = None,
        encrypt_yaml: bool = None,
    ):
        self.addon_release_name = addon_release_name
        self.encrypt_yaml = encrypt_yaml

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_release_name is not None:
            result['addonReleaseName'] = self.addon_release_name
        if self.encrypt_yaml is not None:
            result['encryptYaml'] = self.encrypt_yaml
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonReleaseName') is not None:
            self.addon_release_name = m.get('addonReleaseName')
        if m.get('encryptYaml') is not None:
            self.encrypt_yaml = m.get('encryptYaml')
        return self


class ListIntegrationPolicyCustomScrapeJobRulesResponseBodyCustomScrapeJobRulesScrapeConfigs(TeaModel):
    def __init__(
        self,
        job_name: str = None,
        message: str = None,
        metrics_path: str = None,
        scheme: str = None,
        scrape_interval: str = None,
        scrape_timeout: str = None,
        service_discovery_configs: List[str] = None,
    ):
        self.job_name = job_name
        self.message = message
        self.metrics_path = metrics_path
        self.scheme = scheme
        self.scrape_interval = scrape_interval
        self.scrape_timeout = scrape_timeout
        self.service_discovery_configs = service_discovery_configs

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_name is not None:
            result['jobName'] = self.job_name
        if self.message is not None:
            result['message'] = self.message
        if self.metrics_path is not None:
            result['metricsPath'] = self.metrics_path
        if self.scheme is not None:
            result['scheme'] = self.scheme
        if self.scrape_interval is not None:
            result['scrapeInterval'] = self.scrape_interval
        if self.scrape_timeout is not None:
            result['scrapeTimeout'] = self.scrape_timeout
        if self.service_discovery_configs is not None:
            result['serviceDiscoveryConfigs'] = self.service_discovery_configs
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('jobName') is not None:
            self.job_name = m.get('jobName')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('metricsPath') is not None:
            self.metrics_path = m.get('metricsPath')
        if m.get('scheme') is not None:
            self.scheme = m.get('scheme')
        if m.get('scrapeInterval') is not None:
            self.scrape_interval = m.get('scrapeInterval')
        if m.get('scrapeTimeout') is not None:
            self.scrape_timeout = m.get('scrapeTimeout')
        if m.get('serviceDiscoveryConfigs') is not None:
            self.service_discovery_configs = m.get('serviceDiscoveryConfigs')
        return self


class ListIntegrationPolicyCustomScrapeJobRulesResponseBodyCustomScrapeJobRules(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        addon_release_name: str = None,
        addon_version: str = None,
        config_yaml: str = None,
        enable_status: str = None,
        encrypt_yaml: bool = None,
        matched_pod_count: int = None,
        message: str = None,
        name: str = None,
        namespace: str = None,
        scrape_configs: List[ListIntegrationPolicyCustomScrapeJobRulesResponseBodyCustomScrapeJobRulesScrapeConfigs] = None,
    ):
        self.addon_name = addon_name
        self.addon_release_name = addon_release_name
        self.addon_version = addon_version
        self.config_yaml = config_yaml
        self.enable_status = enable_status
        self.encrypt_yaml = encrypt_yaml
        self.matched_pod_count = matched_pod_count
        self.message = message
        self.name = name
        self.namespace = namespace
        self.scrape_configs = scrape_configs

    def validate(self):
        if self.scrape_configs:
            for k in self.scrape_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.addon_release_name is not None:
            result['addonReleaseName'] = self.addon_release_name
        if self.addon_version is not None:
            result['addonVersion'] = self.addon_version
        if self.config_yaml is not None:
            result['configYaml'] = self.config_yaml
        if self.enable_status is not None:
            result['enableStatus'] = self.enable_status
        if self.encrypt_yaml is not None:
            result['encryptYaml'] = self.encrypt_yaml
        if self.matched_pod_count is not None:
            result['matchedPodCount'] = self.matched_pod_count
        if self.message is not None:
            result['message'] = self.message
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        result['scrapeConfigs'] = []
        if self.scrape_configs is not None:
            for k in self.scrape_configs:
                result['scrapeConfigs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('addonReleaseName') is not None:
            self.addon_release_name = m.get('addonReleaseName')
        if m.get('addonVersion') is not None:
            self.addon_version = m.get('addonVersion')
        if m.get('configYaml') is not None:
            self.config_yaml = m.get('configYaml')
        if m.get('enableStatus') is not None:
            self.enable_status = m.get('enableStatus')
        if m.get('encryptYaml') is not None:
            self.encrypt_yaml = m.get('encryptYaml')
        if m.get('matchedPodCount') is not None:
            self.matched_pod_count = m.get('matchedPodCount')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        self.scrape_configs = []
        if m.get('scrapeConfigs') is not None:
            for k in m.get('scrapeConfigs'):
                temp_model = ListIntegrationPolicyCustomScrapeJobRulesResponseBodyCustomScrapeJobRulesScrapeConfigs()
                self.scrape_configs.append(temp_model.from_map(k))
        return self


class ListIntegrationPolicyCustomScrapeJobRulesResponseBody(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        custom_scrape_job_rules: List[ListIntegrationPolicyCustomScrapeJobRulesResponseBodyCustomScrapeJobRules] = None,
        policy_id: str = None,
        request_id: str = None,
    ):
        self.cluster_id = cluster_id
        self.custom_scrape_job_rules = custom_scrape_job_rules
        self.policy_id = policy_id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.custom_scrape_job_rules:
            for k in self.custom_scrape_job_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['clusterId'] = self.cluster_id
        result['customScrapeJobRules'] = []
        if self.custom_scrape_job_rules is not None:
            for k in self.custom_scrape_job_rules:
                result['customScrapeJobRules'].append(k.to_map() if k else None)
        if self.policy_id is not None:
            result['policyId'] = self.policy_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterId') is not None:
            self.cluster_id = m.get('clusterId')
        self.custom_scrape_job_rules = []
        if m.get('customScrapeJobRules') is not None:
            for k in m.get('customScrapeJobRules'):
                temp_model = ListIntegrationPolicyCustomScrapeJobRulesResponseBodyCustomScrapeJobRules()
                self.custom_scrape_job_rules.append(temp_model.from_map(k))
        if m.get('policyId') is not None:
            self.policy_id = m.get('policyId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListIntegrationPolicyCustomScrapeJobRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntegrationPolicyCustomScrapeJobRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntegrationPolicyCustomScrapeJobRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntegrationPolicyDashboardsRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        scene: str = None,
    ):
        self.addon_name = addon_name
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.scene is not None:
            result['scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        return self


class ListIntegrationPolicyDashboardsResponseBodyDashboards(TeaModel):
    def __init__(
        self,
        folder_uid: str = None,
        region: str = None,
        tags: List[str] = None,
        title: str = None,
        uid: str = None,
        url: str = None,
    ):
        self.folder_uid = folder_uid
        self.region = region
        self.tags = tags
        self.title = title
        self.uid = uid
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.folder_uid is not None:
            result['folderUid'] = self.folder_uid
        if self.region is not None:
            result['region'] = self.region
        if self.tags is not None:
            result['tags'] = self.tags
        if self.title is not None:
            result['title'] = self.title
        if self.uid is not None:
            result['uid'] = self.uid
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('folderUid') is not None:
            self.folder_uid = m.get('folderUid')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('tags') is not None:
            self.tags = m.get('tags')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('uid') is not None:
            self.uid = m.get('uid')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class ListIntegrationPolicyDashboardsResponseBody(TeaModel):
    def __init__(
        self,
        dashboards: List[ListIntegrationPolicyDashboardsResponseBodyDashboards] = None,
        request_id: str = None,
        total: int = None,
    ):
        self.dashboards = dashboards
        # Id of the request
        self.request_id = request_id
        self.total = total

    def validate(self):
        if self.dashboards:
            for k in self.dashboards:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['dashboards'] = []
        if self.dashboards is not None:
            for k in self.dashboards:
                result['dashboards'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dashboards = []
        if m.get('dashboards') is not None:
            for k in m.get('dashboards'):
                temp_model = ListIntegrationPolicyDashboardsResponseBodyDashboards()
                self.dashboards.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListIntegrationPolicyDashboardsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntegrationPolicyDashboardsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntegrationPolicyDashboardsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntegrationPolicyPipelineConfigsRequest(TeaModel):
    def __init__(
        self,
        addon_release_name: str = None,
        encrypt_yaml: bool = None,
        namespace: str = None,
    ):
        self.addon_release_name = addon_release_name
        self.encrypt_yaml = encrypt_yaml
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_release_name is not None:
            result['addonReleaseName'] = self.addon_release_name
        if self.encrypt_yaml is not None:
            result['encryptYaml'] = self.encrypt_yaml
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonReleaseName') is not None:
            self.addon_release_name = m.get('addonReleaseName')
        if m.get('encryptYaml') is not None:
            self.encrypt_yaml = m.get('encryptYaml')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class ListIntegrationPolicyPipelineConfigsResponseBodyPipelineConfigs(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListIntegrationPolicyPipelineConfigsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        pipeline_configs: List[ListIntegrationPolicyPipelineConfigsResponseBodyPipelineConfigs] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.message = message
        self.pipeline_configs = pipeline_configs
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.pipeline_configs:
            for k in self.pipeline_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.message is not None:
            result['message'] = self.message
        result['pipelineConfigs'] = []
        if self.pipeline_configs is not None:
            for k in self.pipeline_configs:
                result['pipelineConfigs'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('message') is not None:
            self.message = m.get('message')
        self.pipeline_configs = []
        if m.get('pipelineConfigs') is not None:
            for k in m.get('pipelineConfigs'):
                temp_model = ListIntegrationPolicyPipelineConfigsResponseBodyPipelineConfigs()
                self.pipeline_configs.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListIntegrationPolicyPipelineConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntegrationPolicyPipelineConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntegrationPolicyPipelineConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntegrationPolicyPodMonitorsRequest(TeaModel):
    def __init__(
        self,
        addon_release_name: str = None,
        encrypt_yaml: bool = None,
        namespace: str = None,
    ):
        self.addon_release_name = addon_release_name
        self.encrypt_yaml = encrypt_yaml
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_release_name is not None:
            result['addonReleaseName'] = self.addon_release_name
        if self.encrypt_yaml is not None:
            result['encryptYaml'] = self.encrypt_yaml
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonReleaseName') is not None:
            self.addon_release_name = m.get('addonReleaseName')
        if m.get('encryptYaml') is not None:
            self.encrypt_yaml = m.get('encryptYaml')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class ListIntegrationPolicyPodMonitorsResponseBodyPodMonitorsEndpoints(TeaModel):
    def __init__(
        self,
        interval: str = None,
        matched_target_count: int = None,
        path: str = None,
        port: str = None,
        target_port: str = None,
    ):
        self.interval = interval
        self.matched_target_count = matched_target_count
        self.path = path
        self.port = port
        self.target_port = target_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interval is not None:
            result['interval'] = self.interval
        if self.matched_target_count is not None:
            result['matchedTargetCount'] = self.matched_target_count
        if self.path is not None:
            result['path'] = self.path
        if self.port is not None:
            result['port'] = self.port
        if self.target_port is not None:
            result['targetPort'] = self.target_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('matchedTargetCount') is not None:
            self.matched_target_count = m.get('matchedTargetCount')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('port') is not None:
            self.port = m.get('port')
        if m.get('targetPort') is not None:
            self.target_port = m.get('targetPort')
        return self


class ListIntegrationPolicyPodMonitorsResponseBodyPodMonitors(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        addon_release_name: str = None,
        addon_version: str = None,
        config_yaml: str = None,
        enable_status: str = None,
        encrypt_yaml: bool = None,
        endpoints: List[ListIntegrationPolicyPodMonitorsResponseBodyPodMonitorsEndpoints] = None,
        matched_pod_count: int = None,
        name: str = None,
        namespace: str = None,
    ):
        self.addon_name = addon_name
        self.addon_release_name = addon_release_name
        self.addon_version = addon_version
        self.config_yaml = config_yaml
        self.enable_status = enable_status
        self.encrypt_yaml = encrypt_yaml
        self.endpoints = endpoints
        self.matched_pod_count = matched_pod_count
        self.name = name
        self.namespace = namespace

    def validate(self):
        if self.endpoints:
            for k in self.endpoints:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.addon_release_name is not None:
            result['addonReleaseName'] = self.addon_release_name
        if self.addon_version is not None:
            result['addonVersion'] = self.addon_version
        if self.config_yaml is not None:
            result['configYaml'] = self.config_yaml
        if self.enable_status is not None:
            result['enableStatus'] = self.enable_status
        if self.encrypt_yaml is not None:
            result['encryptYaml'] = self.encrypt_yaml
        result['endpoints'] = []
        if self.endpoints is not None:
            for k in self.endpoints:
                result['endpoints'].append(k.to_map() if k else None)
        if self.matched_pod_count is not None:
            result['matchedPodCount'] = self.matched_pod_count
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('addonReleaseName') is not None:
            self.addon_release_name = m.get('addonReleaseName')
        if m.get('addonVersion') is not None:
            self.addon_version = m.get('addonVersion')
        if m.get('configYaml') is not None:
            self.config_yaml = m.get('configYaml')
        if m.get('enableStatus') is not None:
            self.enable_status = m.get('enableStatus')
        if m.get('encryptYaml') is not None:
            self.encrypt_yaml = m.get('encryptYaml')
        self.endpoints = []
        if m.get('endpoints') is not None:
            for k in m.get('endpoints'):
                temp_model = ListIntegrationPolicyPodMonitorsResponseBodyPodMonitorsEndpoints()
                self.endpoints.append(temp_model.from_map(k))
        if m.get('matchedPodCount') is not None:
            self.matched_pod_count = m.get('matchedPodCount')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class ListIntegrationPolicyPodMonitorsResponseBody(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        pod_monitors: List[ListIntegrationPolicyPodMonitorsResponseBodyPodMonitors] = None,
        policy_id: str = None,
        request_id: str = None,
    ):
        self.cluster_id = cluster_id
        self.pod_monitors = pod_monitors
        self.policy_id = policy_id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.pod_monitors:
            for k in self.pod_monitors:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['clusterId'] = self.cluster_id
        result['podMonitors'] = []
        if self.pod_monitors is not None:
            for k in self.pod_monitors:
                result['podMonitors'].append(k.to_map() if k else None)
        if self.policy_id is not None:
            result['policyId'] = self.policy_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterId') is not None:
            self.cluster_id = m.get('clusterId')
        self.pod_monitors = []
        if m.get('podMonitors') is not None:
            for k in m.get('podMonitors'):
                temp_model = ListIntegrationPolicyPodMonitorsResponseBodyPodMonitors()
                self.pod_monitors.append(temp_model.from_map(k))
        if m.get('policyId') is not None:
            self.policy_id = m.get('policyId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListIntegrationPolicyPodMonitorsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntegrationPolicyPodMonitorsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntegrationPolicyPodMonitorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntegrationPolicyResourcesRequest(TeaModel):
    def __init__(
        self,
        kind: str = None,
        label_selectors: Dict[str, str] = None,
        namespace: str = None,
    ):
        self.kind = kind
        self.label_selectors = label_selectors
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.kind is not None:
            result['kind'] = self.kind
        if self.label_selectors is not None:
            result['labelSelectors'] = self.label_selectors
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('kind') is not None:
            self.kind = m.get('kind')
        if m.get('labelSelectors') is not None:
            self.label_selectors = m.get('labelSelectors')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class ListIntegrationPolicyResourcesShrinkRequest(TeaModel):
    def __init__(
        self,
        kind: str = None,
        label_selectors_shrink: str = None,
        namespace: str = None,
    ):
        self.kind = kind
        self.label_selectors_shrink = label_selectors_shrink
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.kind is not None:
            result['kind'] = self.kind
        if self.label_selectors_shrink is not None:
            result['labelSelectors'] = self.label_selectors_shrink
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('kind') is not None:
            self.kind = m.get('kind')
        if m.get('labelSelectors') is not None:
            self.label_selectors_shrink = m.get('labelSelectors')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class ListIntegrationPolicyResourcesResponseBodyResourcesMetadata(TeaModel):
    def __init__(
        self,
        annotations: Dict[str, str] = None,
        labels: Dict[str, str] = None,
        name: str = None,
        namespace: str = None,
    ):
        self.annotations = annotations
        self.labels = labels
        self.name = name
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotations is not None:
            result['annotations'] = self.annotations
        if self.labels is not None:
            result['labels'] = self.labels
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('annotations') is not None:
            self.annotations = m.get('annotations')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class ListIntegrationPolicyResourcesResponseBodyResources(TeaModel):
    def __init__(
        self,
        api_version: str = None,
        kind: str = None,
        metadata: ListIntegrationPolicyResourcesResponseBodyResourcesMetadata = None,
        spec: Any = None,
        status: Any = None,
    ):
        self.api_version = api_version
        self.kind = kind
        self.metadata = metadata
        self.spec = spec
        self.status = status

    def validate(self):
        if self.metadata:
            self.metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_version is not None:
            result['apiVersion'] = self.api_version
        if self.kind is not None:
            result['kind'] = self.kind
        if self.metadata is not None:
            result['metadata'] = self.metadata.to_map()
        if self.spec is not None:
            result['spec'] = self.spec
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('apiVersion') is not None:
            self.api_version = m.get('apiVersion')
        if m.get('kind') is not None:
            self.kind = m.get('kind')
        if m.get('metadata') is not None:
            temp_model = ListIntegrationPolicyResourcesResponseBodyResourcesMetadata()
            self.metadata = temp_model.from_map(m['metadata'])
        if m.get('spec') is not None:
            self.spec = m.get('spec')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class ListIntegrationPolicyResourcesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        resources: List[ListIntegrationPolicyResourcesResponseBodyResources] = None,
    ):
        self.request_id = request_id
        self.resources = resources

    def validate(self):
        if self.resources:
            for k in self.resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resources'] = []
        if self.resources is not None:
            for k in self.resources:
                result['resources'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.resources = []
        if m.get('resources') is not None:
            for k in m.get('resources'):
                temp_model = ListIntegrationPolicyResourcesResponseBodyResources()
                self.resources.append(temp_model.from_map(k))
        return self


class ListIntegrationPolicyResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntegrationPolicyResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntegrationPolicyResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntegrationPolicyServiceMonitorsRequest(TeaModel):
    def __init__(
        self,
        addon_release_name: str = None,
        encrypt_yaml: bool = None,
        namespace: str = None,
    ):
        self.addon_release_name = addon_release_name
        self.encrypt_yaml = encrypt_yaml
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_release_name is not None:
            result['addonReleaseName'] = self.addon_release_name
        if self.encrypt_yaml is not None:
            result['encryptYaml'] = self.encrypt_yaml
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonReleaseName') is not None:
            self.addon_release_name = m.get('addonReleaseName')
        if m.get('encryptYaml') is not None:
            self.encrypt_yaml = m.get('encryptYaml')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class ListIntegrationPolicyServiceMonitorsResponseBodyServiceMonitorsEndpoints(TeaModel):
    def __init__(
        self,
        interval: str = None,
        matched_target_count: int = None,
        path: str = None,
        port: str = None,
        target_port: str = None,
    ):
        self.interval = interval
        self.matched_target_count = matched_target_count
        self.path = path
        self.port = port
        self.target_port = target_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interval is not None:
            result['interval'] = self.interval
        if self.matched_target_count is not None:
            result['matchedTargetCount'] = self.matched_target_count
        if self.path is not None:
            result['path'] = self.path
        if self.port is not None:
            result['port'] = self.port
        if self.target_port is not None:
            result['targetPort'] = self.target_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('matchedTargetCount') is not None:
            self.matched_target_count = m.get('matchedTargetCount')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('port') is not None:
            self.port = m.get('port')
        if m.get('targetPort') is not None:
            self.target_port = m.get('targetPort')
        return self


class ListIntegrationPolicyServiceMonitorsResponseBodyServiceMonitors(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        addon_release_name: str = None,
        addon_version: str = None,
        config_yaml: str = None,
        enable_status: str = None,
        encrypt_yaml: bool = None,
        endpoints: List[ListIntegrationPolicyServiceMonitorsResponseBodyServiceMonitorsEndpoints] = None,
        matched_service_count: int = None,
        name: str = None,
        namespace: str = None,
    ):
        self.addon_name = addon_name
        self.addon_release_name = addon_release_name
        self.addon_version = addon_version
        self.config_yaml = config_yaml
        self.enable_status = enable_status
        self.encrypt_yaml = encrypt_yaml
        self.endpoints = endpoints
        self.matched_service_count = matched_service_count
        self.name = name
        self.namespace = namespace

    def validate(self):
        if self.endpoints:
            for k in self.endpoints:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.addon_release_name is not None:
            result['addonReleaseName'] = self.addon_release_name
        if self.addon_version is not None:
            result['addonVersion'] = self.addon_version
        if self.config_yaml is not None:
            result['configYaml'] = self.config_yaml
        if self.enable_status is not None:
            result['enableStatus'] = self.enable_status
        if self.encrypt_yaml is not None:
            result['encryptYaml'] = self.encrypt_yaml
        result['endpoints'] = []
        if self.endpoints is not None:
            for k in self.endpoints:
                result['endpoints'].append(k.to_map() if k else None)
        if self.matched_service_count is not None:
            result['matchedServiceCount'] = self.matched_service_count
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('addonReleaseName') is not None:
            self.addon_release_name = m.get('addonReleaseName')
        if m.get('addonVersion') is not None:
            self.addon_version = m.get('addonVersion')
        if m.get('configYaml') is not None:
            self.config_yaml = m.get('configYaml')
        if m.get('enableStatus') is not None:
            self.enable_status = m.get('enableStatus')
        if m.get('encryptYaml') is not None:
            self.encrypt_yaml = m.get('encryptYaml')
        self.endpoints = []
        if m.get('endpoints') is not None:
            for k in m.get('endpoints'):
                temp_model = ListIntegrationPolicyServiceMonitorsResponseBodyServiceMonitorsEndpoints()
                self.endpoints.append(temp_model.from_map(k))
        if m.get('matchedServiceCount') is not None:
            self.matched_service_count = m.get('matchedServiceCount')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class ListIntegrationPolicyServiceMonitorsResponseBody(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        policy_id: str = None,
        request_id: str = None,
        service_monitors: List[ListIntegrationPolicyServiceMonitorsResponseBodyServiceMonitors] = None,
    ):
        self.cluster_id = cluster_id
        self.policy_id = policy_id
        self.request_id = request_id
        self.service_monitors = service_monitors

    def validate(self):
        if self.service_monitors:
            for k in self.service_monitors:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['clusterId'] = self.cluster_id
        if self.policy_id is not None:
            result['policyId'] = self.policy_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['serviceMonitors'] = []
        if self.service_monitors is not None:
            for k in self.service_monitors:
                result['serviceMonitors'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterId') is not None:
            self.cluster_id = m.get('clusterId')
        if m.get('policyId') is not None:
            self.policy_id = m.get('policyId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.service_monitors = []
        if m.get('serviceMonitors') is not None:
            for k in m.get('serviceMonitors'):
                temp_model = ListIntegrationPolicyServiceMonitorsResponseBodyServiceMonitors()
                self.service_monitors.append(temp_model.from_map(k))
        return self


class ListIntegrationPolicyServiceMonitorsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntegrationPolicyServiceMonitorsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntegrationPolicyServiceMonitorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntegrationPolicyStorageRequirementsRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        storage_type: str = None,
    ):
        self.addon_name = addon_name
        self.storage_type = storage_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.storage_type is not None:
            result['storageType'] = self.storage_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('storageType') is not None:
            self.storage_type = m.get('storageType')
        return self


class ListIntegrationPolicyStorageRequirementsResponseBodyStorageRequirementsMetadata(TeaModel):
    def __init__(
        self,
        annotations: Dict[str, str] = None,
        labels: Dict[str, str] = None,
        name: str = None,
        namespace: str = None,
    ):
        self.annotations = annotations
        self.labels = labels
        self.name = name
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotations is not None:
            result['annotations'] = self.annotations
        if self.labels is not None:
            result['labels'] = self.labels
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('annotations') is not None:
            self.annotations = m.get('annotations')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class ListIntegrationPolicyStorageRequirementsResponseBodyStorageRequirementsSpec(TeaModel):
    def __init__(
        self,
        entity_id: str = None,
        instance: str = None,
        instance_name: str = None,
        project: str = None,
        region: str = None,
        share_scope: str = None,
        storage_type: str = None,
        system_tags: Dict[str, str] = None,
        tags: Dict[str, str] = None,
        user_id: str = None,
        workspace: str = None,
    ):
        self.entity_id = entity_id
        self.instance = instance
        self.instance_name = instance_name
        self.project = project
        self.region = region
        self.share_scope = share_scope
        self.storage_type = storage_type
        self.system_tags = system_tags
        self.tags = tags
        self.user_id = user_id
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_id is not None:
            result['entityId'] = self.entity_id
        if self.instance is not None:
            result['instance'] = self.instance
        if self.instance_name is not None:
            result['instanceName'] = self.instance_name
        if self.project is not None:
            result['project'] = self.project
        if self.region is not None:
            result['region'] = self.region
        if self.share_scope is not None:
            result['shareScope'] = self.share_scope
        if self.storage_type is not None:
            result['storageType'] = self.storage_type
        if self.system_tags is not None:
            result['systemTags'] = self.system_tags
        if self.tags is not None:
            result['tags'] = self.tags
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('entityId') is not None:
            self.entity_id = m.get('entityId')
        if m.get('instance') is not None:
            self.instance = m.get('instance')
        if m.get('instanceName') is not None:
            self.instance_name = m.get('instanceName')
        if m.get('project') is not None:
            self.project = m.get('project')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('shareScope') is not None:
            self.share_scope = m.get('shareScope')
        if m.get('storageType') is not None:
            self.storage_type = m.get('storageType')
        if m.get('systemTags') is not None:
            self.system_tags = m.get('systemTags')
        if m.get('tags') is not None:
            self.tags = m.get('tags')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListIntegrationPolicyStorageRequirementsResponseBodyStorageRequirementsStatus(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        inter_url: str = None,
        intra_url: str = None,
        name: str = None,
        project: str = None,
        prom_metric_store: str = None,
        region: str = None,
        storage_type: str = None,
        workspace: str = None,
    ):
        self.instance_id = instance_id
        self.inter_url = inter_url
        self.intra_url = intra_url
        self.name = name
        self.project = project
        self.prom_metric_store = prom_metric_store
        self.region = region
        self.storage_type = storage_type
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['instanceId'] = self.instance_id
        if self.inter_url is not None:
            result['interUrl'] = self.inter_url
        if self.intra_url is not None:
            result['intraUrl'] = self.intra_url
        if self.name is not None:
            result['name'] = self.name
        if self.project is not None:
            result['project'] = self.project
        if self.prom_metric_store is not None:
            result['promMetricStore'] = self.prom_metric_store
        if self.region is not None:
            result['region'] = self.region
        if self.storage_type is not None:
            result['storageType'] = self.storage_type
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('instanceId') is not None:
            self.instance_id = m.get('instanceId')
        if m.get('interUrl') is not None:
            self.inter_url = m.get('interUrl')
        if m.get('intraUrl') is not None:
            self.intra_url = m.get('intraUrl')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('project') is not None:
            self.project = m.get('project')
        if m.get('promMetricStore') is not None:
            self.prom_metric_store = m.get('promMetricStore')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('storageType') is not None:
            self.storage_type = m.get('storageType')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListIntegrationPolicyStorageRequirementsResponseBodyStorageRequirements(TeaModel):
    def __init__(
        self,
        addon_release_names: List[str] = None,
        api_version: str = None,
        kind: str = None,
        metadata: ListIntegrationPolicyStorageRequirementsResponseBodyStorageRequirementsMetadata = None,
        spec: ListIntegrationPolicyStorageRequirementsResponseBodyStorageRequirementsSpec = None,
        status: ListIntegrationPolicyStorageRequirementsResponseBodyStorageRequirementsStatus = None,
    ):
        self.addon_release_names = addon_release_names
        self.api_version = api_version
        self.kind = kind
        self.metadata = metadata
        self.spec = spec
        self.status = status

    def validate(self):
        if self.metadata:
            self.metadata.validate()
        if self.spec:
            self.spec.validate()
        if self.status:
            self.status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_release_names is not None:
            result['addonReleaseNames'] = self.addon_release_names
        if self.api_version is not None:
            result['apiVersion'] = self.api_version
        if self.kind is not None:
            result['kind'] = self.kind
        if self.metadata is not None:
            result['metadata'] = self.metadata.to_map()
        if self.spec is not None:
            result['spec'] = self.spec.to_map()
        if self.status is not None:
            result['status'] = self.status.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonReleaseNames') is not None:
            self.addon_release_names = m.get('addonReleaseNames')
        if m.get('apiVersion') is not None:
            self.api_version = m.get('apiVersion')
        if m.get('kind') is not None:
            self.kind = m.get('kind')
        if m.get('metadata') is not None:
            temp_model = ListIntegrationPolicyStorageRequirementsResponseBodyStorageRequirementsMetadata()
            self.metadata = temp_model.from_map(m['metadata'])
        if m.get('spec') is not None:
            temp_model = ListIntegrationPolicyStorageRequirementsResponseBodyStorageRequirementsSpec()
            self.spec = temp_model.from_map(m['spec'])
        if m.get('status') is not None:
            temp_model = ListIntegrationPolicyStorageRequirementsResponseBodyStorageRequirementsStatus()
            self.status = temp_model.from_map(m['status'])
        return self


class ListIntegrationPolicyStorageRequirementsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        storage_requirements: List[ListIntegrationPolicyStorageRequirementsResponseBodyStorageRequirements] = None,
    ):
        # Id of the request
        self.request_id = request_id
        self.storage_requirements = storage_requirements

    def validate(self):
        if self.storage_requirements:
            for k in self.storage_requirements:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['storageRequirements'] = []
        if self.storage_requirements is not None:
            for k in self.storage_requirements:
                result['storageRequirements'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.storage_requirements = []
        if m.get('storageRequirements') is not None:
            for k in m.get('storageRequirements'):
                temp_model = ListIntegrationPolicyStorageRequirementsResponseBodyStorageRequirements()
                self.storage_requirements.append(temp_model.from_map(k))
        return self


class ListIntegrationPolicyStorageRequirementsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntegrationPolicyStorageRequirementsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntegrationPolicyStorageRequirementsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntegrationPolicyTargetsRequest(TeaModel):
    def __init__(
        self,
        job_name: str = None,
    ):
        self.job_name = job_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_name is not None:
            result['jobName'] = self.job_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('jobName') is not None:
            self.job_name = m.get('jobName')
        return self


class ListIntegrationPolicyTargetsResponseBodyActiveTargets(TeaModel):
    def __init__(
        self,
        discovered_labels: Dict[str, str] = None,
        global_url: str = None,
        health: str = None,
        labels: Dict[str, str] = None,
        last_error: str = None,
        last_scrape: str = None,
        last_scrape_duration: float = None,
        last_scrape_series: int = None,
        scrape_pool: str = None,
        scrape_url: str = None,
    ):
        self.discovered_labels = discovered_labels
        self.global_url = global_url
        self.health = health
        self.labels = labels
        self.last_error = last_error
        self.last_scrape = last_scrape
        self.last_scrape_duration = last_scrape_duration
        self.last_scrape_series = last_scrape_series
        self.scrape_pool = scrape_pool
        self.scrape_url = scrape_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.discovered_labels is not None:
            result['discoveredLabels'] = self.discovered_labels
        if self.global_url is not None:
            result['globalUrl'] = self.global_url
        if self.health is not None:
            result['health'] = self.health
        if self.labels is not None:
            result['labels'] = self.labels
        if self.last_error is not None:
            result['lastError'] = self.last_error
        if self.last_scrape is not None:
            result['lastScrape'] = self.last_scrape
        if self.last_scrape_duration is not None:
            result['lastScrapeDuration'] = self.last_scrape_duration
        if self.last_scrape_series is not None:
            result['lastScrapeSeries'] = self.last_scrape_series
        if self.scrape_pool is not None:
            result['scrapePool'] = self.scrape_pool
        if self.scrape_url is not None:
            result['scrapeUrl'] = self.scrape_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('discoveredLabels') is not None:
            self.discovered_labels = m.get('discoveredLabels')
        if m.get('globalUrl') is not None:
            self.global_url = m.get('globalUrl')
        if m.get('health') is not None:
            self.health = m.get('health')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('lastError') is not None:
            self.last_error = m.get('lastError')
        if m.get('lastScrape') is not None:
            self.last_scrape = m.get('lastScrape')
        if m.get('lastScrapeDuration') is not None:
            self.last_scrape_duration = m.get('lastScrapeDuration')
        if m.get('lastScrapeSeries') is not None:
            self.last_scrape_series = m.get('lastScrapeSeries')
        if m.get('scrapePool') is not None:
            self.scrape_pool = m.get('scrapePool')
        if m.get('scrapeUrl') is not None:
            self.scrape_url = m.get('scrapeUrl')
        return self


class ListIntegrationPolicyTargetsResponseBodyDroppedTargets(TeaModel):
    def __init__(
        self,
        discovered_labels: Dict[str, str] = None,
        global_url: str = None,
        health: str = None,
        labels: Dict[str, str] = None,
        last_error: str = None,
        last_scrape: str = None,
        last_scrape_duration: float = None,
        last_scrape_series: int = None,
        scrape_pool: str = None,
        scrape_url: str = None,
    ):
        self.discovered_labels = discovered_labels
        self.global_url = global_url
        self.health = health
        self.labels = labels
        self.last_error = last_error
        self.last_scrape = last_scrape
        self.last_scrape_duration = last_scrape_duration
        self.last_scrape_series = last_scrape_series
        self.scrape_pool = scrape_pool
        self.scrape_url = scrape_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.discovered_labels is not None:
            result['discoveredLabels'] = self.discovered_labels
        if self.global_url is not None:
            result['globalUrl'] = self.global_url
        if self.health is not None:
            result['health'] = self.health
        if self.labels is not None:
            result['labels'] = self.labels
        if self.last_error is not None:
            result['lastError'] = self.last_error
        if self.last_scrape is not None:
            result['lastScrape'] = self.last_scrape
        if self.last_scrape_duration is not None:
            result['lastScrapeDuration'] = self.last_scrape_duration
        if self.last_scrape_series is not None:
            result['lastScrapeSeries'] = self.last_scrape_series
        if self.scrape_pool is not None:
            result['scrapePool'] = self.scrape_pool
        if self.scrape_url is not None:
            result['scrapeUrl'] = self.scrape_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('discoveredLabels') is not None:
            self.discovered_labels = m.get('discoveredLabels')
        if m.get('globalUrl') is not None:
            self.global_url = m.get('globalUrl')
        if m.get('health') is not None:
            self.health = m.get('health')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('lastError') is not None:
            self.last_error = m.get('lastError')
        if m.get('lastScrape') is not None:
            self.last_scrape = m.get('lastScrape')
        if m.get('lastScrapeDuration') is not None:
            self.last_scrape_duration = m.get('lastScrapeDuration')
        if m.get('lastScrapeSeries') is not None:
            self.last_scrape_series = m.get('lastScrapeSeries')
        if m.get('scrapePool') is not None:
            self.scrape_pool = m.get('scrapePool')
        if m.get('scrapeUrl') is not None:
            self.scrape_url = m.get('scrapeUrl')
        return self


class ListIntegrationPolicyTargetsResponseBody(TeaModel):
    def __init__(
        self,
        active_targets: List[ListIntegrationPolicyTargetsResponseBodyActiveTargets] = None,
        code: int = None,
        dropped_targets: List[ListIntegrationPolicyTargetsResponseBodyDroppedTargets] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.active_targets = active_targets
        self.code = code
        self.dropped_targets = dropped_targets
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.active_targets:
            for k in self.active_targets:
                if k:
                    k.validate()
        if self.dropped_targets:
            for k in self.dropped_targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['activeTargets'] = []
        if self.active_targets is not None:
            for k in self.active_targets:
                result['activeTargets'].append(k.to_map() if k else None)
        if self.code is not None:
            result['code'] = self.code
        result['droppedTargets'] = []
        if self.dropped_targets is not None:
            for k in self.dropped_targets:
                result['droppedTargets'].append(k.to_map() if k else None)
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.active_targets = []
        if m.get('activeTargets') is not None:
            for k in m.get('activeTargets'):
                temp_model = ListIntegrationPolicyTargetsResponseBodyActiveTargets()
                self.active_targets.append(temp_model.from_map(k))
        if m.get('code') is not None:
            self.code = m.get('code')
        self.dropped_targets = []
        if m.get('droppedTargets') is not None:
            for k in m.get('droppedTargets'):
                temp_model = ListIntegrationPolicyTargetsResponseBodyDroppedTargets()
                self.dropped_targets.append(temp_model.from_map(k))
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListIntegrationPolicyTargetsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntegrationPolicyTargetsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntegrationPolicyTargetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntegrationsRequest(TeaModel):
    def __init__(
        self,
        enable: bool = None,
        integration_id: str = None,
        integration_name: str = None,
        max_results: int = None,
        next_token: str = None,
        page: int = None,
        size: int = None,
        workspace: str = None,
    ):
        self.enable = enable
        self.integration_id = integration_id
        self.integration_name = integration_name
        self.max_results = max_results
        self.next_token = next_token
        self.page = page
        self.size = size
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable is not None:
            result['enable'] = self.enable
        if self.integration_id is not None:
            result['integrationId'] = self.integration_id
        if self.integration_name is not None:
            result['integrationName'] = self.integration_name
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page is not None:
            result['page'] = self.page
        if self.size is not None:
            result['size'] = self.size
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('integrationId') is not None:
            self.integration_id = m.get('integrationId')
        if m.get('integrationName') is not None:
            self.integration_name = m.get('integrationName')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListIntegrationsResponseBody(TeaModel):
    def __init__(
        self,
        integration_list: List[IntegrationForView] = None,
        max_results: int = None,
        next_token: str = None,
        page: int = None,
        request_id: str = None,
        size: int = None,
        total: int = None,
    ):
        self.integration_list = integration_list
        self.max_results = max_results
        self.next_token = next_token
        self.page = page
        self.request_id = request_id
        self.size = size
        self.total = total

    def validate(self):
        if self.integration_list:
            for k in self.integration_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['integrationList'] = []
        if self.integration_list is not None:
            for k in self.integration_list:
                result['integrationList'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page is not None:
            result['page'] = self.page
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.size is not None:
            result['size'] = self.size
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.integration_list = []
        if m.get('integrationList') is not None:
            for k in m.get('integrationList'):
                temp_model = IntegrationForView()
                self.integration_list.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListIntegrationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntegrationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntegrationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMaintainWindowsRequest(TeaModel):
    def __init__(
        self,
        enable: bool = None,
        maintain_window_id: str = None,
        maintain_window_name: str = None,
        max_results: int = None,
        next_token: str = None,
        workspace: str = None,
    ):
        self.enable = enable
        self.maintain_window_id = maintain_window_id
        self.maintain_window_name = maintain_window_name
        self.max_results = max_results
        self.next_token = next_token
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable is not None:
            result['enable'] = self.enable
        if self.maintain_window_id is not None:
            result['maintainWindowId'] = self.maintain_window_id
        if self.maintain_window_name is not None:
            result['maintainWindowName'] = self.maintain_window_name
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('maintainWindowId') is not None:
            self.maintain_window_id = m.get('maintainWindowId')
        if m.get('maintainWindowName') is not None:
            self.maintain_window_name = m.get('maintainWindowName')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListMaintainWindowsResponseBody(TeaModel):
    def __init__(
        self,
        maintain_window_list: List[MaintainWindowForView] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.maintain_window_list = maintain_window_list
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id

    def validate(self):
        if self.maintain_window_list:
            for k in self.maintain_window_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['maintainWindowList'] = []
        if self.maintain_window_list is not None:
            for k in self.maintain_window_list:
                result['maintainWindowList'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.maintain_window_list = []
        if m.get('maintainWindowList') is not None:
            for k in m.get('maintainWindowList'):
                temp_model = MaintainWindowForView()
                self.maintain_window_list.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListMaintainWindowsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMaintainWindowsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMaintainWindowsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMetricTargetsRequest(TeaModel):
    def __init__(
        self,
        job_name: str = None,
    ):
        self.job_name = job_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_name is not None:
            result['jobName'] = self.job_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('jobName') is not None:
            self.job_name = m.get('jobName')
        return self


class ListMetricTargetsResponseBodyDataActiveTargets(TeaModel):
    def __init__(
        self,
        discovered_labels: Dict[str, str] = None,
        global_url: str = None,
        health: str = None,
        labels: Dict[str, str] = None,
        last_error: str = None,
        last_scrape: str = None,
        last_scrape_duration: float = None,
        last_scrape_series: int = None,
        scrape_pool: str = None,
        scrape_url: str = None,
    ):
        self.discovered_labels = discovered_labels
        self.global_url = global_url
        self.health = health
        self.labels = labels
        self.last_error = last_error
        self.last_scrape = last_scrape
        self.last_scrape_duration = last_scrape_duration
        self.last_scrape_series = last_scrape_series
        self.scrape_pool = scrape_pool
        self.scrape_url = scrape_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.discovered_labels is not None:
            result['discoveredLabels'] = self.discovered_labels
        if self.global_url is not None:
            result['globalUrl'] = self.global_url
        if self.health is not None:
            result['health'] = self.health
        if self.labels is not None:
            result['labels'] = self.labels
        if self.last_error is not None:
            result['lastError'] = self.last_error
        if self.last_scrape is not None:
            result['lastScrape'] = self.last_scrape
        if self.last_scrape_duration is not None:
            result['lastScrapeDuration'] = self.last_scrape_duration
        if self.last_scrape_series is not None:
            result['lastScrapeSeries'] = self.last_scrape_series
        if self.scrape_pool is not None:
            result['scrapePool'] = self.scrape_pool
        if self.scrape_url is not None:
            result['scrapeUrl'] = self.scrape_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('discoveredLabels') is not None:
            self.discovered_labels = m.get('discoveredLabels')
        if m.get('globalUrl') is not None:
            self.global_url = m.get('globalUrl')
        if m.get('health') is not None:
            self.health = m.get('health')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('lastError') is not None:
            self.last_error = m.get('lastError')
        if m.get('lastScrape') is not None:
            self.last_scrape = m.get('lastScrape')
        if m.get('lastScrapeDuration') is not None:
            self.last_scrape_duration = m.get('lastScrapeDuration')
        if m.get('lastScrapeSeries') is not None:
            self.last_scrape_series = m.get('lastScrapeSeries')
        if m.get('scrapePool') is not None:
            self.scrape_pool = m.get('scrapePool')
        if m.get('scrapeUrl') is not None:
            self.scrape_url = m.get('scrapeUrl')
        return self


class ListMetricTargetsResponseBodyDataDroppedTargets(TeaModel):
    def __init__(
        self,
        discovered_labels: Dict[str, str] = None,
        global_url: str = None,
        health: str = None,
        labels: Dict[str, str] = None,
        last_error: str = None,
        last_scrape: str = None,
        last_scrape_duration: float = None,
        last_scrape_series: int = None,
        scrape_pool: str = None,
        scrape_url: str = None,
    ):
        self.discovered_labels = discovered_labels
        self.global_url = global_url
        self.health = health
        self.labels = labels
        self.last_error = last_error
        self.last_scrape = last_scrape
        self.last_scrape_duration = last_scrape_duration
        self.last_scrape_series = last_scrape_series
        self.scrape_pool = scrape_pool
        self.scrape_url = scrape_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.discovered_labels is not None:
            result['discoveredLabels'] = self.discovered_labels
        if self.global_url is not None:
            result['globalUrl'] = self.global_url
        if self.health is not None:
            result['health'] = self.health
        if self.labels is not None:
            result['labels'] = self.labels
        if self.last_error is not None:
            result['lastError'] = self.last_error
        if self.last_scrape is not None:
            result['lastScrape'] = self.last_scrape
        if self.last_scrape_duration is not None:
            result['lastScrapeDuration'] = self.last_scrape_duration
        if self.last_scrape_series is not None:
            result['lastScrapeSeries'] = self.last_scrape_series
        if self.scrape_pool is not None:
            result['scrapePool'] = self.scrape_pool
        if self.scrape_url is not None:
            result['scrapeUrl'] = self.scrape_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('discoveredLabels') is not None:
            self.discovered_labels = m.get('discoveredLabels')
        if m.get('globalUrl') is not None:
            self.global_url = m.get('globalUrl')
        if m.get('health') is not None:
            self.health = m.get('health')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('lastError') is not None:
            self.last_error = m.get('lastError')
        if m.get('lastScrape') is not None:
            self.last_scrape = m.get('lastScrape')
        if m.get('lastScrapeDuration') is not None:
            self.last_scrape_duration = m.get('lastScrapeDuration')
        if m.get('lastScrapeSeries') is not None:
            self.last_scrape_series = m.get('lastScrapeSeries')
        if m.get('scrapePool') is not None:
            self.scrape_pool = m.get('scrapePool')
        if m.get('scrapeUrl') is not None:
            self.scrape_url = m.get('scrapeUrl')
        return self


class ListMetricTargetsResponseBodyData(TeaModel):
    def __init__(
        self,
        active_targets: List[ListMetricTargetsResponseBodyDataActiveTargets] = None,
        dropped_targets: List[ListMetricTargetsResponseBodyDataDroppedTargets] = None,
    ):
        self.active_targets = active_targets
        self.dropped_targets = dropped_targets

    def validate(self):
        if self.active_targets:
            for k in self.active_targets:
                if k:
                    k.validate()
        if self.dropped_targets:
            for k in self.dropped_targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['activeTargets'] = []
        if self.active_targets is not None:
            for k in self.active_targets:
                result['activeTargets'].append(k.to_map() if k else None)
        result['droppedTargets'] = []
        if self.dropped_targets is not None:
            for k in self.dropped_targets:
                result['droppedTargets'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.active_targets = []
        if m.get('activeTargets') is not None:
            for k in m.get('activeTargets'):
                temp_model = ListMetricTargetsResponseBodyDataActiveTargets()
                self.active_targets.append(temp_model.from_map(k))
        self.dropped_targets = []
        if m.get('droppedTargets') is not None:
            for k in m.get('droppedTargets'):
                temp_model = ListMetricTargetsResponseBodyDataDroppedTargets()
                self.dropped_targets.append(temp_model.from_map(k))
        return self


class ListMetricTargetsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListMetricTargetsResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            temp_model = ListMetricTargetsResponseBodyData()
            self.data = temp_model.from_map(m['data'])
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListMetricTargetsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMetricTargetsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMetricTargetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListNotifyStrategiesRequest(TeaModel):
    def __init__(
        self,
        enable: bool = None,
        max_results: int = None,
        next_token: str = None,
        notify_strategy_id: str = None,
        notify_strategy_name: str = None,
        workspace: str = None,
    ):
        self.enable = enable
        self.max_results = max_results
        self.next_token = next_token
        self.notify_strategy_id = notify_strategy_id
        self.notify_strategy_name = notify_strategy_name
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable is not None:
            result['enable'] = self.enable
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.notify_strategy_id is not None:
            result['notifyStrategyId'] = self.notify_strategy_id
        if self.notify_strategy_name is not None:
            result['notifyStrategyName'] = self.notify_strategy_name
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('notifyStrategyId') is not None:
            self.notify_strategy_id = m.get('notifyStrategyId')
        if m.get('notifyStrategyName') is not None:
            self.notify_strategy_name = m.get('notifyStrategyName')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListNotifyStrategiesResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        notify_strategy_list: List[NotifyStrategyForView] = None,
        request_id: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.notify_strategy_list = notify_strategy_list
        self.request_id = request_id

    def validate(self):
        if self.notify_strategy_list:
            for k in self.notify_strategy_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['notifyStrategyList'] = []
        if self.notify_strategy_list is not None:
            for k in self.notify_strategy_list:
                result['notifyStrategyList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.notify_strategy_list = []
        if m.get('notifyStrategyList') is not None:
            for k in m.get('notifyStrategyList'):
                temp_model = NotifyStrategyForView()
                self.notify_strategy_list.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListNotifyStrategiesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListNotifyStrategiesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListNotifyStrategiesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOncallContactsRequest(TeaModel):
    def __init__(
        self,
        source: str = None,
        timestamp: str = None,
    ):
        self.source = source
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source is not None:
            result['source'] = self.source
        if self.timestamp is not None:
            result['timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('timestamp') is not None:
            self.timestamp = m.get('timestamp')
        return self


class ListOncallContactsResponseBody(TeaModel):
    def __init__(
        self,
        contact_ids: List[str] = None,
        request_id: str = None,
    ):
        self.contact_ids = contact_ids
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_ids is not None:
            result['contactIds'] = self.contact_ids
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contactIds') is not None:
            self.contact_ids = m.get('contactIds')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListOncallContactsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListOncallContactsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOncallContactsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOncallSchedulesRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        oncall_schedule_ids: List[str] = None,
        oncall_schedule_name: str = None,
        page_number: int = None,
        page_size: int = None,
        source: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.oncall_schedule_ids = oncall_schedule_ids
        self.oncall_schedule_name = oncall_schedule_name
        self.page_number = page_number
        self.page_size = page_size
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.oncall_schedule_ids is not None:
            result['oncallScheduleIds'] = self.oncall_schedule_ids
        if self.oncall_schedule_name is not None:
            result['oncallScheduleName'] = self.oncall_schedule_name
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('oncallScheduleIds') is not None:
            self.oncall_schedule_ids = m.get('oncallScheduleIds')
        if m.get('oncallScheduleName') is not None:
            self.oncall_schedule_name = m.get('oncallScheduleName')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class ListOncallSchedulesShrinkRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        oncall_schedule_ids_shrink: str = None,
        oncall_schedule_name: str = None,
        page_number: int = None,
        page_size: int = None,
        source: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.oncall_schedule_ids_shrink = oncall_schedule_ids_shrink
        self.oncall_schedule_name = oncall_schedule_name
        self.page_number = page_number
        self.page_size = page_size
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.oncall_schedule_ids_shrink is not None:
            result['oncallScheduleIds'] = self.oncall_schedule_ids_shrink
        if self.oncall_schedule_name is not None:
            result['oncallScheduleName'] = self.oncall_schedule_name
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('oncallScheduleIds') is not None:
            self.oncall_schedule_ids_shrink = m.get('oncallScheduleIds')
        if m.get('oncallScheduleName') is not None:
            self.oncall_schedule_name = m.get('oncallScheduleName')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class ListOncallSchedulesResponseBodyOncallSchedulesRotations(TeaModel):
    def __init__(
        self,
        active_days: List[int] = None,
        contacts: List[str] = None,
        rotation_end_time: str = None,
        rotation_name: str = None,
        rotation_start_time: str = None,
        shift_length: int = None,
        shift_recurrence_frequency: str = None,
        start_date: str = None,
        time_zone: str = None,
    ):
        self.active_days = active_days
        self.contacts = contacts
        self.rotation_end_time = rotation_end_time
        self.rotation_name = rotation_name
        self.rotation_start_time = rotation_start_time
        self.shift_length = shift_length
        self.shift_recurrence_frequency = shift_recurrence_frequency
        self.start_date = start_date
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_days is not None:
            result['activeDays'] = self.active_days
        if self.contacts is not None:
            result['contacts'] = self.contacts
        if self.rotation_end_time is not None:
            result['rotationEndTime'] = self.rotation_end_time
        if self.rotation_name is not None:
            result['rotationName'] = self.rotation_name
        if self.rotation_start_time is not None:
            result['rotationStartTime'] = self.rotation_start_time
        if self.shift_length is not None:
            result['shiftLength'] = self.shift_length
        if self.shift_recurrence_frequency is not None:
            result['shiftRecurrenceFrequency'] = self.shift_recurrence_frequency
        if self.start_date is not None:
            result['startDate'] = self.start_date
        if self.time_zone is not None:
            result['timeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('activeDays') is not None:
            self.active_days = m.get('activeDays')
        if m.get('contacts') is not None:
            self.contacts = m.get('contacts')
        if m.get('rotationEndTime') is not None:
            self.rotation_end_time = m.get('rotationEndTime')
        if m.get('rotationName') is not None:
            self.rotation_name = m.get('rotationName')
        if m.get('rotationStartTime') is not None:
            self.rotation_start_time = m.get('rotationStartTime')
        if m.get('shiftLength') is not None:
            self.shift_length = m.get('shiftLength')
        if m.get('shiftRecurrenceFrequency') is not None:
            self.shift_recurrence_frequency = m.get('shiftRecurrenceFrequency')
        if m.get('startDate') is not None:
            self.start_date = m.get('startDate')
        if m.get('timeZone') is not None:
            self.time_zone = m.get('timeZone')
        return self


class ListOncallSchedulesResponseBodyOncallSchedules(TeaModel):
    def __init__(
        self,
        oncall_schedule_id: str = None,
        oncall_schedule_name: str = None,
        rotations: List[ListOncallSchedulesResponseBodyOncallSchedulesRotations] = None,
        shift_robot_id: str = None,
    ):
        self.oncall_schedule_id = oncall_schedule_id
        self.oncall_schedule_name = oncall_schedule_name
        self.rotations = rotations
        self.shift_robot_id = shift_robot_id

    def validate(self):
        if self.rotations:
            for k in self.rotations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.oncall_schedule_id is not None:
            result['oncallScheduleId'] = self.oncall_schedule_id
        if self.oncall_schedule_name is not None:
            result['oncallScheduleName'] = self.oncall_schedule_name
        result['rotations'] = []
        if self.rotations is not None:
            for k in self.rotations:
                result['rotations'].append(k.to_map() if k else None)
        if self.shift_robot_id is not None:
            result['shiftRobotId'] = self.shift_robot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('oncallScheduleId') is not None:
            self.oncall_schedule_id = m.get('oncallScheduleId')
        if m.get('oncallScheduleName') is not None:
            self.oncall_schedule_name = m.get('oncallScheduleName')
        self.rotations = []
        if m.get('rotations') is not None:
            for k in m.get('rotations'):
                temp_model = ListOncallSchedulesResponseBodyOncallSchedulesRotations()
                self.rotations.append(temp_model.from_map(k))
        if m.get('shiftRobotId') is not None:
            self.shift_robot_id = m.get('shiftRobotId')
        return self


class ListOncallSchedulesResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        oncall_schedules: List[ListOncallSchedulesResponseBodyOncallSchedules] = None,
        request_id: str = None,
        total: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.oncall_schedules = oncall_schedules
        self.request_id = request_id
        self.total = total

    def validate(self):
        if self.oncall_schedules:
            for k in self.oncall_schedules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['oncallSchedules'] = []
        if self.oncall_schedules is not None:
            for k in self.oncall_schedules:
                result['oncallSchedules'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.oncall_schedules = []
        if m.get('oncallSchedules') is not None:
            for k in m.get('oncallSchedules'):
                temp_model = ListOncallSchedulesResponseBodyOncallSchedules()
                self.oncall_schedules.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListOncallSchedulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListOncallSchedulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOncallSchedulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPolicyAddonsResponseBodyAddonsDashboards(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        url: str = None,
    ):
        self.description = description
        self.name = name
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class ListPolicyAddonsResponseBodyAddonsEnvironmentsDependencies(TeaModel):
    def __init__(
        self,
        cluster_types: List[str] = None,
        features: Dict[str, bool] = None,
        services: List[str] = None,
    ):
        self.cluster_types = cluster_types
        self.features = features
        self.services = services

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_types is not None:
            result['clusterTypes'] = self.cluster_types
        if self.features is not None:
            result['features'] = self.features
        if self.services is not None:
            result['services'] = self.services
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterTypes') is not None:
            self.cluster_types = m.get('clusterTypes')
        if m.get('features') is not None:
            self.features = m.get('features')
        if m.get('services') is not None:
            self.services = m.get('services')
        return self


class ListPolicyAddonsResponseBodyAddonsEnvironmentsPoliciesMetricCheckRule(TeaModel):
    def __init__(
        self,
        prom_ql: List[str] = None,
    ):
        self.prom_ql = prom_ql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prom_ql is not None:
            result['promQL'] = self.prom_ql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('promQL') is not None:
            self.prom_ql = m.get('promQL')
        return self


class ListPolicyAddonsResponseBodyAddonsEnvironmentsPoliciesProtocols(TeaModel):
    def __init__(
        self,
        description: str = None,
        icon: str = None,
        label: str = None,
        name: str = None,
    ):
        self.description = description
        self.icon = icon
        self.label = label
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.icon is not None:
            result['icon'] = self.icon
        if self.label is not None:
            result['label'] = self.label
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListPolicyAddonsResponseBodyAddonsEnvironmentsPolicies(TeaModel):
    def __init__(
        self,
        alert_default_status: str = None,
        default_install: bool = None,
        enable_service_account: bool = None,
        metric_check_rule: ListPolicyAddonsResponseBodyAddonsEnvironmentsPoliciesMetricCheckRule = None,
        need_restart_after_integration: bool = None,
        protocols: List[ListPolicyAddonsResponseBodyAddonsEnvironmentsPoliciesProtocols] = None,
        target_addon_name: str = None,
    ):
        self.alert_default_status = alert_default_status
        self.default_install = default_install
        self.enable_service_account = enable_service_account
        self.metric_check_rule = metric_check_rule
        self.need_restart_after_integration = need_restart_after_integration
        self.protocols = protocols
        self.target_addon_name = target_addon_name

    def validate(self):
        if self.metric_check_rule:
            self.metric_check_rule.validate()
        if self.protocols:
            for k in self.protocols:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_default_status is not None:
            result['alertDefaultStatus'] = self.alert_default_status
        if self.default_install is not None:
            result['defaultInstall'] = self.default_install
        if self.enable_service_account is not None:
            result['enableServiceAccount'] = self.enable_service_account
        if self.metric_check_rule is not None:
            result['metricCheckRule'] = self.metric_check_rule.to_map()
        if self.need_restart_after_integration is not None:
            result['needRestartAfterIntegration'] = self.need_restart_after_integration
        result['protocols'] = []
        if self.protocols is not None:
            for k in self.protocols:
                result['protocols'].append(k.to_map() if k else None)
        if self.target_addon_name is not None:
            result['targetAddonName'] = self.target_addon_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertDefaultStatus') is not None:
            self.alert_default_status = m.get('alertDefaultStatus')
        if m.get('defaultInstall') is not None:
            self.default_install = m.get('defaultInstall')
        if m.get('enableServiceAccount') is not None:
            self.enable_service_account = m.get('enableServiceAccount')
        if m.get('metricCheckRule') is not None:
            temp_model = ListPolicyAddonsResponseBodyAddonsEnvironmentsPoliciesMetricCheckRule()
            self.metric_check_rule = temp_model.from_map(m['metricCheckRule'])
        if m.get('needRestartAfterIntegration') is not None:
            self.need_restart_after_integration = m.get('needRestartAfterIntegration')
        self.protocols = []
        if m.get('protocols') is not None:
            for k in m.get('protocols'):
                temp_model = ListPolicyAddonsResponseBodyAddonsEnvironmentsPoliciesProtocols()
                self.protocols.append(temp_model.from_map(k))
        if m.get('targetAddonName') is not None:
            self.target_addon_name = m.get('targetAddonName')
        return self


class ListPolicyAddonsResponseBodyAddonsEnvironments(TeaModel):
    def __init__(
        self,
        dependencies: ListPolicyAddonsResponseBodyAddonsEnvironmentsDependencies = None,
        description: str = None,
        enable: bool = None,
        label: str = None,
        name: str = None,
        policies: ListPolicyAddonsResponseBodyAddonsEnvironmentsPolicies = None,
    ):
        self.dependencies = dependencies
        self.description = description
        self.enable = enable
        self.label = label
        self.name = name
        self.policies = policies

    def validate(self):
        if self.dependencies:
            self.dependencies.validate()
        if self.policies:
            self.policies.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dependencies is not None:
            result['dependencies'] = self.dependencies.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.enable is not None:
            result['enable'] = self.enable
        if self.label is not None:
            result['label'] = self.label
        if self.name is not None:
            result['name'] = self.name
        if self.policies is not None:
            result['policies'] = self.policies.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dependencies') is not None:
            temp_model = ListPolicyAddonsResponseBodyAddonsEnvironmentsDependencies()
            self.dependencies = temp_model.from_map(m['dependencies'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('policies') is not None:
            temp_model = ListPolicyAddonsResponseBodyAddonsEnvironmentsPolicies()
            self.policies = temp_model.from_map(m['policies'])
        return self


class ListPolicyAddonsResponseBodyAddons(TeaModel):
    def __init__(
        self,
        alias: str = None,
        categories: List[str] = None,
        dashboards: List[ListPolicyAddonsResponseBodyAddonsDashboards] = None,
        description: str = None,
        environments: List[ListPolicyAddonsResponseBodyAddonsEnvironments] = None,
        icon: str = None,
        keywords: List[str] = None,
        language: str = None,
        latest_release_create_time: str = None,
        name: str = None,
        once: bool = None,
        scene: str = None,
        version: str = None,
        weight: int = None,
    ):
        self.alias = alias
        self.categories = categories
        self.dashboards = dashboards
        self.description = description
        self.environments = environments
        self.icon = icon
        self.keywords = keywords
        self.language = language
        self.latest_release_create_time = latest_release_create_time
        self.name = name
        self.once = once
        self.scene = scene
        self.version = version
        self.weight = weight

    def validate(self):
        if self.dashboards:
            for k in self.dashboards:
                if k:
                    k.validate()
        if self.environments:
            for k in self.environments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['alias'] = self.alias
        if self.categories is not None:
            result['categories'] = self.categories
        result['dashboards'] = []
        if self.dashboards is not None:
            for k in self.dashboards:
                result['dashboards'].append(k.to_map() if k else None)
        if self.description is not None:
            result['description'] = self.description
        result['environments'] = []
        if self.environments is not None:
            for k in self.environments:
                result['environments'].append(k.to_map() if k else None)
        if self.icon is not None:
            result['icon'] = self.icon
        if self.keywords is not None:
            result['keywords'] = self.keywords
        if self.language is not None:
            result['language'] = self.language
        if self.latest_release_create_time is not None:
            result['latestReleaseCreateTime'] = self.latest_release_create_time
        if self.name is not None:
            result['name'] = self.name
        if self.once is not None:
            result['once'] = self.once
        if self.scene is not None:
            result['scene'] = self.scene
        if self.version is not None:
            result['version'] = self.version
        if self.weight is not None:
            result['weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alias') is not None:
            self.alias = m.get('alias')
        if m.get('categories') is not None:
            self.categories = m.get('categories')
        self.dashboards = []
        if m.get('dashboards') is not None:
            for k in m.get('dashboards'):
                temp_model = ListPolicyAddonsResponseBodyAddonsDashboards()
                self.dashboards.append(temp_model.from_map(k))
        if m.get('description') is not None:
            self.description = m.get('description')
        self.environments = []
        if m.get('environments') is not None:
            for k in m.get('environments'):
                temp_model = ListPolicyAddonsResponseBodyAddonsEnvironments()
                self.environments.append(temp_model.from_map(k))
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('keywords') is not None:
            self.keywords = m.get('keywords')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('latestReleaseCreateTime') is not None:
            self.latest_release_create_time = m.get('latestReleaseCreateTime')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('once') is not None:
            self.once = m.get('once')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        return self


class ListPolicyAddonsResponseBody(TeaModel):
    def __init__(
        self,
        addons: List[ListPolicyAddonsResponseBodyAddons] = None,
        code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        self.addons = addons
        self.code = code
        self.message = message
        self.request_id = request_id
        self.success = success
        self.total = total

    def validate(self):
        if self.addons:
            for k in self.addons:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['addons'] = []
        if self.addons is not None:
            for k in self.addons:
                result['addons'].append(k.to_map() if k else None)
        if self.code is not None:
            result['code'] = self.code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addons = []
        if m.get('addons') is not None:
            for k in m.get('addons'):
                temp_model = ListPolicyAddonsResponseBodyAddons()
                self.addons.append(temp_model.from_map(k))
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListPolicyAddonsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPolicyAddonsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPolicyAddonsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPolicyDashboardsRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        scene: str = None,
    ):
        self.addon_name = addon_name
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['addonName'] = self.addon_name
        if self.scene is not None:
            result['scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonName') is not None:
            self.addon_name = m.get('addonName')
        if m.get('scene') is not None:
            self.scene = m.get('scene')
        return self


class ListPolicyDashboardsResponseBodyDashboards(TeaModel):
    def __init__(
        self,
        xxx: str = None,
        yyy: str = None,
    ):
        self.xxx = xxx
        self.yyy = yyy

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.xxx is not None:
            result['xxx'] = self.xxx
        if self.yyy is not None:
            result['yyy'] = self.yyy
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('xxx') is not None:
            self.xxx = m.get('xxx')
        if m.get('yyy') is not None:
            self.yyy = m.get('yyy')
        return self


class ListPolicyDashboardsResponseBodyDataDashboards(TeaModel):
    def __init__(
        self,
        folder_uid: str = None,
        region: str = None,
        tags: List[str] = None,
        title: str = None,
        uid: str = None,
        url: str = None,
    ):
        self.folder_uid = folder_uid
        self.region = region
        self.tags = tags
        self.title = title
        self.uid = uid
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.folder_uid is not None:
            result['folderUid'] = self.folder_uid
        if self.region is not None:
            result['region'] = self.region
        if self.tags is not None:
            result['tags'] = self.tags
        if self.title is not None:
            result['title'] = self.title
        if self.uid is not None:
            result['uid'] = self.uid
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('folderUid') is not None:
            self.folder_uid = m.get('folderUid')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('tags') is not None:
            self.tags = m.get('tags')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('uid') is not None:
            self.uid = m.get('uid')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class ListPolicyDashboardsResponseBodyData(TeaModel):
    def __init__(
        self,
        dashboards: ListPolicyDashboardsResponseBodyDataDashboards = None,
        total: str = None,
    ):
        self.dashboards = dashboards
        self.total = total

    def validate(self):
        if self.dashboards:
            self.dashboards.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dashboards is not None:
            result['dashboards'] = self.dashboards.to_map()
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dashboards') is not None:
            temp_model = ListPolicyDashboardsResponseBodyDataDashboards()
            self.dashboards = temp_model.from_map(m['dashboards'])
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListPolicyDashboardsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        dashboards: ListPolicyDashboardsResponseBodyDashboards = None,
        data: ListPolicyDashboardsResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: str = None,
        total: str = None,
    ):
        self.code = code
        self.dashboards = dashboards
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success
        self.total = total

    def validate(self):
        if self.dashboards:
            self.dashboards.validate()
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.dashboards is not None:
            result['dashboards'] = self.dashboards.to_map()
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('dashboards') is not None:
            temp_model = ListPolicyDashboardsResponseBodyDashboards()
            self.dashboards = temp_model.from_map(m['dashboards'])
        if m.get('data') is not None:
            temp_model = ListPolicyDashboardsResponseBodyData()
            self.data = temp_model.from_map(m['data'])
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListPolicyDashboardsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPolicyDashboardsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPolicyDashboardsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPromFrontVarsRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        product_id: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.product_id = product_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.product_id is not None:
            result['productId'] = self.product_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('productId') is not None:
            self.product_id = m.get('productId')
        return self


class ListPromFrontVarsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        vars: Dict[str, Any] = None,
    ):
        self.request_id = request_id
        self.vars = vars

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.vars is not None:
            result['vars'] = self.vars
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('vars') is not None:
            self.vars = m.get('vars')
        return self


class ListPromFrontVarsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPromFrontVarsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPromFrontVarsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPrometheusDashboardsRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        resource_group_id: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        return self


class ListPrometheusDashboardsResponseBodyPrometheusDashboards(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        tags: List[str] = None,
        title: str = None,
        uid: str = None,
        url: str = None,
    ):
        self.id = id
        self.name = name
        self.tags = tags
        self.title = title
        self.uid = uid
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.tags is not None:
            result['tags'] = self.tags
        if self.title is not None:
            result['title'] = self.title
        if self.uid is not None:
            result['uid'] = self.uid
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('tags') is not None:
            self.tags = m.get('tags')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('uid') is not None:
            self.uid = m.get('uid')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class ListPrometheusDashboardsResponseBody(TeaModel):
    def __init__(
        self,
        prometheus_dashboards: List[ListPrometheusDashboardsResponseBodyPrometheusDashboards] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.prometheus_dashboards = prometheus_dashboards
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.prometheus_dashboards:
            for k in self.prometheus_dashboards:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['prometheusDashboards'] = []
        if self.prometheus_dashboards is not None:
            for k in self.prometheus_dashboards:
                result['prometheusDashboards'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.prometheus_dashboards = []
        if m.get('prometheusDashboards') is not None:
            for k in m.get('prometheusDashboards'):
                temp_model = ListPrometheusDashboardsResponseBodyPrometheusDashboards()
                self.prometheus_dashboards.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListPrometheusDashboardsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPrometheusDashboardsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPrometheusDashboardsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPrometheusInstancesRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListPrometheusInstancesRequest(TeaModel):
    def __init__(
        self,
        filter_region_ids: str = None,
        max_results: int = None,
        next_token: str = None,
        prometheus_instance_ids: str = None,
        prometheus_instance_name: str = None,
        query_scene: str = None,
        resource_group_id: str = None,
        resource_type: str = None,
        sls_project: str = None,
        sls_store: str = None,
        tag: List[ListPrometheusInstancesRequestTag] = None,
        version: str = None,
        workspace: str = None,
    ):
        self.filter_region_ids = filter_region_ids
        self.max_results = max_results
        self.next_token = next_token
        self.prometheus_instance_ids = prometheus_instance_ids
        self.prometheus_instance_name = prometheus_instance_name
        self.query_scene = query_scene
        self.resource_group_id = resource_group_id
        self.resource_type = resource_type
        self.sls_project = sls_project
        self.sls_store = sls_store
        self.tag = tag
        self.version = version
        self.workspace = workspace

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter_region_ids is not None:
            result['filterRegionIds'] = self.filter_region_ids
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.prometheus_instance_ids is not None:
            result['prometheusInstanceIds'] = self.prometheus_instance_ids
        if self.prometheus_instance_name is not None:
            result['prometheusInstanceName'] = self.prometheus_instance_name
        if self.query_scene is not None:
            result['queryScene'] = self.query_scene
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        if self.sls_project is not None:
            result['slsProject'] = self.sls_project
        if self.sls_store is not None:
            result['slsStore'] = self.sls_store
        result['tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['tag'].append(k.to_map() if k else None)
        if self.version is not None:
            result['version'] = self.version
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('filterRegionIds') is not None:
            self.filter_region_ids = m.get('filterRegionIds')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('prometheusInstanceIds') is not None:
            self.prometheus_instance_ids = m.get('prometheusInstanceIds')
        if m.get('prometheusInstanceName') is not None:
            self.prometheus_instance_name = m.get('prometheusInstanceName')
        if m.get('queryScene') is not None:
            self.query_scene = m.get('queryScene')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        if m.get('slsProject') is not None:
            self.sls_project = m.get('slsProject')
        if m.get('slsStore') is not None:
            self.sls_store = m.get('slsStore')
        self.tag = []
        if m.get('tag') is not None:
            for k in m.get('tag'):
                temp_model = ListPrometheusInstancesRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListPrometheusInstancesResponseBodyPrometheusInstancesTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListPrometheusInstancesResponseBodyPrometheusInstances(TeaModel):
    def __init__(
        self,
        access_type: str = None,
        create_time: str = None,
        instance_type: str = None,
        payment_type: str = None,
        product: str = None,
        prometheus_instance_id: str = None,
        prometheus_instance_name: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        resource_type: str = None,
        status: str = None,
        support_auth_types: List[str] = None,
        tags: List[ListPrometheusInstancesResponseBodyPrometheusInstancesTags] = None,
        user_id: str = None,
        version: str = None,
        workspace: str = None,
    ):
        self.access_type = access_type
        self.create_time = create_time
        self.instance_type = instance_type
        self.payment_type = payment_type
        self.product = product
        self.prometheus_instance_id = prometheus_instance_id
        self.prometheus_instance_name = prometheus_instance_name
        self.region_id = region_id
        self.resource_group_id = resource_group_id
        self.resource_type = resource_type
        self.status = status
        self.support_auth_types = support_auth_types
        self.tags = tags
        self.user_id = user_id
        self.version = version
        self.workspace = workspace

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_type is not None:
            result['accessType'] = self.access_type
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.instance_type is not None:
            result['instanceType'] = self.instance_type
        if self.payment_type is not None:
            result['paymentType'] = self.payment_type
        if self.product is not None:
            result['product'] = self.product
        if self.prometheus_instance_id is not None:
            result['prometheusInstanceId'] = self.prometheus_instance_id
        if self.prometheus_instance_name is not None:
            result['prometheusInstanceName'] = self.prometheus_instance_name
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        if self.status is not None:
            result['status'] = self.status
        if self.support_auth_types is not None:
            result['supportAuthTypes'] = self.support_auth_types
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.version is not None:
            result['version'] = self.version
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessType') is not None:
            self.access_type = m.get('accessType')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('instanceType') is not None:
            self.instance_type = m.get('instanceType')
        if m.get('paymentType') is not None:
            self.payment_type = m.get('paymentType')
        if m.get('product') is not None:
            self.product = m.get('product')
        if m.get('prometheusInstanceId') is not None:
            self.prometheus_instance_id = m.get('prometheusInstanceId')
        if m.get('prometheusInstanceName') is not None:
            self.prometheus_instance_name = m.get('prometheusInstanceName')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('supportAuthTypes') is not None:
            self.support_auth_types = m.get('supportAuthTypes')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = ListPrometheusInstancesResponseBodyPrometheusInstancesTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListPrometheusInstancesResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        prometheus_instances: List[ListPrometheusInstancesResponseBodyPrometheusInstances] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.prometheus_instances = prometheus_instances
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.prometheus_instances:
            for k in self.prometheus_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['prometheusInstances'] = []
        if self.prometheus_instances is not None:
            for k in self.prometheus_instances:
                result['prometheusInstances'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.prometheus_instances = []
        if m.get('prometheusInstances') is not None:
            for k in m.get('prometheusInstances'):
                temp_model = ListPrometheusInstancesResponseBodyPrometheusInstances()
                self.prometheus_instances.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListPrometheusInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPrometheusInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPrometheusInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPrometheusMetricsRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        end_time: int = None,
        max_results: int = None,
        resource_group_id: str = None,
        start_time: int = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.end_time = end_time
        self.max_results = max_results
        self.resource_group_id = resource_group_id
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class ListPrometheusMetricsResponseBodyPrometheusMetrics(TeaModel):
    def __init__(
        self,
        count: str = None,
        fee_type: str = None,
        job: str = None,
        metric: str = None,
        percent: str = None,
    ):
        self.count = count
        self.fee_type = fee_type
        self.job = job
        self.metric = metric
        self.percent = percent

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['count'] = self.count
        if self.fee_type is not None:
            result['feeType'] = self.fee_type
        if self.job is not None:
            result['job'] = self.job
        if self.metric is not None:
            result['metric'] = self.metric
        if self.percent is not None:
            result['percent'] = self.percent
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('feeType') is not None:
            self.fee_type = m.get('feeType')
        if m.get('job') is not None:
            self.job = m.get('job')
        if m.get('metric') is not None:
            self.metric = m.get('metric')
        if m.get('percent') is not None:
            self.percent = m.get('percent')
        return self


class ListPrometheusMetricsResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        prometheus_metrics: List[ListPrometheusMetricsResponseBodyPrometheusMetrics] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.prometheus_metrics = prometheus_metrics
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.prometheus_metrics:
            for k in self.prometheus_metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        result['prometheusMetrics'] = []
        if self.prometheus_metrics is not None:
            for k in self.prometheus_metrics:
                result['prometheusMetrics'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        self.prometheus_metrics = []
        if m.get('prometheusMetrics') is not None:
            for k in m.get('prometheusMetrics'):
                temp_model = ListPrometheusMetricsResponseBodyPrometheusMetrics()
                self.prometheus_metrics.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListPrometheusMetricsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPrometheusMetricsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPrometheusMetricsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPrometheusViewsRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListPrometheusViewsRequest(TeaModel):
    def __init__(
        self,
        filter_region_ids: str = None,
        max_results: int = None,
        next_token: str = None,
        prometheus_view_ids: str = None,
        prometheus_view_name: str = None,
        resource_group_id: str = None,
        resource_type: str = None,
        tag: List[ListPrometheusViewsRequestTag] = None,
        version: str = None,
        workspace: str = None,
    ):
        self.filter_region_ids = filter_region_ids
        self.max_results = max_results
        self.next_token = next_token
        self.prometheus_view_ids = prometheus_view_ids
        self.prometheus_view_name = prometheus_view_name
        self.resource_group_id = resource_group_id
        self.resource_type = resource_type
        self.tag = tag
        self.version = version
        self.workspace = workspace

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter_region_ids is not None:
            result['filterRegionIds'] = self.filter_region_ids
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.prometheus_view_ids is not None:
            result['prometheusViewIds'] = self.prometheus_view_ids
        if self.prometheus_view_name is not None:
            result['prometheusViewName'] = self.prometheus_view_name
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        result['tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['tag'].append(k.to_map() if k else None)
        if self.version is not None:
            result['version'] = self.version
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('filterRegionIds') is not None:
            self.filter_region_ids = m.get('filterRegionIds')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('prometheusViewIds') is not None:
            self.prometheus_view_ids = m.get('prometheusViewIds')
        if m.get('prometheusViewName') is not None:
            self.prometheus_view_name = m.get('prometheusViewName')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        self.tag = []
        if m.get('tag') is not None:
            for k in m.get('tag'):
                temp_model = ListPrometheusViewsRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListPrometheusViewsShrinkRequest(TeaModel):
    def __init__(
        self,
        filter_region_ids: str = None,
        max_results: int = None,
        next_token: str = None,
        prometheus_view_ids: str = None,
        prometheus_view_name: str = None,
        resource_group_id: str = None,
        resource_type: str = None,
        tag_shrink: str = None,
        version: str = None,
        workspace: str = None,
    ):
        self.filter_region_ids = filter_region_ids
        self.max_results = max_results
        self.next_token = next_token
        self.prometheus_view_ids = prometheus_view_ids
        self.prometheus_view_name = prometheus_view_name
        self.resource_group_id = resource_group_id
        self.resource_type = resource_type
        self.tag_shrink = tag_shrink
        self.version = version
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter_region_ids is not None:
            result['filterRegionIds'] = self.filter_region_ids
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.prometheus_view_ids is not None:
            result['prometheusViewIds'] = self.prometheus_view_ids
        if self.prometheus_view_name is not None:
            result['prometheusViewName'] = self.prometheus_view_name
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        if self.tag_shrink is not None:
            result['tag'] = self.tag_shrink
        if self.version is not None:
            result['version'] = self.version
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('filterRegionIds') is not None:
            self.filter_region_ids = m.get('filterRegionIds')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('prometheusViewIds') is not None:
            self.prometheus_view_ids = m.get('prometheusViewIds')
        if m.get('prometheusViewName') is not None:
            self.prometheus_view_name = m.get('prometheusViewName')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        if m.get('tag') is not None:
            self.tag_shrink = m.get('tag')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListPrometheusViewsResponseBodyPrometheusViewsTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListPrometheusViewsResponseBodyPrometheusViews(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        instance_type: str = None,
        payment_type: str = None,
        product: str = None,
        prometheus_instance_count: int = None,
        prometheus_view_id: str = None,
        prometheus_view_name: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        resource_type: str = None,
        status: str = None,
        tags: List[ListPrometheusViewsResponseBodyPrometheusViewsTags] = None,
        user_id: str = None,
        version: str = None,
        workspace: str = None,
    ):
        self.create_time = create_time
        self.instance_type = instance_type
        self.payment_type = payment_type
        self.product = product
        self.prometheus_instance_count = prometheus_instance_count
        self.prometheus_view_id = prometheus_view_id
        self.prometheus_view_name = prometheus_view_name
        self.region_id = region_id
        self.resource_group_id = resource_group_id
        self.resource_type = resource_type
        self.status = status
        self.tags = tags
        self.user_id = user_id
        self.version = version
        self.workspace = workspace

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.instance_type is not None:
            result['instanceType'] = self.instance_type
        if self.payment_type is not None:
            result['paymentType'] = self.payment_type
        if self.product is not None:
            result['product'] = self.product
        if self.prometheus_instance_count is not None:
            result['prometheusInstanceCount'] = self.prometheus_instance_count
        if self.prometheus_view_id is not None:
            result['prometheusViewId'] = self.prometheus_view_id
        if self.prometheus_view_name is not None:
            result['prometheusViewName'] = self.prometheus_view_name
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        if self.status is not None:
            result['status'] = self.status
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.version is not None:
            result['version'] = self.version
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('instanceType') is not None:
            self.instance_type = m.get('instanceType')
        if m.get('paymentType') is not None:
            self.payment_type = m.get('paymentType')
        if m.get('product') is not None:
            self.product = m.get('product')
        if m.get('prometheusInstanceCount') is not None:
            self.prometheus_instance_count = m.get('prometheusInstanceCount')
        if m.get('prometheusViewId') is not None:
            self.prometheus_view_id = m.get('prometheusViewId')
        if m.get('prometheusViewName') is not None:
            self.prometheus_view_name = m.get('prometheusViewName')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        if m.get('status') is not None:
            self.status = m.get('status')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = ListPrometheusViewsResponseBodyPrometheusViewsTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListPrometheusViewsResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        prometheus_views: List[ListPrometheusViewsResponseBodyPrometheusViews] = None,
        request_id: str = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.prometheus_views = prometheus_views
        self.request_id = request_id
        self.total_count = total_count

    def validate(self):
        if self.prometheus_views:
            for k in self.prometheus_views:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['prometheusViews'] = []
        if self.prometheus_views is not None:
            for k in self.prometheus_views:
                result['prometheusViews'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.prometheus_views = []
        if m.get('prometheusViews') is not None:
            for k in m.get('prometheusViews'):
                temp_model = ListPrometheusViewsResponseBodyPrometheusViews()
                self.prometheus_views.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListPrometheusViewsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPrometheusViewsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPrometheusViewsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSiteMonitorsRequest(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        filter: str = None,
        max_results: int = None,
        next_token: str = None,
        payment_type: str = None,
        resource_group_id: str = None,
        site_monitor_id: str = None,
        site_monitor_name: str = None,
        skip: int = None,
    ):
        self.create_time = create_time
        self.filter = filter
        self.max_results = max_results
        self.next_token = next_token
        self.payment_type = payment_type
        self.resource_group_id = resource_group_id
        self.site_monitor_id = site_monitor_id
        self.site_monitor_name = site_monitor_name
        self.skip = skip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.filter is not None:
            result['filter'] = self.filter
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.payment_type is not None:
            result['paymentType'] = self.payment_type
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.site_monitor_id is not None:
            result['siteMonitorId'] = self.site_monitor_id
        if self.site_monitor_name is not None:
            result['siteMonitorName'] = self.site_monitor_name
        if self.skip is not None:
            result['skip'] = self.skip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('filter') is not None:
            self.filter = m.get('filter')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('paymentType') is not None:
            self.payment_type = m.get('paymentType')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('siteMonitorId') is not None:
            self.site_monitor_id = m.get('siteMonitorId')
        if m.get('siteMonitorName') is not None:
            self.site_monitor_name = m.get('siteMonitorName')
        if m.get('skip') is not None:
            self.skip = m.get('skip')
        return self


class ListSiteMonitorsResponseBodySiteMonitors(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        payment_type: str = None,
        resource_group_id: str = None,
        site_monitor_id: str = None,
        site_monitor_name: str = None,
    ):
        self.create_time = create_time
        self.payment_type = payment_type
        self.resource_group_id = resource_group_id
        self.site_monitor_id = site_monitor_id
        self.site_monitor_name = site_monitor_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.payment_type is not None:
            result['paymentType'] = self.payment_type
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.site_monitor_id is not None:
            result['siteMonitorId'] = self.site_monitor_id
        if self.site_monitor_name is not None:
            result['siteMonitorName'] = self.site_monitor_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('paymentType') is not None:
            self.payment_type = m.get('paymentType')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('siteMonitorId') is not None:
            self.site_monitor_id = m.get('siteMonitorId')
        if m.get('siteMonitorName') is not None:
            self.site_monitor_name = m.get('siteMonitorName')
        return self


class ListSiteMonitorsResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        site_monitors: List[ListSiteMonitorsResponseBodySiteMonitors] = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.site_monitors = site_monitors
        self.total_count = total_count

    def validate(self):
        if self.site_monitors:
            for k in self.site_monitors:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['siteMonitors'] = []
        if self.site_monitors is not None:
            for k in self.site_monitors:
                result['siteMonitors'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.site_monitors = []
        if m.get('siteMonitors') is not None:
            for k in m.get('siteMonitors'):
                temp_model = ListSiteMonitorsResponseBodySiteMonitors()
                self.site_monitors.append(temp_model.from_map(k))
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListSiteMonitorsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSiteMonitorsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSiteMonitorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSubscriptionsRequest(TeaModel):
    def __init__(
        self,
        enable: bool = None,
        max_results: int = None,
        next_token: str = None,
        subscription_id: str = None,
        subscription_name: str = None,
        workspace: str = None,
    ):
        self.enable = enable
        self.max_results = max_results
        self.next_token = next_token
        self.subscription_id = subscription_id
        self.subscription_name = subscription_name
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable is not None:
            result['enable'] = self.enable
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.subscription_id is not None:
            result['subscriptionId'] = self.subscription_id
        if self.subscription_name is not None:
            result['subscriptionName'] = self.subscription_name
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('subscriptionId') is not None:
            self.subscription_id = m.get('subscriptionId')
        if m.get('subscriptionName') is not None:
            self.subscription_name = m.get('subscriptionName')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListSubscriptionsResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        subscription_list: List[SubscriptionForView] = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.subscription_list = subscription_list

    def validate(self):
        if self.subscription_list:
            for k in self.subscription_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['subscriptionList'] = []
        if self.subscription_list is not None:
            for k in self.subscription_list:
                result['subscriptionList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.subscription_list = []
        if m.get('subscriptionList') is not None:
            for k in m.get('subscriptionList'):
                temp_model = SubscriptionForView()
                self.subscription_list.append(temp_model.from_map(k))
        return self


class ListSubscriptionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSubscriptionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSubscriptionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTransformersRequest(TeaModel):
    def __init__(
        self,
        enable: bool = None,
        max_results: int = None,
        next_token: str = None,
        transformer_id: str = None,
        transformer_name: str = None,
        workspace: str = None,
    ):
        self.enable = enable
        self.max_results = max_results
        self.next_token = next_token
        self.transformer_id = transformer_id
        self.transformer_name = transformer_name
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable is not None:
            result['enable'] = self.enable
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.transformer_id is not None:
            result['transformerId'] = self.transformer_id
        if self.transformer_name is not None:
            result['transformerName'] = self.transformer_name
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('transformerId') is not None:
            self.transformer_id = m.get('transformerId')
        if m.get('transformerName') is not None:
            self.transformer_name = m.get('transformerName')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListTransformersResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        transformer_list: List[TransformerForView] = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.transformer_list = transformer_list

    def validate(self):
        if self.transformer_list:
            for k in self.transformer_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['transformerList'] = []
        if self.transformer_list is not None:
            for k in self.transformer_list:
                result['transformerList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.transformer_list = []
        if m.get('transformerList') is not None:
            for k in m.get('transformerList'):
                temp_model = TransformerForView()
                self.transformer_list.append(temp_model.from_map(k))
        return self


class ListTransformersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTransformersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTransformersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUserEventHistogramsRequest(TeaModel):
    def __init__(
        self,
        from_: int = None,
        id: str = None,
        max_results: int = None,
        next_token: str = None,
        severity: str = None,
        source: str = None,
        source_type: str = None,
        status: str = None,
        sub_type: str = None,
        subject: str = None,
        to: int = None,
        type: str = None,
        workspace: str = None,
    ):
        # This parameter is required.
        self.from_ = from_
        self.id = id
        self.max_results = max_results
        self.next_token = next_token
        self.severity = severity
        self.source = source
        self.source_type = source_type
        self.status = status
        self.sub_type = sub_type
        self.subject = subject
        # This parameter is required.
        self.to = to
        self.type = type
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['from'] = self.from_
        if self.id is not None:
            result['id'] = self.id
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.severity is not None:
            result['severity'] = self.severity
        if self.source is not None:
            result['source'] = self.source
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.status is not None:
            result['status'] = self.status
        if self.sub_type is not None:
            result['subType'] = self.sub_type
        if self.subject is not None:
            result['subject'] = self.subject
        if self.to is not None:
            result['to'] = self.to
        if self.type is not None:
            result['type'] = self.type
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('severity') is not None:
            self.severity = m.get('severity')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('subType') is not None:
            self.sub_type = m.get('subType')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('to') is not None:
            self.to = m.get('to')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListUserEventHistogramsResponseBodyHistogramList(TeaModel):
    def __init__(
        self,
        count: int = None,
        from_: int = None,
        to: int = None,
    ):
        self.count = count
        self.from_ = from_
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['count'] = self.count
        if self.from_ is not None:
            result['from'] = self.from_
        if self.to is not None:
            result['to'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('to') is not None:
            self.to = m.get('to')
        return self


class ListUserEventHistogramsResponseBody(TeaModel):
    def __init__(
        self,
        histogram_list: List[ListUserEventHistogramsResponseBodyHistogramList] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.histogram_list = histogram_list
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id

    def validate(self):
        if self.histogram_list:
            for k in self.histogram_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['histogramList'] = []
        if self.histogram_list is not None:
            for k in self.histogram_list:
                result['histogramList'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.histogram_list = []
        if m.get('histogramList') is not None:
            for k in m.get('histogramList'):
                temp_model = ListUserEventHistogramsResponseBodyHistogramList()
                self.histogram_list.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListUserEventHistogramsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUserEventHistogramsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUserEventHistogramsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUserEventsRequest(TeaModel):
    def __init__(
        self,
        from_: int = None,
        id: str = None,
        max_results: int = None,
        next_token: str = None,
        severity: str = None,
        source: str = None,
        source_type: str = None,
        status: str = None,
        sub_type: str = None,
        subject: str = None,
        to: int = None,
        type: str = None,
        workspace: str = None,
    ):
        # This parameter is required.
        self.from_ = from_
        self.id = id
        self.max_results = max_results
        self.next_token = next_token
        self.severity = severity
        self.source = source
        self.source_type = source_type
        self.status = status
        self.sub_type = sub_type
        self.subject = subject
        # This parameter is required.
        self.to = to
        self.type = type
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['from'] = self.from_
        if self.id is not None:
            result['id'] = self.id
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.severity is not None:
            result['severity'] = self.severity
        if self.source is not None:
            result['source'] = self.source
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.status is not None:
            result['status'] = self.status
        if self.sub_type is not None:
            result['subType'] = self.sub_type
        if self.subject is not None:
            result['subject'] = self.subject
        if self.to is not None:
            result['to'] = self.to
        if self.type is not None:
            result['type'] = self.type
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('severity') is not None:
            self.severity = m.get('severity')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('subType') is not None:
            self.sub_type = m.get('subType')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('to') is not None:
            self.to = m.get('to')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListUserEventsResponseBodyEventListResource(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        tags: Dict[str, Any] = None,
        type: str = None,
        uri: str = None,
    ):
        self.id = id
        self.name = name
        self.tags = tags
        self.type = type
        self.uri = uri

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.tags is not None:
            result['tags'] = self.tags
        if self.type is not None:
            result['type'] = self.type
        if self.uri is not None:
            result['uri'] = self.uri
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('tags') is not None:
            self.tags = m.get('tags')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('uri') is not None:
            self.uri = m.get('uri')
        return self


class ListUserEventsResponseBodyEventList(TeaModel):
    def __init__(
        self,
        alert_event_integration_policy_uuid: str = None,
        data: Dict[str, str] = None,
        id: str = None,
        labels: Dict[str, Any] = None,
        resource: ListUserEventsResponseBodyEventListResource = None,
        severity: str = None,
        source: str = None,
        sourcetype: str = None,
        status: str = None,
        subject: str = None,
        subtype: str = None,
        timestamp: str = None,
        type: str = None,
        user_id: str = None,
        workspace: str = None,
    ):
        self.alert_event_integration_policy_uuid = alert_event_integration_policy_uuid
        self.data = data
        self.id = id
        self.labels = labels
        self.resource = resource
        self.severity = severity
        self.source = source
        self.sourcetype = sourcetype
        self.status = status
        self.subject = subject
        self.subtype = subtype
        self.timestamp = timestamp
        self.type = type
        self.user_id = user_id
        self.workspace = workspace

    def validate(self):
        if self.resource:
            self.resource.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_event_integration_policy_uuid is not None:
            result['alertEventIntegrationPolicyUuid'] = self.alert_event_integration_policy_uuid
        if self.data is not None:
            result['data'] = self.data
        if self.id is not None:
            result['id'] = self.id
        if self.labels is not None:
            result['labels'] = self.labels
        if self.resource is not None:
            result['resource'] = self.resource.to_map()
        if self.severity is not None:
            result['severity'] = self.severity
        if self.source is not None:
            result['source'] = self.source
        if self.sourcetype is not None:
            result['sourcetype'] = self.sourcetype
        if self.status is not None:
            result['status'] = self.status
        if self.subject is not None:
            result['subject'] = self.subject
        if self.subtype is not None:
            result['subtype'] = self.subtype
        if self.timestamp is not None:
            result['timestamp'] = self.timestamp
        if self.type is not None:
            result['type'] = self.type
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertEventIntegrationPolicyUuid') is not None:
            self.alert_event_integration_policy_uuid = m.get('alertEventIntegrationPolicyUuid')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('resource') is not None:
            temp_model = ListUserEventsResponseBodyEventListResource()
            self.resource = temp_model.from_map(m['resource'])
        if m.get('severity') is not None:
            self.severity = m.get('severity')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('sourcetype') is not None:
            self.sourcetype = m.get('sourcetype')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('subtype') is not None:
            self.subtype = m.get('subtype')
        if m.get('timestamp') is not None:
            self.timestamp = m.get('timestamp')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class ListUserEventsResponseBody(TeaModel):
    def __init__(
        self,
        event_list: List[ListUserEventsResponseBodyEventList] = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.event_list = event_list
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id

    def validate(self):
        if self.event_list:
            for k in self.event_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['eventList'] = []
        if self.event_list is not None:
            for k in self.event_list:
                result['eventList'].append(k.to_map() if k else None)
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.event_list = []
        if m.get('eventList') is not None:
            for k in m.get('eventList'):
                temp_model = ListUserEventsResponseBodyEventList()
                self.event_list.append(temp_model.from_map(k))
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListUserEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUserEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUserEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkspacesRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        region: str = None,
        workspace_name: str = None,
        workspace_name_list: List[str] = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.region = region
        self.workspace_name = workspace_name
        self.workspace_name_list = workspace_name_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.region is not None:
            result['region'] = self.region
        if self.workspace_name is not None:
            result['workspaceName'] = self.workspace_name
        if self.workspace_name_list is not None:
            result['workspaceNameList'] = self.workspace_name_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('workspaceName') is not None:
            self.workspace_name = m.get('workspaceName')
        if m.get('workspaceNameList') is not None:
            self.workspace_name_list = m.get('workspaceNameList')
        return self


class ListWorkspacesShrinkRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        region: str = None,
        workspace_name: str = None,
        workspace_name_list_shrink: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.region = region
        self.workspace_name = workspace_name
        self.workspace_name_list_shrink = workspace_name_list_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.region is not None:
            result['region'] = self.region
        if self.workspace_name is not None:
            result['workspaceName'] = self.workspace_name
        if self.workspace_name_list_shrink is not None:
            result['workspaceNameList'] = self.workspace_name_list_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('workspaceName') is not None:
            self.workspace_name = m.get('workspaceName')
        if m.get('workspaceNameList') is not None:
            self.workspace_name_list_shrink = m.get('workspaceNameList')
        return self


class ListWorkspacesResponseBodyWorkspaces(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        display_name: str = None,
        last_modify_time: str = None,
        region_id: str = None,
        sls_project: str = None,
        workspace_name: str = None,
    ):
        # Use the UTC time format: yyyy-MM-ddTHH:mm:ssZ
        self.create_time = create_time
        # 工作空间描述
        self.description = description
        self.display_name = display_name
        # Use the UTC time format: yyyy-MM-ddTHH:mm:ssZ
        self.last_modify_time = last_modify_time
        # 地域ID
        self.region_id = region_id
        # 工作空间绑定的日志服务项目名称
        self.sls_project = sls_project
        # 工作空间名称
        # 
        # This parameter is required.
        self.workspace_name = workspace_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.last_modify_time is not None:
            result['lastModifyTime'] = self.last_modify_time
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.sls_project is not None:
            result['slsProject'] = self.sls_project
        if self.workspace_name is not None:
            result['workspaceName'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('lastModifyTime') is not None:
            self.last_modify_time = m.get('lastModifyTime')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('slsProject') is not None:
            self.sls_project = m.get('slsProject')
        if m.get('workspaceName') is not None:
            self.workspace_name = m.get('workspaceName')
        return self


class ListWorkspacesResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total: int = None,
        workspaces: List[ListWorkspacesResponseBodyWorkspaces] = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.total = total
        self.workspaces = workspaces

    def validate(self):
        if self.workspaces:
            for k in self.workspaces:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total is not None:
            result['total'] = self.total
        result['workspaces'] = []
        if self.workspaces is not None:
            for k in self.workspaces:
                result['workspaces'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('total') is not None:
            self.total = m.get('total')
        self.workspaces = []
        if m.get('workspaces') is not None:
            for k in m.get('workspaces'):
                temp_model = ListWorkspacesResponseBodyWorkspaces()
                self.workspaces.append(temp_model.from_map(k))
        return self


class ListWorkspacesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWorkspacesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkspacesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OpenCmsServiceResponseBody(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        request_id: str = None,
    ):
        self.enabled = enabled
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class OpenCmsServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OpenCmsServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OpenCmsServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PatchAlertRuleRequest(TeaModel):
    def __init__(
        self,
        alert_metric_input: AlertRuleAlertMetricInput = None,
        annotations: Dict[str, str] = None,
        condition: AlertRuleCondition = None,
        display_name: str = None,
        effect_time: AlertRuleTimeSpan = None,
        interval: int = None,
        labels: Dict[str, str] = None,
        level: str = None,
        message: str = None,
        query: AlertRuleQuery = None,
        send: AlertRuleSend = None,
    ):
        self.alert_metric_input = alert_metric_input
        # 规则注解，允许设置长文本
        self.annotations = annotations
        self.condition = condition
        # 代表资源名称的资源属性字段
        self.display_name = display_name
        self.effect_time = effect_time
        self.interval = interval
        self.labels = labels
        # 告警级别，CRITICAL,ERROR,WARNING,INFO，默认INFO，
        self.level = level
        # 告警规则的通知消息内容
        self.message = message
        self.query = query
        self.send = send

    def validate(self):
        if self.alert_metric_input:
            self.alert_metric_input.validate()
        if self.condition:
            self.condition.validate()
        if self.effect_time:
            self.effect_time.validate()
        if self.query:
            self.query.validate()
        if self.send:
            self.send.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_metric_input is not None:
            result['alertMetricInput'] = self.alert_metric_input.to_map()
        if self.annotations is not None:
            result['annotations'] = self.annotations
        if self.condition is not None:
            result['condition'] = self.condition.to_map()
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.effect_time is not None:
            result['effectTime'] = self.effect_time.to_map()
        if self.interval is not None:
            result['interval'] = self.interval
        if self.labels is not None:
            result['labels'] = self.labels
        if self.level is not None:
            result['level'] = self.level
        if self.message is not None:
            result['message'] = self.message
        if self.query is not None:
            result['query'] = self.query.to_map()
        if self.send is not None:
            result['send'] = self.send.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertMetricInput') is not None:
            temp_model = AlertRuleAlertMetricInput()
            self.alert_metric_input = temp_model.from_map(m['alertMetricInput'])
        if m.get('annotations') is not None:
            self.annotations = m.get('annotations')
        if m.get('condition') is not None:
            temp_model = AlertRuleCondition()
            self.condition = temp_model.from_map(m['condition'])
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('effectTime') is not None:
            temp_model = AlertRuleTimeSpan()
            self.effect_time = temp_model.from_map(m['effectTime'])
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('query') is not None:
            temp_model = AlertRuleQuery()
            self.query = temp_model.from_map(m['query'])
        if m.get('send') is not None:
            temp_model = AlertRuleSend()
            self.send = temp_model.from_map(m['send'])
        return self


class PatchAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        data: int = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class PatchAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PatchAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PatchAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutIncidentRobotCommandRequest(TeaModel):
    def __init__(
        self,
        command: str = None,
        content: str = None,
        id_code: str = None,
        session_id: str = None,
    ):
        self.command = command
        self.content = content
        self.id_code = id_code
        self.session_id = session_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['command'] = self.command
        if self.content is not None:
            result['content'] = self.content
        if self.id_code is not None:
            result['idCode'] = self.id_code
        if self.session_id is not None:
            result['sessionId'] = self.session_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('command') is not None:
            self.command = m.get('command')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('idCode') is not None:
            self.id_code = m.get('idCode')
        if m.get('sessionId') is not None:
            self.session_id = m.get('sessionId')
        return self


class PutIncidentRobotCommandResponseBody(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        page_number: int = None,
        page_size: int = None,
        request_id: str = None,
        result_obj: Any = None,
        total: int = None,
    ):
        self.next_token = next_token
        self.page_number = page_number
        self.page_size = page_size
        self.request_id = request_id
        self.result_obj = result_obj
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_number is not None:
            result['pageNumber'] = self.page_number
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result_obj is not None:
            result['resultObj'] = self.result_obj
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageNumber') is not None:
            self.page_number = m.get('pageNumber')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('resultObj') is not None:
            self.result_obj = m.get('resultObj')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class PutIncidentRobotCommandResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PutIncidentRobotCommandResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutIncidentRobotCommandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutWorkspaceRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        display_name: str = None,
        sls_project: str = None,
    ):
        # 工作空间描述
        self.description = description
        self.display_name = display_name
        # 工作空间绑定的日志服务项目名称
        # 
        # This parameter is required.
        self.sls_project = sls_project

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.sls_project is not None:
            result['slsProject'] = self.sls_project
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('slsProject') is not None:
            self.sls_project = m.get('slsProject')
        return self


class PutWorkspaceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        workspace_name: str = None,
    ):
        self.request_id = request_id
        self.workspace_name = workspace_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.workspace_name is not None:
            result['workspaceName'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('workspaceName') is not None:
            self.workspace_name = m.get('workspaceName')
        return self


class PutWorkspaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PutWorkspaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutWorkspaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RenderAlertMetricRequest(TeaModel):
    def __init__(
        self,
        filter_values: List[AlertRuleAlertMetricInputFilterValue] = None,
        param_values: List[AlertRuleAlertMetricInputParamValue] = None,
    ):
        self.filter_values = filter_values
        self.param_values = param_values

    def validate(self):
        if self.filter_values:
            for k in self.filter_values:
                if k:
                    k.validate()
        if self.param_values:
            for k in self.param_values:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['filterValues'] = []
        if self.filter_values is not None:
            for k in self.filter_values:
                result['filterValues'].append(k.to_map() if k else None)
        result['paramValues'] = []
        if self.param_values is not None:
            for k in self.param_values:
                result['paramValues'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.filter_values = []
        if m.get('filterValues') is not None:
            for k in m.get('filterValues'):
                temp_model = AlertRuleAlertMetricInputFilterValue()
                self.filter_values.append(temp_model.from_map(k))
        self.param_values = []
        if m.get('paramValues') is not None:
            for k in m.get('paramValues'):
                temp_model = AlertRuleAlertMetricInputParamValue()
                self.param_values.append(temp_model.from_map(k))
        return self


class RenderAlertMetricShrinkRequest(TeaModel):
    def __init__(
        self,
        filter_values_shrink: str = None,
        param_values_shrink: str = None,
    ):
        self.filter_values_shrink = filter_values_shrink
        self.param_values_shrink = param_values_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter_values_shrink is not None:
            result['filterValues'] = self.filter_values_shrink
        if self.param_values_shrink is not None:
            result['paramValues'] = self.param_values_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('filterValues') is not None:
            self.filter_values_shrink = m.get('filterValues')
        if m.get('paramValues') is not None:
            self.param_values_shrink = m.get('paramValues')
        return self


class RenderAlertMetricResponseBody(TeaModel):
    def __init__(
        self,
        alert_metric_id: str = None,
        expr: str = None,
        request_id: str = None,
    ):
        self.alert_metric_id = alert_metric_id
        self.expr = expr
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_metric_id is not None:
            result['alertMetricId'] = self.alert_metric_id
        if self.expr is not None:
            result['expr'] = self.expr
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertMetricId') is not None:
            self.alert_metric_id = m.get('alertMetricId')
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class RenderAlertMetricResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RenderAlertMetricResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RenderAlertMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResendVerifyActivateRequest(TeaModel):
    def __init__(
        self,
        channel_type: str = None,
    ):
        self.channel_type = channel_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_type is not None:
            result['channelType'] = self.channel_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('channelType') is not None:
            self.channel_type = m.get('channelType')
        return self


class ResendVerifyActivateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ResendVerifyActivateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResendVerifyActivateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResendVerifyActivateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResolveIncidentRequest(TeaModel):
    def __init__(
        self,
        incident_id: str = None,
    ):
        # This parameter is required.
        self.incident_id = incident_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.incident_id is not None:
            result['incidentId'] = self.incident_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('incidentId') is not None:
            self.incident_id = m.get('incidentId')
        return self


class ResolveIncidentResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ResolveIncidentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResolveIncidentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResolveIncidentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TestDeleteWorkspaceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class TestDeleteWorkspaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TestDeleteWorkspaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TestDeleteWorkspaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TestGetWorkspaceResponseBody(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        display_name: str = None,
        last_modify_time: str = None,
        region_id: str = None,
        request_id: str = None,
        sls_project: str = None,
        workspace_name: str = None,
    ):
        # Use the UTC time format: yyyy-MM-ddTHH:mm:ss.SSSZ
        self.create_time = create_time
        # 工作空间描述
        self.description = description
        self.display_name = display_name
        # Use the UTC time format: yyyy-MM-ddTHH:mm:ssZ
        self.last_modify_time = last_modify_time
        # 地域ID
        self.region_id = region_id
        self.request_id = request_id
        # 工作空间绑定的日志服务项目名称
        self.sls_project = sls_project
        # 工作空间名称
        # 
        # This parameter is required.
        self.workspace_name = workspace_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.last_modify_time is not None:
            result['lastModifyTime'] = self.last_modify_time
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.sls_project is not None:
            result['slsProject'] = self.sls_project
        if self.workspace_name is not None:
            result['workspaceName'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('lastModifyTime') is not None:
            self.last_modify_time = m.get('lastModifyTime')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('slsProject') is not None:
            self.sls_project = m.get('slsProject')
        if m.get('workspaceName') is not None:
            self.workspace_name = m.get('workspaceName')
        return self


class TestGetWorkspaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TestGetWorkspaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TestGetWorkspaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TestListWorkspaceRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        region: str = None,
        workspace_name: str = None,
        workspace_name_list: List[str] = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.region = region
        self.workspace_name = workspace_name
        self.workspace_name_list = workspace_name_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.region is not None:
            result['region'] = self.region
        if self.workspace_name is not None:
            result['workspaceName'] = self.workspace_name
        if self.workspace_name_list is not None:
            result['workspaceNameList'] = self.workspace_name_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('workspaceName') is not None:
            self.workspace_name = m.get('workspaceName')
        if m.get('workspaceNameList') is not None:
            self.workspace_name_list = m.get('workspaceNameList')
        return self


class TestListWorkspaceShrinkRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        region: str = None,
        workspace_name: str = None,
        workspace_name_list_shrink: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.region = region
        self.workspace_name = workspace_name
        self.workspace_name_list_shrink = workspace_name_list_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.region is not None:
            result['region'] = self.region
        if self.workspace_name is not None:
            result['workspaceName'] = self.workspace_name
        if self.workspace_name_list_shrink is not None:
            result['workspaceNameList'] = self.workspace_name_list_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('workspaceName') is not None:
            self.workspace_name = m.get('workspaceName')
        if m.get('workspaceNameList') is not None:
            self.workspace_name_list_shrink = m.get('workspaceNameList')
        return self


class TestListWorkspaceResponseBodyWorkspaces(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        display_name: str = None,
        last_modify_time: str = None,
        region_id: str = None,
        sls_project: str = None,
        workspace_name: str = None,
    ):
        # Use the UTC time format: yyyy-MM-ddTHH:mm:ssZ
        self.create_time = create_time
        # 工作空间描述
        self.description = description
        self.display_name = display_name
        # Use the UTC time format: yyyy-MM-ddTHH:mm:ssZ
        self.last_modify_time = last_modify_time
        # 地域ID
        self.region_id = region_id
        # 工作空间绑定的日志服务项目名称
        self.sls_project = sls_project
        # 工作空间名称
        # 
        # This parameter is required.
        self.workspace_name = workspace_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.last_modify_time is not None:
            result['lastModifyTime'] = self.last_modify_time
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.sls_project is not None:
            result['slsProject'] = self.sls_project
        if self.workspace_name is not None:
            result['workspaceName'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('lastModifyTime') is not None:
            self.last_modify_time = m.get('lastModifyTime')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('slsProject') is not None:
            self.sls_project = m.get('slsProject')
        if m.get('workspaceName') is not None:
            self.workspace_name = m.get('workspaceName')
        return self


class TestListWorkspaceResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        total: int = None,
        workspaces: List[TestListWorkspaceResponseBodyWorkspaces] = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.total = total
        self.workspaces = workspaces

    def validate(self):
        if self.workspaces:
            for k in self.workspaces:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total is not None:
            result['total'] = self.total
        result['workspaces'] = []
        if self.workspaces is not None:
            for k in self.workspaces:
                result['workspaces'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('total') is not None:
            self.total = m.get('total')
        self.workspaces = []
        if m.get('workspaces') is not None:
            for k in m.get('workspaces'):
                temp_model = TestListWorkspaceResponseBodyWorkspaces()
                self.workspaces.append(temp_model.from_map(k))
        return self


class TestListWorkspaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TestListWorkspaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TestListWorkspaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TestPutWorkspaceRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class TestPutWorkspaceRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        display_name: str = None,
        resource_group_id: str = None,
        sls_project: str = None,
        tags: List[TestPutWorkspaceRequestTags] = None,
    ):
        # 工作空间描述
        self.description = description
        self.display_name = display_name
        self.resource_group_id = resource_group_id
        # 工作空间绑定的日志服务项目名称
        # 
        # This parameter is required.
        self.sls_project = sls_project
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.sls_project is not None:
            result['slsProject'] = self.sls_project
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('slsProject') is not None:
            self.sls_project = m.get('slsProject')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = TestPutWorkspaceRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class TestPutWorkspaceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        workspace_name: str = None,
    ):
        self.request_id = request_id
        self.workspace_name = workspace_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.workspace_name is not None:
            result['workspaceName'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('workspaceName') is not None:
            self.workspace_name = m.get('workspaceName')
        return self


class TestPutWorkspaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TestPutWorkspaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TestPutWorkspaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAddonReleaseRequest(TeaModel):
    def __init__(
        self,
        addon_version: str = None,
        dry_run: bool = None,
        values: str = None,
    ):
        self.addon_version = addon_version
        self.dry_run = dry_run
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_version is not None:
            result['addonVersion'] = self.addon_version
        if self.dry_run is not None:
            result['dryRun'] = self.dry_run
        if self.values is not None:
            result['values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonVersion') is not None:
            self.addon_version = m.get('addonVersion')
        if m.get('dryRun') is not None:
            self.dry_run = m.get('dryRun')
        if m.get('values') is not None:
            self.values = m.get('values')
        return self


class UpdateAddonReleaseResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateAddonReleaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAddonReleaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAddonReleaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAggTaskGroupRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class UpdateAggTaskGroupRequest(TeaModel):
    def __init__(
        self,
        agg_task_group_config: str = None,
        agg_task_group_config_type: str = None,
        agg_task_group_name: str = None,
        cron_expr: str = None,
        delay: int = None,
        description: str = None,
        from_time: int = None,
        max_retries: int = None,
        max_run_time_in_seconds: int = None,
        precheck_string: str = None,
        schedule_mode: str = None,
        schedule_time_expr: str = None,
        status: str = None,
        tags: List[UpdateAggTaskGroupRequestTags] = None,
        target_prometheus_id: str = None,
        to_time: int = None,
    ):
        # This parameter is required.
        self.agg_task_group_config = agg_task_group_config
        self.agg_task_group_config_type = agg_task_group_config_type
        self.agg_task_group_name = agg_task_group_name
        self.cron_expr = cron_expr
        self.delay = delay
        self.description = description
        self.from_time = from_time
        self.max_retries = max_retries
        self.max_run_time_in_seconds = max_run_time_in_seconds
        self.precheck_string = precheck_string
        self.schedule_mode = schedule_mode
        self.schedule_time_expr = schedule_time_expr
        self.status = status
        self.tags = tags
        # This parameter is required.
        self.target_prometheus_id = target_prometheus_id
        self.to_time = to_time

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agg_task_group_config is not None:
            result['aggTaskGroupConfig'] = self.agg_task_group_config
        if self.agg_task_group_config_type is not None:
            result['aggTaskGroupConfigType'] = self.agg_task_group_config_type
        if self.agg_task_group_name is not None:
            result['aggTaskGroupName'] = self.agg_task_group_name
        if self.cron_expr is not None:
            result['cronExpr'] = self.cron_expr
        if self.delay is not None:
            result['delay'] = self.delay
        if self.description is not None:
            result['description'] = self.description
        if self.from_time is not None:
            result['fromTime'] = self.from_time
        if self.max_retries is not None:
            result['maxRetries'] = self.max_retries
        if self.max_run_time_in_seconds is not None:
            result['maxRunTimeInSeconds'] = self.max_run_time_in_seconds
        if self.precheck_string is not None:
            result['precheckString'] = self.precheck_string
        if self.schedule_mode is not None:
            result['scheduleMode'] = self.schedule_mode
        if self.schedule_time_expr is not None:
            result['scheduleTimeExpr'] = self.schedule_time_expr
        if self.status is not None:
            result['status'] = self.status
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.target_prometheus_id is not None:
            result['targetPrometheusId'] = self.target_prometheus_id
        if self.to_time is not None:
            result['toTime'] = self.to_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aggTaskGroupConfig') is not None:
            self.agg_task_group_config = m.get('aggTaskGroupConfig')
        if m.get('aggTaskGroupConfigType') is not None:
            self.agg_task_group_config_type = m.get('aggTaskGroupConfigType')
        if m.get('aggTaskGroupName') is not None:
            self.agg_task_group_name = m.get('aggTaskGroupName')
        if m.get('cronExpr') is not None:
            self.cron_expr = m.get('cronExpr')
        if m.get('delay') is not None:
            self.delay = m.get('delay')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('fromTime') is not None:
            self.from_time = m.get('fromTime')
        if m.get('maxRetries') is not None:
            self.max_retries = m.get('maxRetries')
        if m.get('maxRunTimeInSeconds') is not None:
            self.max_run_time_in_seconds = m.get('maxRunTimeInSeconds')
        if m.get('precheckString') is not None:
            self.precheck_string = m.get('precheckString')
        if m.get('scheduleMode') is not None:
            self.schedule_mode = m.get('scheduleMode')
        if m.get('scheduleTimeExpr') is not None:
            self.schedule_time_expr = m.get('scheduleTimeExpr')
        if m.get('status') is not None:
            self.status = m.get('status')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = UpdateAggTaskGroupRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('targetPrometheusId') is not None:
            self.target_prometheus_id = m.get('targetPrometheusId')
        if m.get('toTime') is not None:
            self.to_time = m.get('toTime')
        return self


class UpdateAggTaskGroupResponseBody(TeaModel):
    def __init__(
        self,
        agg_task_group_config_hash: str = None,
        agg_task_group_id: str = None,
        agg_task_group_name: str = None,
        request_id: str = None,
        source_prometheus_id: str = None,
        status: str = None,
    ):
        self.agg_task_group_config_hash = agg_task_group_config_hash
        self.agg_task_group_id = agg_task_group_id
        self.agg_task_group_name = agg_task_group_name
        self.request_id = request_id
        self.source_prometheus_id = source_prometheus_id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agg_task_group_config_hash is not None:
            result['aggTaskGroupConfigHash'] = self.agg_task_group_config_hash
        if self.agg_task_group_id is not None:
            result['aggTaskGroupId'] = self.agg_task_group_id
        if self.agg_task_group_name is not None:
            result['aggTaskGroupName'] = self.agg_task_group_name
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.source_prometheus_id is not None:
            result['sourcePrometheusId'] = self.source_prometheus_id
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aggTaskGroupConfigHash') is not None:
            self.agg_task_group_config_hash = m.get('aggTaskGroupConfigHash')
        if m.get('aggTaskGroupId') is not None:
            self.agg_task_group_id = m.get('aggTaskGroupId')
        if m.get('aggTaskGroupName') is not None:
            self.agg_task_group_name = m.get('aggTaskGroupName')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('sourcePrometheusId') is not None:
            self.source_prometheus_id = m.get('sourcePrometheusId')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class UpdateAggTaskGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAggTaskGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAggTaskGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAggTaskGroupStatusRequest(TeaModel):
    def __init__(
        self,
        status: str = None,
    ):
        # This parameter is required.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class UpdateAggTaskGroupStatusResponseBody(TeaModel):
    def __init__(
        self,
        agg_task_group_config_hash: str = None,
        agg_task_group_id: str = None,
        agg_task_group_name: str = None,
        request_id: str = None,
        source_prometheus_id: str = None,
        status: str = None,
    ):
        self.agg_task_group_config_hash = agg_task_group_config_hash
        self.agg_task_group_id = agg_task_group_id
        self.agg_task_group_name = agg_task_group_name
        self.request_id = request_id
        self.source_prometheus_id = source_prometheus_id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agg_task_group_config_hash is not None:
            result['aggTaskGroupConfigHash'] = self.agg_task_group_config_hash
        if self.agg_task_group_id is not None:
            result['aggTaskGroupId'] = self.agg_task_group_id
        if self.agg_task_group_name is not None:
            result['aggTaskGroupName'] = self.agg_task_group_name
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.source_prometheus_id is not None:
            result['sourcePrometheusId'] = self.source_prometheus_id
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aggTaskGroupConfigHash') is not None:
            self.agg_task_group_config_hash = m.get('aggTaskGroupConfigHash')
        if m.get('aggTaskGroupId') is not None:
            self.agg_task_group_id = m.get('aggTaskGroupId')
        if m.get('aggTaskGroupName') is not None:
            self.agg_task_group_name = m.get('aggTaskGroupName')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('sourcePrometheusId') is not None:
            self.source_prometheus_id = m.get('sourcePrometheusId')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class UpdateAggTaskGroupStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAggTaskGroupStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAggTaskGroupStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAlertActionRequestEssParam(TeaModel):
    def __init__(
        self,
        ess_group_id: str = None,
        ess_rule_id: str = None,
        region_id: str = None,
    ):
        self.ess_group_id = ess_group_id
        self.ess_rule_id = ess_rule_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ess_group_id is not None:
            result['essGroupId'] = self.ess_group_id
        if self.ess_rule_id is not None:
            result['essRuleId'] = self.ess_rule_id
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('essGroupId') is not None:
            self.ess_group_id = m.get('essGroupId')
        if m.get('essRuleId') is not None:
            self.ess_rule_id = m.get('essRuleId')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class UpdateAlertActionRequestFcParam(TeaModel):
    def __init__(
        self,
        function: str = None,
        region_id: str = None,
        service: str = None,
    ):
        self.function = function
        self.region_id = region_id
        self.service = service

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function is not None:
            result['function'] = self.function
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.service is not None:
            result['service'] = self.service
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('function') is not None:
            self.function = m.get('function')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('service') is not None:
            self.service = m.get('service')
        return self


class UpdateAlertActionRequestMnsParam(TeaModel):
    def __init__(
        self,
        mns_type: str = None,
        name: str = None,
        region_id: str = None,
    ):
        self.mns_type = mns_type
        self.name = name
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mns_type is not None:
            result['mnsType'] = self.mns_type
        if self.name is not None:
            result['name'] = self.name
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('mnsType') is not None:
            self.mns_type = m.get('mnsType')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class UpdateAlertActionRequestPagerDutyParam(TeaModel):
    def __init__(
        self,
        key: str = None,
        url: str = None,
    ):
        self.key = key
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class UpdateAlertActionRequestSlsParam(TeaModel):
    def __init__(
        self,
        logstore: str = None,
        project: str = None,
        region_id: str = None,
    ):
        self.logstore = logstore
        self.project = project
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logstore is not None:
            result['logstore'] = self.logstore
        if self.project is not None:
            result['project'] = self.project
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('logstore') is not None:
            self.logstore = m.get('logstore')
        if m.get('project') is not None:
            self.project = m.get('project')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class UpdateAlertActionRequestWebhookParam(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        headers: Dict[str, str] = None,
        method: str = None,
        url: str = None,
    ):
        self.content_type = content_type
        self.headers = headers
        self.method = method
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.headers is not None:
            result['headers'] = self.headers
        if self.method is not None:
            result['method'] = self.method
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('method') is not None:
            self.method = m.get('method')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class UpdateAlertActionRequest(TeaModel):
    def __init__(
        self,
        alert_action_name: str = None,
        ess_param: UpdateAlertActionRequestEssParam = None,
        fc_param: UpdateAlertActionRequestFcParam = None,
        mns_param: UpdateAlertActionRequestMnsParam = None,
        pager_duty_param: UpdateAlertActionRequestPagerDutyParam = None,
        sls_param: UpdateAlertActionRequestSlsParam = None,
        source: str = None,
        type: str = None,
        webhook_param: UpdateAlertActionRequestWebhookParam = None,
    ):
        self.alert_action_name = alert_action_name
        self.ess_param = ess_param
        self.fc_param = fc_param
        self.mns_param = mns_param
        self.pager_duty_param = pager_duty_param
        self.sls_param = sls_param
        self.source = source
        self.type = type
        self.webhook_param = webhook_param

    def validate(self):
        if self.ess_param:
            self.ess_param.validate()
        if self.fc_param:
            self.fc_param.validate()
        if self.mns_param:
            self.mns_param.validate()
        if self.pager_duty_param:
            self.pager_duty_param.validate()
        if self.sls_param:
            self.sls_param.validate()
        if self.webhook_param:
            self.webhook_param.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_action_name is not None:
            result['alertActionName'] = self.alert_action_name
        if self.ess_param is not None:
            result['essParam'] = self.ess_param.to_map()
        if self.fc_param is not None:
            result['fcParam'] = self.fc_param.to_map()
        if self.mns_param is not None:
            result['mnsParam'] = self.mns_param.to_map()
        if self.pager_duty_param is not None:
            result['pagerDutyParam'] = self.pager_duty_param.to_map()
        if self.sls_param is not None:
            result['slsParam'] = self.sls_param.to_map()
        if self.source is not None:
            result['source'] = self.source
        if self.type is not None:
            result['type'] = self.type
        if self.webhook_param is not None:
            result['webhookParam'] = self.webhook_param.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertActionName') is not None:
            self.alert_action_name = m.get('alertActionName')
        if m.get('essParam') is not None:
            temp_model = UpdateAlertActionRequestEssParam()
            self.ess_param = temp_model.from_map(m['essParam'])
        if m.get('fcParam') is not None:
            temp_model = UpdateAlertActionRequestFcParam()
            self.fc_param = temp_model.from_map(m['fcParam'])
        if m.get('mnsParam') is not None:
            temp_model = UpdateAlertActionRequestMnsParam()
            self.mns_param = temp_model.from_map(m['mnsParam'])
        if m.get('pagerDutyParam') is not None:
            temp_model = UpdateAlertActionRequestPagerDutyParam()
            self.pager_duty_param = temp_model.from_map(m['pagerDutyParam'])
        if m.get('slsParam') is not None:
            temp_model = UpdateAlertActionRequestSlsParam()
            self.sls_param = temp_model.from_map(m['slsParam'])
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('webhookParam') is not None:
            temp_model = UpdateAlertActionRequestWebhookParam()
            self.webhook_param = temp_model.from_map(m['webhookParam'])
        return self


class UpdateAlertActionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateAlertActionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAlertActionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAlertActionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAlertEventIntegrationPolicyRequest(TeaModel):
    def __init__(
        self,
        body: AlertEventIntegrationPolicyForModify = None,
        client_token: str = None,
        workspace: str = None,
    ):
        self.body = body
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body.to_map()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            temp_model = AlertEventIntegrationPolicyForModify()
            self.body = temp_model.from_map(m['body'])
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class UpdateAlertEventIntegrationPolicyResponseBody(TeaModel):
    def __init__(
        self,
        alert_event_integration_policy_id: str = None,
        request_id: str = None,
    ):
        self.alert_event_integration_policy_id = alert_event_integration_policy_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_event_integration_policy_id is not None:
            result['alertEventIntegrationPolicyId'] = self.alert_event_integration_policy_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertEventIntegrationPolicyId') is not None:
            self.alert_event_integration_policy_id = m.get('alertEventIntegrationPolicyId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateAlertEventIntegrationPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAlertEventIntegrationPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAlertEventIntegrationPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAlertNotifyTemplateRequest(TeaModel):
    def __init__(
        self,
        alert_notify_template_name: str = None,
        templates: Dict[str, dict] = None,
    ):
        self.alert_notify_template_name = alert_notify_template_name
        self.templates = templates

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_notify_template_name is not None:
            result['alertNotifyTemplateName'] = self.alert_notify_template_name
        if self.templates is not None:
            result['templates'] = self.templates
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertNotifyTemplateName') is not None:
            self.alert_notify_template_name = m.get('alertNotifyTemplateName')
        if m.get('templates') is not None:
            self.templates = m.get('templates')
        return self


class UpdateAlertNotifyTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateAlertNotifyTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAlertNotifyTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAlertNotifyTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAlertRobotRequest(TeaModel):
    def __init__(
        self,
        is_custom: str = None,
        lang: str = None,
        name: str = None,
        source: str = None,
        type: str = None,
        url: str = None,
    ):
        self.is_custom = is_custom
        self.lang = lang
        self.name = name
        self.source = source
        self.type = type
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_custom is not None:
            result['isCustom'] = self.is_custom
        if self.lang is not None:
            result['lang'] = self.lang
        if self.name is not None:
            result['name'] = self.name
        if self.source is not None:
            result['source'] = self.source
        if self.type is not None:
            result['type'] = self.type
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isCustom') is not None:
            self.is_custom = m.get('isCustom')
        if m.get('lang') is not None:
            self.lang = m.get('lang')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class UpdateAlertRobotResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateAlertRobotResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAlertRobotResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAlertRobotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAlertRuleRequest(TeaModel):
    def __init__(
        self,
        alert_metric_input: AlertRuleAlertMetricInput = None,
        annotations: Dict[str, str] = None,
        condition: AlertRuleCondition = None,
        display_name: str = None,
        effect_time: AlertRuleTimeSpan = None,
        interval: int = None,
        labels: Dict[str, str] = None,
        level: str = None,
        message: str = None,
        query: AlertRuleQuery = None,
        send: AlertRuleSend = None,
    ):
        self.alert_metric_input = alert_metric_input
        # 规则注解，允许设置长文本
        self.annotations = annotations
        self.condition = condition
        # 代表资源名称的资源属性字段
        # 
        # This parameter is required.
        self.display_name = display_name
        self.effect_time = effect_time
        self.interval = interval
        self.labels = labels
        # 告警级别，CRITICAL,ERROR,WARNING,INFO，默认INFO，
        self.level = level
        # 告警规则的通知消息内容
        self.message = message
        # This parameter is required.
        self.query = query
        self.send = send

    def validate(self):
        if self.alert_metric_input:
            self.alert_metric_input.validate()
        if self.condition:
            self.condition.validate()
        if self.effect_time:
            self.effect_time.validate()
        if self.query:
            self.query.validate()
        if self.send:
            self.send.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_metric_input is not None:
            result['alertMetricInput'] = self.alert_metric_input.to_map()
        if self.annotations is not None:
            result['annotations'] = self.annotations
        if self.condition is not None:
            result['condition'] = self.condition.to_map()
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.effect_time is not None:
            result['effectTime'] = self.effect_time.to_map()
        if self.interval is not None:
            result['interval'] = self.interval
        if self.labels is not None:
            result['labels'] = self.labels
        if self.level is not None:
            result['level'] = self.level
        if self.message is not None:
            result['message'] = self.message
        if self.query is not None:
            result['query'] = self.query.to_map()
        if self.send is not None:
            result['send'] = self.send.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alertMetricInput') is not None:
            temp_model = AlertRuleAlertMetricInput()
            self.alert_metric_input = temp_model.from_map(m['alertMetricInput'])
        if m.get('annotations') is not None:
            self.annotations = m.get('annotations')
        if m.get('condition') is not None:
            temp_model = AlertRuleCondition()
            self.condition = temp_model.from_map(m['condition'])
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('effectTime') is not None:
            temp_model = AlertRuleTimeSpan()
            self.effect_time = temp_model.from_map(m['effectTime'])
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('query') is not None:
            temp_model = AlertRuleQuery()
            self.query = temp_model.from_map(m['query'])
        if m.get('send') is not None:
            temp_model = AlertRuleSend()
            self.send = temp_model.from_map(m['send'])
        return self


class UpdateAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        data: int = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAlertWebhookRequest(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        headers: Dict[str, str] = None,
        is_custom: str = None,
        lang: str = None,
        method: str = None,
        name: str = None,
        source: str = None,
        url: str = None,
    ):
        self.content_type = content_type
        self.headers = headers
        self.is_custom = is_custom
        self.lang = lang
        self.method = method
        self.name = name
        self.source = source
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['contentType'] = self.content_type
        if self.headers is not None:
            result['headers'] = self.headers
        if self.is_custom is not None:
            result['isCustom'] = self.is_custom
        if self.lang is not None:
            result['lang'] = self.lang
        if self.method is not None:
            result['method'] = self.method
        if self.name is not None:
            result['name'] = self.name
        if self.source is not None:
            result['source'] = self.source
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contentType') is not None:
            self.content_type = m.get('contentType')
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('isCustom') is not None:
            self.is_custom = m.get('isCustom')
        if m.get('lang') is not None:
            self.lang = m.get('lang')
        if m.get('method') is not None:
            self.method = m.get('method')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class UpdateAlertWebhookResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateAlertWebhookResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAlertWebhookResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAlertWebhookResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateBizTraceRequest(TeaModel):
    def __init__(
        self,
        advanced_config: str = None,
        biz_trace_name: str = None,
        rule_config: str = None,
        workspace: str = None,
    ):
        self.advanced_config = advanced_config
        self.biz_trace_name = biz_trace_name
        self.rule_config = rule_config
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advanced_config is not None:
            result['advancedConfig'] = self.advanced_config
        if self.biz_trace_name is not None:
            result['bizTraceName'] = self.biz_trace_name
        if self.rule_config is not None:
            result['ruleConfig'] = self.rule_config
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('advancedConfig') is not None:
            self.advanced_config = m.get('advancedConfig')
        if m.get('bizTraceName') is not None:
            self.biz_trace_name = m.get('bizTraceName')
        if m.get('ruleConfig') is not None:
            self.rule_config = m.get('ruleConfig')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class UpdateBizTraceResponseBody(TeaModel):
    def __init__(
        self,
        biz_trace_id: str = None,
        request_id: str = None,
    ):
        self.biz_trace_id = biz_trace_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_trace_id is not None:
            result['bizTraceId'] = self.biz_trace_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizTraceId') is not None:
            self.biz_trace_id = m.get('bizTraceId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateBizTraceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateBizTraceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateBizTraceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateContactRequest(TeaModel):
    def __init__(
        self,
        email: str = None,
        im_user_ids: Dict[str, str] = None,
        is_inner_call: bool = None,
        lang: str = None,
        name: str = None,
        phone: str = None,
        phone_code: str = None,
        source: str = None,
    ):
        self.email = email
        self.im_user_ids = im_user_ids
        self.is_inner_call = is_inner_call
        self.lang = lang
        self.name = name
        self.phone = phone
        self.phone_code = phone_code
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.email is not None:
            result['email'] = self.email
        if self.im_user_ids is not None:
            result['imUserIds'] = self.im_user_ids
        if self.is_inner_call is not None:
            result['isInnerCall'] = self.is_inner_call
        if self.lang is not None:
            result['lang'] = self.lang
        if self.name is not None:
            result['name'] = self.name
        if self.phone is not None:
            result['phone'] = self.phone
        if self.phone_code is not None:
            result['phoneCode'] = self.phone_code
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('imUserIds') is not None:
            self.im_user_ids = m.get('imUserIds')
        if m.get('isInnerCall') is not None:
            self.is_inner_call = m.get('isInnerCall')
        if m.get('lang') is not None:
            self.lang = m.get('lang')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('phone') is not None:
            self.phone = m.get('phone')
        if m.get('phoneCode') is not None:
            self.phone_code = m.get('phoneCode')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class UpdateContactResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateContactResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateContactResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateContactResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateContactGroupRequest(TeaModel):
    def __init__(
        self,
        contacts: List[str] = None,
        name: str = None,
        source: str = None,
    ):
        self.contacts = contacts
        self.name = name
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contacts is not None:
            result['contacts'] = self.contacts
        if self.name is not None:
            result['name'] = self.name
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('contacts') is not None:
            self.contacts = m.get('contacts')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class UpdateContactGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateContactGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateContactGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateContactGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateEntityGroupRequestEntityRulesAnnotations(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class UpdateEntityGroupRequestEntityRulesFieldRules(TeaModel):
    def __init__(
        self,
        field_key: str = None,
        field_values: List[str] = None,
        op: str = None,
    ):
        self.field_key = field_key
        self.field_values = field_values
        self.op = op

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_key is not None:
            result['fieldKey'] = self.field_key
        if self.field_values is not None:
            result['fieldValues'] = self.field_values
        if self.op is not None:
            result['op'] = self.op
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldKey') is not None:
            self.field_key = m.get('fieldKey')
        if m.get('fieldValues') is not None:
            self.field_values = m.get('fieldValues')
        if m.get('op') is not None:
            self.op = m.get('op')
        return self


class UpdateEntityGroupRequestEntityRulesIpMatchRule(TeaModel):
    def __init__(
        self,
        ip_cidr: str = None,
        ip_field_key: str = None,
    ):
        self.ip_cidr = ip_cidr
        self.ip_field_key = ip_field_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_cidr is not None:
            result['ipCIDR'] = self.ip_cidr
        if self.ip_field_key is not None:
            result['ipFieldKey'] = self.ip_field_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ipCIDR') is not None:
            self.ip_cidr = m.get('ipCIDR')
        if m.get('ipFieldKey') is not None:
            self.ip_field_key = m.get('ipFieldKey')
        return self


class UpdateEntityGroupRequestEntityRulesLabels(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class UpdateEntityGroupRequestEntityRulesTags(TeaModel):
    def __init__(
        self,
        op: str = None,
        tag_key: str = None,
        tag_values: List[str] = None,
    ):
        self.op = op
        self.tag_key = tag_key
        self.tag_values = tag_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.tag_key is not None:
            result['tagKey'] = self.tag_key
        if self.tag_values is not None:
            result['tagValues'] = self.tag_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('tagKey') is not None:
            self.tag_key = m.get('tagKey')
        if m.get('tagValues') is not None:
            self.tag_values = m.get('tagValues')
        return self


class UpdateEntityGroupRequestEntityRules(TeaModel):
    def __init__(
        self,
        annotations: List[UpdateEntityGroupRequestEntityRulesAnnotations] = None,
        entity_types: List[str] = None,
        field_rules: List[UpdateEntityGroupRequestEntityRulesFieldRules] = None,
        instance_ids: List[str] = None,
        ip_match_rule: UpdateEntityGroupRequestEntityRulesIpMatchRule = None,
        labels: List[UpdateEntityGroupRequestEntityRulesLabels] = None,
        region_ids: List[str] = None,
        resource_group_id: str = None,
        tags: List[UpdateEntityGroupRequestEntityRulesTags] = None,
    ):
        self.annotations = annotations
        self.entity_types = entity_types
        self.field_rules = field_rules
        self.instance_ids = instance_ids
        self.ip_match_rule = ip_match_rule
        self.labels = labels
        self.region_ids = region_ids
        self.resource_group_id = resource_group_id
        self.tags = tags

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.field_rules:
            for k in self.field_rules:
                if k:
                    k.validate()
        if self.ip_match_rule:
            self.ip_match_rule.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        if self.entity_types is not None:
            result['entityTypes'] = self.entity_types
        result['fieldRules'] = []
        if self.field_rules is not None:
            for k in self.field_rules:
                result['fieldRules'].append(k.to_map() if k else None)
        if self.instance_ids is not None:
            result['instanceIds'] = self.instance_ids
        if self.ip_match_rule is not None:
            result['ipMatchRule'] = self.ip_match_rule.to_map()
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.region_ids is not None:
            result['regionIds'] = self.region_ids
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = UpdateEntityGroupRequestEntityRulesAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('entityTypes') is not None:
            self.entity_types = m.get('entityTypes')
        self.field_rules = []
        if m.get('fieldRules') is not None:
            for k in m.get('fieldRules'):
                temp_model = UpdateEntityGroupRequestEntityRulesFieldRules()
                self.field_rules.append(temp_model.from_map(k))
        if m.get('instanceIds') is not None:
            self.instance_ids = m.get('instanceIds')
        if m.get('ipMatchRule') is not None:
            temp_model = UpdateEntityGroupRequestEntityRulesIpMatchRule()
            self.ip_match_rule = temp_model.from_map(m['ipMatchRule'])
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = UpdateEntityGroupRequestEntityRulesLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('regionIds') is not None:
            self.region_ids = m.get('regionIds')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = UpdateEntityGroupRequestEntityRulesTags()
                self.tags.append(temp_model.from_map(k))
        return self


class UpdateEntityGroupRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        entity_group_name: str = None,
        entity_rules: UpdateEntityGroupRequestEntityRules = None,
        workspace: str = None,
    ):
        self.description = description
        self.entity_group_name = entity_group_name
        # This parameter is required.
        self.entity_rules = entity_rules
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        if self.entity_rules:
            self.entity_rules.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.entity_group_name is not None:
            result['entityGroupName'] = self.entity_group_name
        if self.entity_rules is not None:
            result['entityRules'] = self.entity_rules.to_map()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('entityGroupName') is not None:
            self.entity_group_name = m.get('entityGroupName')
        if m.get('entityRules') is not None:
            temp_model = UpdateEntityGroupRequestEntityRules()
            self.entity_rules = temp_model.from_map(m['entityRules'])
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class UpdateEntityGroupResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateEntityGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateEntityGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateEntityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateEnvDropMetricsRuleRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        drop_metrics: str = None,
        environment_id: str = None,
        region_id: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        # This parameter is required.
        self.drop_metrics = drop_metrics
        # This parameter is required.
        self.environment_id = environment_id
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.drop_metrics is not None:
            result['DropMetrics'] = self.drop_metrics
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('DropMetrics') is not None:
            self.drop_metrics = m.get('DropMetrics')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdateEnvDropMetricsRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateEnvDropMetricsRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateEnvDropMetricsRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateEnvDropMetricsRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateEscalationRequest(TeaModel):
    def __init__(
        self,
        body: EscalationForUpdate = None,
        workspace: str = None,
    ):
        self.body = body
        # This parameter is required.
        self.workspace = workspace

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body.to_map()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            temp_model = EscalationForUpdate()
            self.body = temp_model.from_map(m['body'])
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class UpdateEscalationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        uuid: str = None,
    ):
        self.request_id = request_id
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class UpdateEscalationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateEscalationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateEscalationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateIncidentEscalationRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        incident_escalation_id: str = None,
        name: str = None,
        stage: List[IncidentEscalationStageStruct] = None,
        workspace: str = None,
    ):
        self.description = description
        self.incident_escalation_id = incident_escalation_id
        self.name = name
        self.stage = stage
        self.workspace = workspace

    def validate(self):
        if self.stage:
            for k in self.stage:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.incident_escalation_id is not None:
            result['incidentEscalationId'] = self.incident_escalation_id
        if self.name is not None:
            result['name'] = self.name
        result['stage'] = []
        if self.stage is not None:
            for k in self.stage:
                result['stage'].append(k.to_map() if k else None)
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('incidentEscalationId') is not None:
            self.incident_escalation_id = m.get('incidentEscalationId')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.stage = []
        if m.get('stage') is not None:
            for k in m.get('stage'):
                temp_model = IncidentEscalationStageStruct()
                self.stage.append(temp_model.from_map(k))
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class UpdateIncidentEscalationResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateIncidentEscalationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateIncidentEscalationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateIncidentEscalationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateIncidentPlanRequestCorporation(TeaModel):
    def __init__(
        self,
        channel: str = None,
        robot_id: str = None,
    ):
        self.channel = channel
        self.robot_id = robot_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel is not None:
            result['channel'] = self.channel
        if self.robot_id is not None:
            result['robotId'] = self.robot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('channel') is not None:
            self.channel = m.get('channel')
        if m.get('robotId') is not None:
            self.robot_id = m.get('robotId')
        return self


class UpdateIncidentPlanRequest(TeaModel):
    def __init__(
        self,
        auto_recover_seconds: int = None,
        corporation: List[UpdateIncidentPlanRequestCorporation] = None,
        description: str = None,
        escalation_id: List[str] = None,
        group_by: List[IncidentPlanFieldPath] = None,
        incident_plan_id: str = None,
        name: str = None,
        pause_expire: int = None,
        resource_field: List[IncidentPlanFieldPath] = None,
        status: str = None,
    ):
        self.auto_recover_seconds = auto_recover_seconds
        self.corporation = corporation
        self.description = description
        self.escalation_id = escalation_id
        self.group_by = group_by
        self.incident_plan_id = incident_plan_id
        self.name = name
        self.pause_expire = pause_expire
        self.resource_field = resource_field
        self.status = status

    def validate(self):
        if self.corporation:
            for k in self.corporation:
                if k:
                    k.validate()
        if self.group_by:
            for k in self.group_by:
                if k:
                    k.validate()
        if self.resource_field:
            for k in self.resource_field:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_recover_seconds is not None:
            result['autoRecoverSeconds'] = self.auto_recover_seconds
        result['corporation'] = []
        if self.corporation is not None:
            for k in self.corporation:
                result['corporation'].append(k.to_map() if k else None)
        if self.description is not None:
            result['description'] = self.description
        if self.escalation_id is not None:
            result['escalationId'] = self.escalation_id
        result['groupBy'] = []
        if self.group_by is not None:
            for k in self.group_by:
                result['groupBy'].append(k.to_map() if k else None)
        if self.incident_plan_id is not None:
            result['incidentPlanId'] = self.incident_plan_id
        if self.name is not None:
            result['name'] = self.name
        if self.pause_expire is not None:
            result['pauseExpire'] = self.pause_expire
        result['resourceField'] = []
        if self.resource_field is not None:
            for k in self.resource_field:
                result['resourceField'].append(k.to_map() if k else None)
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('autoRecoverSeconds') is not None:
            self.auto_recover_seconds = m.get('autoRecoverSeconds')
        self.corporation = []
        if m.get('corporation') is not None:
            for k in m.get('corporation'):
                temp_model = UpdateIncidentPlanRequestCorporation()
                self.corporation.append(temp_model.from_map(k))
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('escalationId') is not None:
            self.escalation_id = m.get('escalationId')
        self.group_by = []
        if m.get('groupBy') is not None:
            for k in m.get('groupBy'):
                temp_model = IncidentPlanFieldPath()
                self.group_by.append(temp_model.from_map(k))
        if m.get('incidentPlanId') is not None:
            self.incident_plan_id = m.get('incidentPlanId')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pauseExpire') is not None:
            self.pause_expire = m.get('pauseExpire')
        self.resource_field = []
        if m.get('resourceField') is not None:
            for k in m.get('resourceField'):
                temp_model = IncidentPlanFieldPath()
                self.resource_field.append(temp_model.from_map(k))
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class UpdateIncidentPlanResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateIncidentPlanResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateIncidentPlanResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateIncidentPlanResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateIntegrationRequest(TeaModel):
    def __init__(
        self,
        body: IntegrationForModify = None,
        client_token: str = None,
        workspace: str = None,
    ):
        self.body = body
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body.to_map()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            temp_model = IntegrationForModify()
            self.body = temp_model.from_map(m['body'])
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class UpdateIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        integration_id: str = None,
        request_id: str = None,
    ):
        self.integration_id = integration_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integration_id is not None:
            result['integrationId'] = self.integration_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('integrationId') is not None:
            self.integration_id = m.get('integrationId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateIntegrationPolicyRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class UpdateIntegrationPolicyRequest(TeaModel):
    def __init__(
        self,
        fee_package: str = None,
        policy_name: str = None,
        resource_group_id: str = None,
        tags: List[UpdateIntegrationPolicyRequestTags] = None,
    ):
        self.fee_package = fee_package
        self.policy_name = policy_name
        self.resource_group_id = resource_group_id
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fee_package is not None:
            result['feePackage'] = self.fee_package
        if self.policy_name is not None:
            result['policyName'] = self.policy_name
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('feePackage') is not None:
            self.fee_package = m.get('feePackage')
        if m.get('policyName') is not None:
            self.policy_name = m.get('policyName')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = UpdateIntegrationPolicyRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class UpdateIntegrationPolicyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateIntegrationPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateIntegrationPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateIntegrationPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMaintainWindowRequest(TeaModel):
    def __init__(
        self,
        body: MaintainWindowForModify = None,
        client_token: str = None,
        workspace: str = None,
    ):
        self.body = body
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body.to_map()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            temp_model = MaintainWindowForModify()
            self.body = temp_model.from_map(m['body'])
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class UpdateMaintainWindowResponseBody(TeaModel):
    def __init__(
        self,
        maintain_window_id: str = None,
        request_id: str = None,
    ):
        self.maintain_window_id = maintain_window_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.maintain_window_id is not None:
            result['maintainWindowId'] = self.maintain_window_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maintainWindowId') is not None:
            self.maintain_window_id = m.get('maintainWindowId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateMaintainWindowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMaintainWindowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMaintainWindowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateNotifyStrategyRequest(TeaModel):
    def __init__(
        self,
        body: NotifyStrategyForModify = None,
        client_token: str = None,
        workspace: str = None,
    ):
        self.body = body
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body.to_map()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            temp_model = NotifyStrategyForModify()
            self.body = temp_model.from_map(m['body'])
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class UpdateNotifyStrategyResponseBody(TeaModel):
    def __init__(
        self,
        notify_strategy_id: str = None,
        request_id: str = None,
    ):
        self.notify_strategy_id = notify_strategy_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify_strategy_id is not None:
            result['notifyStrategyId'] = self.notify_strategy_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('notifyStrategyId') is not None:
            self.notify_strategy_id = m.get('notifyStrategyId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateNotifyStrategyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateNotifyStrategyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateNotifyStrategyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateOncallScheduleRequestRotations(TeaModel):
    def __init__(
        self,
        active_days: List[int] = None,
        contacts: List[str] = None,
        rotation_end_time: str = None,
        rotation_name: str = None,
        rotation_start_time: str = None,
        shift_length: int = None,
        shift_recurrence_frequency: str = None,
        start_date: str = None,
        time_zone: str = None,
    ):
        # This parameter is required.
        self.active_days = active_days
        # This parameter is required.
        self.contacts = contacts
        # This parameter is required.
        self.rotation_end_time = rotation_end_time
        # This parameter is required.
        self.rotation_name = rotation_name
        # This parameter is required.
        self.rotation_start_time = rotation_start_time
        self.shift_length = shift_length
        # This parameter is required.
        self.shift_recurrence_frequency = shift_recurrence_frequency
        # This parameter is required.
        self.start_date = start_date
        # This parameter is required.
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_days is not None:
            result['activeDays'] = self.active_days
        if self.contacts is not None:
            result['contacts'] = self.contacts
        if self.rotation_end_time is not None:
            result['rotationEndTime'] = self.rotation_end_time
        if self.rotation_name is not None:
            result['rotationName'] = self.rotation_name
        if self.rotation_start_time is not None:
            result['rotationStartTime'] = self.rotation_start_time
        if self.shift_length is not None:
            result['shiftLength'] = self.shift_length
        if self.shift_recurrence_frequency is not None:
            result['shiftRecurrenceFrequency'] = self.shift_recurrence_frequency
        if self.start_date is not None:
            result['startDate'] = self.start_date
        if self.time_zone is not None:
            result['timeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('activeDays') is not None:
            self.active_days = m.get('activeDays')
        if m.get('contacts') is not None:
            self.contacts = m.get('contacts')
        if m.get('rotationEndTime') is not None:
            self.rotation_end_time = m.get('rotationEndTime')
        if m.get('rotationName') is not None:
            self.rotation_name = m.get('rotationName')
        if m.get('rotationStartTime') is not None:
            self.rotation_start_time = m.get('rotationStartTime')
        if m.get('shiftLength') is not None:
            self.shift_length = m.get('shiftLength')
        if m.get('shiftRecurrenceFrequency') is not None:
            self.shift_recurrence_frequency = m.get('shiftRecurrenceFrequency')
        if m.get('startDate') is not None:
            self.start_date = m.get('startDate')
        if m.get('timeZone') is not None:
            self.time_zone = m.get('timeZone')
        return self


class UpdateOncallScheduleRequest(TeaModel):
    def __init__(
        self,
        oncall_schedule_name: str = None,
        rotations: List[UpdateOncallScheduleRequestRotations] = None,
        shift_robot_id: str = None,
        source: str = None,
    ):
        self.oncall_schedule_name = oncall_schedule_name
        self.rotations = rotations
        self.shift_robot_id = shift_robot_id
        self.source = source

    def validate(self):
        if self.rotations:
            for k in self.rotations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.oncall_schedule_name is not None:
            result['oncallScheduleName'] = self.oncall_schedule_name
        result['rotations'] = []
        if self.rotations is not None:
            for k in self.rotations:
                result['rotations'].append(k.to_map() if k else None)
        if self.shift_robot_id is not None:
            result['shiftRobotId'] = self.shift_robot_id
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('oncallScheduleName') is not None:
            self.oncall_schedule_name = m.get('oncallScheduleName')
        self.rotations = []
        if m.get('rotations') is not None:
            for k in m.get('rotations'):
                temp_model = UpdateOncallScheduleRequestRotations()
                self.rotations.append(temp_model.from_map(k))
        if m.get('shiftRobotId') is not None:
            self.shift_robot_id = m.get('shiftRobotId')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class UpdateOncallScheduleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateOncallScheduleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateOncallScheduleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateOncallScheduleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePolicyRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        fee_package: str = None,
        policy_name: str = None,
        region_id: str = None,
    ):
        self.aliyun_lang = aliyun_lang
        self.fee_package = fee_package
        self.policy_name = policy_name
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['aliyunLang'] = self.aliyun_lang
        if self.fee_package is not None:
            result['feePackage'] = self.fee_package
        if self.policy_name is not None:
            result['policyName'] = self.policy_name
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunLang') is not None:
            self.aliyun_lang = m.get('aliyunLang')
        if m.get('feePackage') is not None:
            self.fee_package = m.get('feePackage')
        if m.get('policyName') is not None:
            self.policy_name = m.get('policyName')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class UpdatePolicyResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdatePolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePrometheusInstanceRequest(TeaModel):
    def __init__(
        self,
        archive_duration: int = None,
        auth_free_read_policy: str = None,
        auth_free_write_policy: str = None,
        enable_auth_free_read: bool = None,
        enable_auth_free_write: bool = None,
        enable_auth_token: bool = None,
        payment_type: str = None,
        prometheus_instance_name: str = None,
        status: str = None,
        storage_duration: int = None,
    ):
        self.archive_duration = archive_duration
        self.auth_free_read_policy = auth_free_read_policy
        self.auth_free_write_policy = auth_free_write_policy
        self.enable_auth_free_read = enable_auth_free_read
        self.enable_auth_free_write = enable_auth_free_write
        self.enable_auth_token = enable_auth_token
        self.payment_type = payment_type
        self.prometheus_instance_name = prometheus_instance_name
        self.status = status
        self.storage_duration = storage_duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.archive_duration is not None:
            result['archiveDuration'] = self.archive_duration
        if self.auth_free_read_policy is not None:
            result['authFreeReadPolicy'] = self.auth_free_read_policy
        if self.auth_free_write_policy is not None:
            result['authFreeWritePolicy'] = self.auth_free_write_policy
        if self.enable_auth_free_read is not None:
            result['enableAuthFreeRead'] = self.enable_auth_free_read
        if self.enable_auth_free_write is not None:
            result['enableAuthFreeWrite'] = self.enable_auth_free_write
        if self.enable_auth_token is not None:
            result['enableAuthToken'] = self.enable_auth_token
        if self.payment_type is not None:
            result['paymentType'] = self.payment_type
        if self.prometheus_instance_name is not None:
            result['prometheusInstanceName'] = self.prometheus_instance_name
        if self.status is not None:
            result['status'] = self.status
        if self.storage_duration is not None:
            result['storageDuration'] = self.storage_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('archiveDuration') is not None:
            self.archive_duration = m.get('archiveDuration')
        if m.get('authFreeReadPolicy') is not None:
            self.auth_free_read_policy = m.get('authFreeReadPolicy')
        if m.get('authFreeWritePolicy') is not None:
            self.auth_free_write_policy = m.get('authFreeWritePolicy')
        if m.get('enableAuthFreeRead') is not None:
            self.enable_auth_free_read = m.get('enableAuthFreeRead')
        if m.get('enableAuthFreeWrite') is not None:
            self.enable_auth_free_write = m.get('enableAuthFreeWrite')
        if m.get('enableAuthToken') is not None:
            self.enable_auth_token = m.get('enableAuthToken')
        if m.get('paymentType') is not None:
            self.payment_type = m.get('paymentType')
        if m.get('prometheusInstanceName') is not None:
            self.prometheus_instance_name = m.get('prometheusInstanceName')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('storageDuration') is not None:
            self.storage_duration = m.get('storageDuration')
        return self


class UpdatePrometheusInstanceResponseBody(TeaModel):
    def __init__(
        self,
        prometheus_instance_id: str = None,
        request_id: str = None,
    ):
        self.prometheus_instance_id = prometheus_instance_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_instance_id is not None:
            result['prometheusInstanceId'] = self.prometheus_instance_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('prometheusInstanceId') is not None:
            self.prometheus_instance_id = m.get('prometheusInstanceId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdatePrometheusInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePrometheusInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePrometheusInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePrometheusUserSettingRequest(TeaModel):
    def __init__(
        self,
        setting_value: str = None,
    ):
        # This parameter is required.
        self.setting_value = setting_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.setting_value is not None:
            result['settingValue'] = self.setting_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('settingValue') is not None:
            self.setting_value = m.get('settingValue')
        return self


class UpdatePrometheusUserSettingResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdatePrometheusUserSettingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePrometheusUserSettingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePrometheusUserSettingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePrometheusViewRequestPrometheusInstances(TeaModel):
    def __init__(
        self,
        prometheus_instance_id: str = None,
        region_id: str = None,
        user_id: str = None,
    ):
        self.prometheus_instance_id = prometheus_instance_id
        self.region_id = region_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_instance_id is not None:
            result['prometheusInstanceId'] = self.prometheus_instance_id
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('prometheusInstanceId') is not None:
            self.prometheus_instance_id = m.get('prometheusInstanceId')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class UpdatePrometheusViewRequest(TeaModel):
    def __init__(
        self,
        auth_free_read_policy: str = None,
        enable_auth_free_read: bool = None,
        enable_auth_token: bool = None,
        prometheus_instances: List[UpdatePrometheusViewRequestPrometheusInstances] = None,
        prometheus_view_name: str = None,
        status: str = None,
    ):
        self.auth_free_read_policy = auth_free_read_policy
        self.enable_auth_free_read = enable_auth_free_read
        self.enable_auth_token = enable_auth_token
        self.prometheus_instances = prometheus_instances
        self.prometheus_view_name = prometheus_view_name
        self.status = status

    def validate(self):
        if self.prometheus_instances:
            for k in self.prometheus_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_free_read_policy is not None:
            result['authFreeReadPolicy'] = self.auth_free_read_policy
        if self.enable_auth_free_read is not None:
            result['enableAuthFreeRead'] = self.enable_auth_free_read
        if self.enable_auth_token is not None:
            result['enableAuthToken'] = self.enable_auth_token
        result['prometheusInstances'] = []
        if self.prometheus_instances is not None:
            for k in self.prometheus_instances:
                result['prometheusInstances'].append(k.to_map() if k else None)
        if self.prometheus_view_name is not None:
            result['prometheusViewName'] = self.prometheus_view_name
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authFreeReadPolicy') is not None:
            self.auth_free_read_policy = m.get('authFreeReadPolicy')
        if m.get('enableAuthFreeRead') is not None:
            self.enable_auth_free_read = m.get('enableAuthFreeRead')
        if m.get('enableAuthToken') is not None:
            self.enable_auth_token = m.get('enableAuthToken')
        self.prometheus_instances = []
        if m.get('prometheusInstances') is not None:
            for k in m.get('prometheusInstances'):
                temp_model = UpdatePrometheusViewRequestPrometheusInstances()
                self.prometheus_instances.append(temp_model.from_map(k))
        if m.get('prometheusViewName') is not None:
            self.prometheus_view_name = m.get('prometheusViewName')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class UpdatePrometheusViewResponseBody(TeaModel):
    def __init__(
        self,
        prometheus_view_id: str = None,
        request_id: str = None,
    ):
        self.prometheus_view_id = prometheus_view_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_view_id is not None:
            result['prometheusViewId'] = self.prometheus_view_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('prometheusViewId') is not None:
            self.prometheus_view_id = m.get('prometheusViewId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdatePrometheusViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePrometheusViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePrometheusViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSubscriptionRequest(TeaModel):
    def __init__(
        self,
        body: SubscriptionForModify = None,
        client_token: str = None,
        workspace: str = None,
    ):
        self.body = body
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body.to_map()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            temp_model = SubscriptionForModify()
            self.body = temp_model.from_map(m['body'])
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class UpdateSubscriptionResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        subscription_id: str = None,
    ):
        self.request_id = request_id
        self.subscription_id = subscription_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.subscription_id is not None:
            result['subscriptionId'] = self.subscription_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('subscriptionId') is not None:
            self.subscription_id = m.get('subscriptionId')
        return self


class UpdateSubscriptionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSubscriptionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSubscriptionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTransformerRequest(TeaModel):
    def __init__(
        self,
        body: TransformerForModify = None,
        client_token: str = None,
        workspace: str = None,
    ):
        self.body = body
        self.client_token = client_token
        self.workspace = workspace

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['body'] = self.body.to_map()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            temp_model = TransformerForModify()
            self.body = temp_model.from_map(m['body'])
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class UpdateTransformerResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        transformer_id: str = None,
    ):
        self.request_id = request_id
        self.transformer_id = transformer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.transformer_id is not None:
            result['transformerId'] = self.transformer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('transformerId') is not None:
            self.transformer_id = m.get('transformerId')
        return self


class UpdateTransformerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTransformerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTransformerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTransformerSortIdRequest(TeaModel):
    def __init__(
        self,
        client_token: str = None,
        sort_id: int = None,
        workspace: str = None,
    ):
        self.client_token = client_token
        self.sort_id = sort_id
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['clientToken'] = self.client_token
        if self.sort_id is not None:
            result['sortId'] = self.sort_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clientToken') is not None:
            self.client_token = m.get('clientToken')
        if m.get('sortId') is not None:
            self.sort_id = m.get('sortId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class UpdateTransformerSortIdResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        transformer_id: str = None,
    ):
        self.request_id = request_id
        self.transformer_id = transformer_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.transformer_id is not None:
            result['transformerId'] = self.transformer_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('transformerId') is not None:
            self.transformer_id = m.get('transformerId')
        return self


class UpdateTransformerSortIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTransformerSortIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTransformerSortIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateUmodelRequestCommonSchemaRef(TeaModel):
    def __init__(
        self,
        group: str = None,
        items: List[str] = None,
        version: str = None,
    ):
        self.group = group
        self.items = items
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group is not None:
            result['group'] = self.group
        if self.items is not None:
            result['items'] = self.items
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('group') is not None:
            self.group = m.get('group')
        if m.get('items') is not None:
            self.items = m.get('items')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class UpdateUmodelRequest(TeaModel):
    def __init__(
        self,
        common_schema_ref: List[UpdateUmodelRequestCommonSchemaRef] = None,
        description: str = None,
    ):
        self.common_schema_ref = common_schema_ref
        self.description = description

    def validate(self):
        if self.common_schema_ref:
            for k in self.common_schema_ref:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['commonSchemaRef'] = []
        if self.common_schema_ref is not None:
            for k in self.common_schema_ref:
                result['commonSchemaRef'].append(k.to_map() if k else None)
        if self.description is not None:
            result['description'] = self.description
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.common_schema_ref = []
        if m.get('commonSchemaRef') is not None:
            for k in m.get('commonSchemaRef'):
                temp_model = UpdateUmodelRequestCommonSchemaRef()
                self.common_schema_ref.append(temp_model.from_map(k))
        if m.get('description') is not None:
            self.description = m.get('description')
        return self


class UpdateUmodelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        workspace: str = None,
    ):
        self.request_id = request_id
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class UpdateUmodelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateUmodelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateUmodelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpgradeAddonReleaseRequest(TeaModel):
    def __init__(
        self,
        addon_version: str = None,
        dry_run: bool = None,
        values: str = None,
    ):
        self.addon_version = addon_version
        self.dry_run = dry_run
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_version is not None:
            result['addonVersion'] = self.addon_version
        if self.dry_run is not None:
            result['dryRun'] = self.dry_run
        if self.values is not None:
            result['values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addonVersion') is not None:
            self.addon_version = m.get('addonVersion')
        if m.get('dryRun') is not None:
            self.dry_run = m.get('dryRun')
        if m.get('values') is not None:
            self.values = m.get('values')
        return self


class UpgradeAddonReleaseResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpgradeAddonReleaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpgradeAddonReleaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpgradeAddonReleaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpsertUmodelDataRequest(TeaModel):
    def __init__(
        self,
        elements: List[Any] = None,
        method: str = None,
    ):
        self.elements = elements
        self.method = method

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.elements is not None:
            result['elements'] = self.elements
        if self.method is not None:
            result['method'] = self.method
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('elements') is not None:
            self.elements = m.get('elements')
        if m.get('method') is not None:
            self.method = m.get('method')
        return self


class UpsertUmodelDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpsertUmodelDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpsertUmodelDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpsertUmodelDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpsertUmodelDataTestHeaders(TeaModel):
    def __init__(
        self,
        common_headers: Dict[str, str] = None,
        x_logapiversion: str = None,
    ):
        self.common_headers = common_headers
        self.x_logapiversion = x_logapiversion

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_headers is not None:
            result['commonHeaders'] = self.common_headers
        if self.x_logapiversion is not None:
            result['X-LOG-APIVERSION'] = self.x_logapiversion
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commonHeaders') is not None:
            self.common_headers = m.get('commonHeaders')
        if m.get('X-LOG-APIVERSION') is not None:
            self.x_logapiversion = m.get('X-LOG-APIVERSION')
        return self


class UpsertUmodelDataTestRequest(TeaModel):
    def __init__(
        self,
        elements: List[Any] = None,
        method: str = None,
    ):
        self.elements = elements
        self.method = method

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.elements is not None:
            result['elements'] = self.elements
        if self.method is not None:
            result['method'] = self.method
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('elements') is not None:
            self.elements = m.get('elements')
        if m.get('method') is not None:
            self.method = m.get('method')
        return self


class UpsertUmodelDataTestResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpsertUmodelDataTestResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpsertUmodelDataTestResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpsertUmodelDataTestResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ViewOncallScheduleRequestUnSavedScheduleRotations(TeaModel):
    def __init__(
        self,
        active_days: List[int] = None,
        contacts: List[str] = None,
        rotation_end_time: str = None,
        rotation_name: str = None,
        rotation_start_time: str = None,
        shift_length: int = None,
        shift_recurrence_frequency: str = None,
        start_date: str = None,
        time_zone: str = None,
    ):
        self.active_days = active_days
        self.contacts = contacts
        self.rotation_end_time = rotation_end_time
        self.rotation_name = rotation_name
        self.rotation_start_time = rotation_start_time
        self.shift_length = shift_length
        self.shift_recurrence_frequency = shift_recurrence_frequency
        self.start_date = start_date
        self.time_zone = time_zone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_days is not None:
            result['activeDays'] = self.active_days
        if self.contacts is not None:
            result['contacts'] = self.contacts
        if self.rotation_end_time is not None:
            result['rotationEndTime'] = self.rotation_end_time
        if self.rotation_name is not None:
            result['rotationName'] = self.rotation_name
        if self.rotation_start_time is not None:
            result['rotationStartTime'] = self.rotation_start_time
        if self.shift_length is not None:
            result['shiftLength'] = self.shift_length
        if self.shift_recurrence_frequency is not None:
            result['shiftRecurrenceFrequency'] = self.shift_recurrence_frequency
        if self.start_date is not None:
            result['startDate'] = self.start_date
        if self.time_zone is not None:
            result['timeZone'] = self.time_zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('activeDays') is not None:
            self.active_days = m.get('activeDays')
        if m.get('contacts') is not None:
            self.contacts = m.get('contacts')
        if m.get('rotationEndTime') is not None:
            self.rotation_end_time = m.get('rotationEndTime')
        if m.get('rotationName') is not None:
            self.rotation_name = m.get('rotationName')
        if m.get('rotationStartTime') is not None:
            self.rotation_start_time = m.get('rotationStartTime')
        if m.get('shiftLength') is not None:
            self.shift_length = m.get('shiftLength')
        if m.get('shiftRecurrenceFrequency') is not None:
            self.shift_recurrence_frequency = m.get('shiftRecurrenceFrequency')
        if m.get('startDate') is not None:
            self.start_date = m.get('startDate')
        if m.get('timeZone') is not None:
            self.time_zone = m.get('timeZone')
        return self


class ViewOncallScheduleRequestUnSavedSchedule(TeaModel):
    def __init__(
        self,
        rotations: List[ViewOncallScheduleRequestUnSavedScheduleRotations] = None,
    ):
        self.rotations = rotations

    def validate(self):
        if self.rotations:
            for k in self.rotations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['rotations'] = []
        if self.rotations is not None:
            for k in self.rotations:
                result['rotations'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.rotations = []
        if m.get('rotations') is not None:
            for k in m.get('rotations'):
                temp_model = ViewOncallScheduleRequestUnSavedScheduleRotations()
                self.rotations.append(temp_model.from_map(k))
        return self


class ViewOncallScheduleRequest(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        source: str = None,
        start_date: str = None,
        un_saved_schedule: ViewOncallScheduleRequestUnSavedSchedule = None,
    ):
        self.end_date = end_date
        self.source = source
        self.start_date = start_date
        self.un_saved_schedule = un_saved_schedule

    def validate(self):
        if self.un_saved_schedule:
            self.un_saved_schedule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['endDate'] = self.end_date
        if self.source is not None:
            result['source'] = self.source
        if self.start_date is not None:
            result['startDate'] = self.start_date
        if self.un_saved_schedule is not None:
            result['unSavedSchedule'] = self.un_saved_schedule.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endDate') is not None:
            self.end_date = m.get('endDate')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('startDate') is not None:
            self.start_date = m.get('startDate')
        if m.get('unSavedSchedule') is not None:
            temp_model = ViewOncallScheduleRequestUnSavedSchedule()
            self.un_saved_schedule = temp_model.from_map(m['unSavedSchedule'])
        return self


class ViewOncallScheduleShrinkRequest(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        source: str = None,
        start_date: str = None,
        un_saved_schedule_shrink: str = None,
    ):
        self.end_date = end_date
        self.source = source
        self.start_date = start_date
        self.un_saved_schedule_shrink = un_saved_schedule_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['endDate'] = self.end_date
        if self.source is not None:
            result['source'] = self.source
        if self.start_date is not None:
            result['startDate'] = self.start_date
        if self.un_saved_schedule_shrink is not None:
            result['unSavedSchedule'] = self.un_saved_schedule_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endDate') is not None:
            self.end_date = m.get('endDate')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('startDate') is not None:
            self.start_date = m.get('startDate')
        if m.get('unSavedSchedule') is not None:
            self.un_saved_schedule_shrink = m.get('unSavedSchedule')
        return self


class ViewOncallScheduleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        schedule: Dict[str, List[ScheduleValue]] = None,
    ):
        self.request_id = request_id
        self.schedule = schedule

    def validate(self):
        if self.schedule:
            for v in self.schedule.values():
                for k1 in v:
                    if k1:
                        k1.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['schedule'] = {}
        if self.schedule is not None:
            for k, v in self.schedule.items():
                l1 = []
                for k1 in v:
                    l1.append(k1.to_map() if k1 else None)
                result['schedule'][k] = l1
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.schedule = {}
        if m.get('schedule') is not None:
            for k, v in m.get('schedule').items():
                l1 = []
                for k1 in v:
                    temp_model = ScheduleValue()
                    l1.append(temp_model.from_map(k1))
                self.schedule['k'] = l1
        return self


class ViewOncallScheduleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ViewOncallScheduleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ViewOncallScheduleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


